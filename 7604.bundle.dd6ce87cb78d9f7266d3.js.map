{"version":3,"file":"7604.bundle.dd6ce87cb78d9f7266d3.js","mappings":"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","sources":["webpack:///../../../node_modules/dicomweb-client/src/message.js","webpack:///../../../node_modules/dicomweb-client/src/api.js","webpack:///../../../node_modules/dicomweb-client/src/version.js","webpack:///../../../node_modules/dicomweb-client/src/dicomweb-client.js"],"sourcesContent":["/**\n * Converts a Uint8Array to a String.\n * @param {Uint8Array} array that should be converted\n * @param {Number} offset array offset in case only subset of array items should\n                   be extracted (default: 0)\n * @param {Number} limit maximum number of array items that should be extracted\n                   (defaults to length of array)\n * @returns {String}\n */\nfunction uint8ArrayToString(arr, offset = 0, limit) {\n  const itemLimit = limit || arr.length - offset;\n  let str = '';\n  for (let i = offset; i < offset + itemLimit; i++) {\n    str += String.fromCharCode(arr[i]);\n  }\n  return str;\n}\n\n/**\n * Converts a String to a Uint8Array.\n * @param {String} str string that should be converted\n * @returns {Uint8Array}\n */\nfunction stringToUint8Array(str) {\n  const arr = new Uint8Array(str.length);\n  for (let i = 0, j = str.length; i < j; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\n/**\n * Identifies the boundary in a multipart/related message header.\n * @param {String} header message header\n * @returns {String} boundary\n */\nfunction identifyBoundary(header) {\n  const parts = header.split('\\r\\n');\n\n  for (let i = 0; i < parts.length; i++) {\n    if (parts[i].substring(0, 2) === '--') {\n      return parts[i];\n    }\n  }\n\n  return null;\n}\n\n/**\n * Checks whether a given token is contained by a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be present\n * @param {Number} offset offset in message content from where search should start\n * @returns {Boolean} whether message contains token at offset\n */\nfunction containsToken(message, token, offset = 0) {\n  if (offset + token.length > message.length) {\n    return false;\n  }\n\n  let index = offset;\n  for (let i = 0; i < token.length; i++) {\n    if (token[i] !== message[index]) {\n      return false;\n    }\n\n    index += 1;\n  }\n  return true;\n}\n\n/**\n * Finds a given token in a message at a given offset.\n * @param {Uint8Array} message message content\n * @param {Uint8Array} token substring that should be found\n * @param {String} offset message body offset from where search should start\n * @returns {Boolean} whether message has a part at given offset or not\n */\nfunction findToken(message, token, offset = 0, maxSearchLength) {\n  let searchLength = message.length;\n  if (maxSearchLength) {\n    searchLength = Math.min(offset + maxSearchLength, message.length);\n  }\n\n  for (let i = offset; i < searchLength; i++) {\n    // If the first value of the message matches\n    // the first value of the token, check if\n    // this is the full token.\n    if (message[i] === token[0]) {\n      if (containsToken(message, token, i)) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n\n/**\n * Create a random GUID\n *\n * @return {string}\n */\nfunction guid() {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  }\n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;\n}\n\n/**\n * @typedef {Object} MultipartEncodedData\n * @property {ArrayBuffer} data The encoded Multipart Data\n * @property {String} boundary The boundary used to divide pieces of the encoded data\n */\n\n/**\n * Encode one or more DICOM datasets into a single body so it can be\n * sent using the Multipart Content-Type.\n *\n * @param {ArrayBuffer[]} datasets Array containing each file to be encoded in the\n                          multipart body, passed as ArrayBuffers.\n * @param {String} [boundary] Optional string to define a boundary between each part\n                              of the multipart body. If this is not specified, a random\n                              GUID will be generated.\n * @return {MultipartEncodedData} The Multipart encoded data returned as an Object. This\n                                  contains both the data itself, and the boundary string\n                                  used to divide it.\n */\nfunction multipartEncode(\n  datasets,\n  boundary = guid(),\n  contentType = 'application/dicom',\n) {\n  const contentTypeString = `Content-Type: ${contentType}`;\n  const header = `\\r\\n--${boundary}\\r\\n${contentTypeString}\\r\\n\\r\\n`;\n  const footer = `\\r\\n--${boundary}--`;\n  const headerArray = stringToUint8Array(header);\n  const footerArray = stringToUint8Array(footer);\n  const headerLength = headerArray.length;\n  const footerLength = footerArray.length;\n\n  let length = 0;\n\n  // Calculate the total length for the final array\n  const contentArrays = datasets.map(datasetBuffer => {\n    const contentArray = new Uint8Array(datasetBuffer);\n    const contentLength = contentArray.length;\n\n    length += headerLength + contentLength\n\n    return contentArray;\n  });\n\n  length += footerLength;\n\n  // Allocate the array\n  const multipartArray = new Uint8Array(length);\n\n  // Set the initial header\n  multipartArray.set(headerArray, 0);\n\n  // Write each dataset into the multipart array\n  let position = 0;\n  contentArrays.forEach(contentArray => {\n    multipartArray.set(headerArray, position);\n    multipartArray.set(contentArray, position + headerLength);\n\n    position += headerLength + contentArray.length;\n  });\n\n  multipartArray.set(footerArray, position);\n\n  return {\n    data: multipartArray.buffer,\n    boundary,\n  };\n}\n\n/**\n * Splits the header string into  parts and extracts the simple contentType\n * and transferSyntaxUID, assigning them, plus the headers map into the destination object.\n *\n * @param {*} destination\n * @param {string} headerString\n */\nfunction addHeaders(destination, headerString) {\n  if (!headerString) {\n    return;\n  }\n  const headerLines = headerString.split('\\r\\n').filter(Boolean);\n  const headers = new Map();\n  let transferSyntaxUID = null,\n    contentType = null;\n\n  for (const line of headerLines) {\n    const colon = line.indexOf(':');\n    if (colon === -1) {\n      continue;\n    }\n    const name = line.substring(0, colon).toLowerCase();\n    const value = line.substring(colon + 1).trim();\n    if (headers.has(name)) {\n      headers.get(name).push(value);\n    } else {\n      headers.set(name, [value]);\n    }\n    if (name === 'content-type') {\n      const endSimpleType = value.indexOf(';');\n      contentType = value.substring(\n        0,\n        endSimpleType === -1 ? value.length : endSimpleType,\n      );\n      const transferSyntaxStart = value.indexOf('transfer-syntax=');\n      if (transferSyntaxStart !== -1) {\n        const endTsuid = value.indexOf(';', transferSyntaxStart);\n        transferSyntaxUID = value.substring(\n          transferSyntaxStart + 16,\n          endTsuid === -1 ? value.length : endTsuid,\n        );\n      }\n    }\n  }\n\n  Object.defineProperty(destination, 'headers', { value: headers });\n  Object.defineProperty(destination, 'contentType', { value: contentType });\n  Object.defineProperty(destination, 'transferSyntaxUID', {\n    value: transferSyntaxUID,\n  });\n}\n\n/**\n * Decode a Multipart encoded ArrayBuffer and return the components as an Array.\n *\n * @param {ArrayBuffer} response Data encoded as a 'multipart/related' message\n * @returns {Uint8Array[]} The content as an array of Uint8Array\n *    Each item shall have a contentType value, and a transferSyntaxUID if available,\n *    as well as the headers Map.  See parseHeaders for output.\n *\n */\nfunction multipartDecode(response) {\n  // Use the raw data if it is provided in an appropriate format\n  const message = ArrayBuffer.isView(response)\n    ? response\n    : new Uint8Array(response);\n  /* Set a maximum length to search for the header boundaries, otherwise\n       findToken can run for a long time\n    */\n  const maxSearchLength = 1000;\n\n  // First look for the multipart mime header\n  const separator = stringToUint8Array('\\r\\n\\r\\n');\n  const headerIndex = findToken(message, separator, 0, maxSearchLength);\n  if (headerIndex === -1) {\n    throw new Error('Response message has no multipart mime header');\n  }\n\n  const header = uint8ArrayToString(message, 0, headerIndex);\n  const boundaryString = identifyBoundary(header);\n  if (!boundaryString) {\n    throw new Error('Header of response message does not specify boundary');\n  }\n\n  const boundary = stringToUint8Array(boundaryString);\n  const boundaryLength = boundary.length;\n  const components = [];\n\n  const headers = header.substring(boundary.length + 2);\n\n  let offset = boundaryLength;\n\n  // Loop until we cannot find any more boundaries\n  let boundaryIndex;\n\n  while (boundaryIndex !== -1) {\n    // Search for the next boundary in the message, starting\n    // from the current offset position\n    boundaryIndex = findToken(message, boundary, offset);\n\n    // If no further boundaries are found, stop here.\n    if (boundaryIndex === -1) {\n      break;\n    }\n\n    const headerTokenIndex = findToken(\n      message,\n      separator,\n      offset,\n      maxSearchLength,\n    );\n    if (headerTokenIndex === -1) {\n      throw new Error('Response message part has no mime header');\n    }\n    offset = headerTokenIndex + separator.length;\n\n    // Extract data from response message, excluding \"\\r\\n\"\n    const spacingLength = 2;\n    const data = response.slice(offset, boundaryIndex - spacingLength);\n    // TODO - extract header data on a per frame basis.\n    addHeaders(data, headers);\n\n    // Add the data to the array of results\n    components.push(data);\n\n    // Move the offset to the end of the current section,\n    // plus the identified boundary\n    offset = boundaryIndex + boundaryLength;\n  }\n\n  return components;\n}\n\nexport {\n  containsToken,\n  findToken,\n  identifyBoundary,\n  uint8ArrayToString,\n  stringToUint8Array,\n  multipartEncode,\n  multipartDecode,\n  guid,\n  addHeaders,\n};\n","import { multipartEncode, multipartDecode, addHeaders } from './message.js';\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nfunction isEmptyObject(obj) {\n  return Object.keys(obj).length === 0 && obj.constructor === Object;\n}\n\nfunction areValidRequestHooks(requestHooks) {\n  const isValid =\n    Array.isArray(requestHooks) &&\n    requestHooks.every(\n      requestHook =>\n        typeof requestHook === 'function' && requestHook.length === 2,\n    );\n\n  if (!isValid) {\n    console.warn(\n      'Request hooks should have the following signature: ' +\n        'function requestHook(request, metadata) { return request; }',\n    );\n  }\n\n  return isValid;\n}\n\n/**\n * @typedef {Object} Request\n * @property {XMLHttpRequest} [instance] - If specified, the request to use, otherwise one will be created.\n * @property {function(ProgressEvent):void} [progressCallback] - A callback function to handle progress events.\n * @property {string} [responseType] - The response type of the request.\n * @property {boolean} [withCredentials] - Whether to include credentials in the request.\n */\n\n/**\n * @param {Request} request - Request options.\n */\nconst getRequestOptions = (request = {}) => ({\n    instance: request.instance || new XMLHttpRequest(),\n    progressCallback: request.progressCallback ||  false,\n    withCredentials: request.withCredentials || false,\n    responseType: request.responseType\n})\n\nconst getFirstResult = result => result[0];\n\nconst MEDIATYPES = {\n  DICOM: 'application/dicom',\n  DICOM_JSON: 'application/dicom+json',\n  OCTET_STREAM: 'application/octet-stream',\n  PDF: 'application/pdf',\n  JPEG: 'image/jpeg',\n  PNG: 'image/png',\n};\n\n/**\n * debugLog is a function that can be called with console.log arguments, and will\n * be conditionally displayed, only when debug logging is enabled.\n */\nlet debugLog = () => {};\n\n/**\n * @typedef { import(\"../types/types\").InstanceMetadata } InstanceMetadata\n */\n\n/**\n * A callback with the request instance and metadata information\n * of the currently request being executed that should necessarily\n * return the given request optionally modified.\n * @typedef {function} RequestHook\n * @param {XMLHttpRequest} request - The original XMLHttpRequest instance.\n * @param {object} metadata - The metadata used by the request.\n */\n\n/**\n * Class for interacting with DICOMweb RESTful services.\n */\nclass DICOMwebClient {\n  /**\n   * @constructor\n   * @param {Object} options\n   * @param {String} options.url - URL of the DICOMweb RESTful Service endpoint\n   * @param {String=} options.qidoURLPrefix - URL path prefix for QIDO-RS\n   * @param {String=} options.wadoURLPrefix - URL path prefix for WADO-RS\n   * @param {String=} options.stowURLPrefix - URL path prefix for STOW-RS\n   * @param {String=} options.username - Username\n   * @param {String=} options.password - Password\n   * @param {Object=} options.headers - HTTP headers\n   * @param {Array.<RequestHook>=} options.requestHooks - Request hooks.\n   * @param {Object=} options.verbose - print to console request warnings and errors, default true\n   * @param {Object=} options.debug - print to the console debug level information/status updates.\n   * @param {boolean|String} options.singlepart - retrieve singlepart for the named types.\n   * The available types are:  bulkdata, video, image.  true means all.\n   */\n  constructor(options) {\n    this.baseURL = options.url;\n    if (!this.baseURL) {\n      console.error('no DICOMweb base url provided - calls that require a URL will fail');\n    }\n\n    if ('username' in options) {\n      this.username = options.username;\n      if (!('password' in options)) {\n        console.error(\n          'no password provided to authenticate with DICOMweb service',\n        );\n      }\n      this.password = options.password;\n    }\n\n    if ('qidoURLPrefix' in options) {\n      debugLog(`use URL prefix for QIDO-RS: ${options.qidoURLPrefix}`);\n      this.qidoURL = `${this.baseURL}/${options.qidoURLPrefix}`;\n    } else {\n      this.qidoURL = this.baseURL;\n    }\n\n    if ('wadoURLPrefix' in options) {\n      debugLog(`use URL prefix for WADO-RS: ${options.wadoURLPrefix}`);\n      this.wadoURL = `${this.baseURL}/${options.wadoURLPrefix}`;\n    } else {\n      this.wadoURL = this.baseURL;\n    }\n\n    if ('stowURLPrefix' in options) {\n      debugLog(`use URL prefix for STOW-RS: ${options.stowURLPrefix}`);\n      this.stowURL = `${this.baseURL}/${options.stowURLPrefix}`;\n    } else {\n      this.stowURL = this.baseURL;\n    }\n\n    if (options.singlepart) {\n      debugLog('use singlepart', options.singlepart);\n      this.singlepart = options.singlepart === true ? 'bulkdata,video,image' : options.singlepart;\n    } else {\n      this.singlepart = '';\n    }\n\n    if ('requestHooks' in options) {\n      this.requestHooks = options.requestHooks;\n    }\n\n    // Headers to pass to requests.\n    this.headers = options.headers || {};\n\n    // Optional error interceptor callback to handle any failed request.\n    this.errorInterceptor = options.errorInterceptor || (() => undefined);\n\n    // Verbose - print to console request warnings and errors, default true\n    this.verbose = options.verbose !== false;\n\n    this.setDebug(options.debug);\n \n\n  }\n\n  /**\n   * Allows setting the debug log information. \n   * Note this is different from verbose in that verbose is whether to include warning/error information, defaulting to true\n   * \n   * @param {boolean} debugLevel \n   * @param {function} debugLogFunction to call with the debug output arguments. \n   */\n  setDebug(debugLevel = false, debugLogFunction = null) {\n    this.debugLevel = !!debugLevel;\n    debugLog = debugLogFunction || debugLevel ? console.log : () => {};\n  }\n\n  /**\n   * Gets debug flag\n   * \n   * @returns true if debug logging is enabled\n   */\n  getDebug() {\n    return this.debugLevel;\n  }\n \n  /**\n   * Sets verbose flag.\n   *\n   * @param {Boolean} verbose\n   */\n  setVerbose(verbose) {\n    this.verbose = verbose;\n  }\n\n  /**\n   * Gets verbose flag.\n   *\n   * @return {Boolean} verbose\n   */\n  getVerbose() {\n    return this.verbose;\n  }\n\n  static _parseQueryParameters(params = {}) {\n    let queryString = '?';\n    Object.keys(params).forEach((key, index) => {\n      if (index !== 0) {\n        queryString += '&';\n      }\n      queryString += `${key}=${encodeURIComponent(params[key])}`;\n    });\n    return queryString;\n  }\n\n  /**\n   * Performs an HTTP request.\n   *\n   * @param {String} url\n   * @param {String} method\n   * @param {Object} headers\n   * @param {Request} [request] - Request Options\n   * @param {Array} [request.data] - Data that should be stored\n   *  @return {*}\n   * @private\n   */\n  _httpRequest(url, method, headers = {}, request = {}) {\n    const { errorInterceptor, requestHooks } = this;\n    return new Promise((resolve, reject) => {\n      let requestInstance = request.instance ? request.instance : new XMLHttpRequest();\n\n      requestInstance.open(method, url, true);\n      if (request.responseType) {\n        requestInstance.responseType = request.responseType;\n      }\n\n      if (typeof headers === 'object') {\n        Object.keys(headers).forEach(key => {\n          requestInstance.setRequestHeader(key, headers[key]);\n        });\n      }\n\n      // now add custom headers from the user\n      // (e.g. access tokens)\n      const userHeaders = this.headers;\n      Object.keys(userHeaders).forEach(key => {\n        requestInstance.setRequestHeader(key, userHeaders[key]);\n      });\n\n      // Event triggered when upload starts\n      requestInstance.onloadstart = function onloadstart() {\n        debugLog('upload started: ', url)\n      };\n\n      // Event triggered when upload ends\n      requestInstance.onloadend = function onloadend() {\n        debugLog('upload finished')\n      };\n\n      // Handle response message\n      requestInstance.onreadystatechange = () => {\n        if (requestInstance.readyState === 4) {\n          if (requestInstance.status === 200) {\n            const contentType = requestInstance.getResponseHeader(\n              'Content-Type',\n            );\n            const headers = requestInstance.getAllResponseHeaders();\n            // Automatically distinguishes between multipart and singlepart in an array buffer, and\n            // converts them into a consistent type.\n            if (contentType && contentType.indexOf('multipart') !== -1) {\n              resolve(multipartDecode(requestInstance.response));\n            } else if (requestInstance.responseType === 'arraybuffer') {\n              addHeaders(requestInstance.response, headers);\n              resolve([requestInstance.response]);\n            } else {\n              resolve(requestInstance.response);\n            }\n          } else if (requestInstance.status === 202) {\n            if (this.verbose) {\n              console.warn('some resources already existed: ', requestInstance);\n            }\n            resolve(requestInstance.response);\n          } else if (requestInstance.status === 204) {\n            if (this.verbose) {\n              console.warn('empty response for request: ', requestInstance);\n            }\n            resolve([]);\n          } else {\n            const error = new Error('request failed');\n            error.request = requestInstance;\n            error.response = requestInstance.response;\n            error.status = requestInstance.status;\n            if (this.verbose) {\n              console.error('request failed: ', requestInstance);\n              console.error(error);\n              console.error(error.response);\n            }\n\n            errorInterceptor(error);\n\n            reject(error);\n          }\n        }\n      };\n\n      // Event triggered while download progresses\n      if (typeof request.progressCallback === 'function') {\n        requestInstance.onprogress = request.progressCallback;\n      }\n\n      if (requestHooks && areValidRequestHooks(requestHooks)) {\n        const combinedHeaders = Object.assign({}, headers, this.headers);\n        const metadata = { method, url, headers: combinedHeaders };\n        const pipeRequestHooks = functions => args =>\n          functions.reduce((props, fn) => fn(props, metadata), args);\n        const pipedRequest = pipeRequestHooks(requestHooks);\n        requestInstance = pipedRequest(requestInstance);\n      }\n\n      // Add withCredentials to request if needed\n      if (request.withCredentials) {\n        requestInstance.withCredentials = true;\n      }\n\n      if (request.data) {\n        requestInstance.send(request.data);\n      } else {\n        requestInstance.send();\n      }\n    });\n  }\n\n  /**\n   * Performs an HTTP GET request.\n   *\n   * @param {String} url\n   * @param {Object} headers\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGet(url, headers, request) {\n    return this._httpRequest(url, 'get', headers, request);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/json\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationJson(url, params = {}, request = {}) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.DICOM_JSON };\n\n    request.responseType = 'json';\n\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      request\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with application/pdf\n   * media type.\n   *\n   * @param {String} url\n   * @param {Object} params\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGetApplicationPdf(url, params = {}, request = {}) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n    const headers = { Accept: MEDIATYPES.PDF };\n\n    request.responseType = 'json'\n\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      request,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with an image\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGetImage(\n    url,\n    mediaTypes,\n    params = {},\n    request = {}\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'image/',\n      'image/*',\n      'image/jpeg',\n      'image/jp2',\n      'image/gif',\n      'image/png',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    request.responseType = 'arraybuffer'\n\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      request,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a text\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGetText(\n    url,\n    mediaTypes,\n    params = {},\n    request = {}\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'text/',\n      'text/*',\n      'text/html',\n      'text/plain',\n      'text/rtf',\n      'text/xml',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    request.responseType = 'arraybuffer';\n\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      request,\n    );\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a message with a video\n   media type.\n   *\n   * @param {String} url\n   * @param {Object[]} mediaTypes\n   * @param {Object} params\n   * @param {Request} request - Request Options\n   * @return {*}\n   * @private\n   */\n  _httpGetVideo(\n    url,\n    mediaTypes,\n    params = {},\n    request = {}\n  ) {\n    let urlWithQueryParams = url;\n\n    if (typeof params === 'object') {\n      if (!isEmptyObject(params)) {\n        urlWithQueryParams += DICOMwebClient._parseQueryParameters(params);\n      }\n    }\n\n    const supportedMediaTypes = [\n      'video/',\n      'video/*',\n      'video/mpeg',\n      'video/mp4',\n      'video/H265',\n    ];\n\n    const acceptHeaderFieldValue = DICOMwebClient._buildAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n    const headers = { Accept: acceptHeaderFieldValue };\n    request.responseType = 'arraybuffer';\n\n    return this._httpGet(\n      urlWithQueryParams,\n      headers,\n      request,\n    );\n  }\n\n  /**\n   * Asserts that a given media type is valid.\n   *\n   * @params {String} mediaType media type\n   */\n  static _assertMediaTypeIsValid(mediaType) {\n    if (!mediaType) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const sepIndex = mediaType.indexOf('/');\n    if (sepIndex === -1) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    const mediaTypeType = mediaType.slice(0, sepIndex);\n    const types = ['application', 'image', 'text', 'video'];\n    if (!types.includes(mediaTypeType)) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n\n    if (mediaType.slice(sepIndex + 1).includes('/')) {\n      throw new Error(`Not a valid media type: ${mediaType}`);\n    }\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with an image media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Request} request - Request Options\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartImage(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    request = {}\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'image/jpeg',\n        'image/gif',\n        'image/png',\n        'image/jp2',\n        'image/*',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '*': ['image/*'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    request.responseType = 'arraybuffer';\n\n    return this._httpGet(url, headers, request);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message with a video media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange - Start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Boolean} rendered - Whether resource should be requested using rendered media types\n   * @param {Request} request - Request Options\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartVideo(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    rendered = false,\n    request = {}\n  ) {\n    const headers = {};\n    let supportedMediaTypes;\n    if (rendered) {\n      supportedMediaTypes = [\n        'video/',\n        'video/*',\n        'video/mpeg2',\n        'video/mp4',\n        'video/H265',\n      ];\n    } else {\n      supportedMediaTypes = {\n        '1.2.840.10008.1.2.4.100': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.101': ['video/mpeg2'],\n        '1.2.840.10008.1.2.4.102': ['video/mp4'],\n        '1.2.840.10008.1.2.4.103': ['video/mp4'],\n        '1.2.840.10008.1.2.4.104': ['video/mp4'],\n        '1.2.840.10008.1.2.4.105': ['video/mp4'],\n        '1.2.840.10008.1.2.4.106': ['video/mp4'],\n      };\n\n      if (byteRange) {\n        headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n      }\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      mediaTypes,\n      supportedMediaTypes,\n    );\n\n    request.responseType = 'arraybuffer';\n\n    return this._httpGet(url, headers, request);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/dicom media type.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Request} request - request options\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationDicom(\n    url,\n    mediaTypes,\n    params,\n    request = {}\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/dicom';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [defaultMediaType],\n      '1.2.840.10008.1.2.5': [defaultMediaType],\n      '1.2.840.10008.1.2.4.50': [defaultMediaType],\n      '1.2.840.10008.1.2.4.51': [defaultMediaType],\n      '1.2.840.10008.1.2.4.57': [defaultMediaType],\n      '1.2.840.10008.1.2.4.70': [defaultMediaType],\n      '1.2.840.10008.1.2.4.80': [defaultMediaType],\n      '1.2.840.10008.1.2.4.81': [defaultMediaType],\n      '1.2.840.10008.1.2.4.90': [defaultMediaType],\n      '1.2.840.10008.1.2.4.91': [defaultMediaType],\n      '1.2.840.10008.1.2.4.92': [defaultMediaType],\n      '1.2.840.10008.1.2.4.93': [defaultMediaType],\n      '1.2.840.10008.1.2.4.100': [defaultMediaType],\n      '1.2.840.10008.1.2.4.101': [defaultMediaType],\n      '1.2.840.10008.1.2.4.102': [defaultMediaType],\n      '1.2.840.10008.1.2.4.103': [defaultMediaType],\n      '1.2.840.10008.1.2.4.104': [defaultMediaType],\n      '1.2.840.10008.1.2.4.105': [defaultMediaType],\n      '1.2.840.10008.1.2.4.106': [defaultMediaType],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    request.responseType = 'arraybuffer';\n\n    return this._httpGet(url, headers, request);\n  }\n\n  /**\n   * Performs an HTTP GET request that accepts a multipart message\n   * with a application/octet-stream, OR any of the equivalencies for that (eg\n   * application/pdf etc)\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @param {Array} byteRange start and end of byte range\n   * @param {Object} params - Additional HTTP GET query parameters\n   * @param {Request} request - Request Options\n   * @private\n   * @returns {Promise<Array>} Content of HTTP message body parts\n   */\n  _httpGetMultipartApplicationOctetStream(\n    url,\n    mediaTypes,\n    byteRange,\n    params,\n    request = {}\n  ) {\n    const headers = {};\n    const defaultMediaType = 'application/octet-stream';\n    const supportedMediaTypes = {\n      '1.2.840.10008.1.2.1': [...Object.values(MEDIATYPES)],\n    };\n\n    let acceptableMediaTypes = mediaTypes;\n    if (!mediaTypes) {\n      acceptableMediaTypes = [{ mediaType: defaultMediaType }];\n    }\n\n    if (byteRange) {\n      headers.Range = DICOMwebClient._buildRangeHeaderFieldValue(byteRange);\n    }\n\n    headers.Accept = DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n      acceptableMediaTypes,\n      supportedMediaTypes,\n    );\n\n    request.responseType = 'arraybuffer'\n\n    return this._httpGet(url, headers, request);\n  }\n\n  /**\n   * Performs an HTTP POST request.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Request} request - Request Options\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPost(url, headers, data, request) {\n    return this._httpRequest(url, 'post', headers, {\n      ...request, data\n    });\n  }\n\n  /**\n   * Performs an HTTP POST request with content-type application/dicom+json.\n   *\n   * @param {String} url - Unique resource locator\n   * @param {Object} headers - HTTP header fields\n   * @param {Array} data - Data that should be stored\n   * @param {Request} request - Request Options\n   * @private\n   * @returns {Promise} Response\n   */\n  _httpPostApplicationJson(url, data, request) {\n    const headers = { 'Content-Type': MEDIATYPES.DICOM_JSON };\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      request,\n    );\n  }\n\n  /**\n   * Parses media type and extracts its type and subtype.\n   *\n   * @param {String} mediaType - HTTP media type (e.g. image/jpeg)\n   * @private\n   * @returns {String[]} Media type and subtype\n   */\n  static _parseMediaType(mediaType) {\n    DICOMwebClient._assertMediaTypeIsValid(mediaType);\n\n    return mediaType.split('/');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET request messages.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @return {*}\n   * @private\n   */\n  static _buildAcceptHeaderFieldValue(mediaTypes, supportedMediaTypes) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    const fieldValueParts = mediaTypes.map(item => {\n      const { mediaType } = item;\n\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      if (!supportedMediaTypes.includes(mediaType)) {\n        throw new Error(\n          `Media type ${mediaType} is not supported for requested resource`,\n        );\n      }\n\n      return mediaType;\n    });\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds an accept header field value for HTTP GET multipart request\n   * messages.  Will throw an exception if no media types are found which are acceptable,\n   * but will only log a verbose level message when types are specified which are\n   * not acceptable.  This allows requesting several types with having to know\n   * whether they are all acceptable or not.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types\n   * @param {Object[]} supportedMediaTypes - Supported media types\n   * @private\n   */\n  static _buildMultipartAcceptHeaderFieldValue(\n    mediaTypes,\n    supportedMediaTypes,\n  ) {\n    if (!Array.isArray(mediaTypes)) {\n      throw new Error('Acceptable media types must be provided as an Array');\n    }\n\n    if (!Array.isArray(supportedMediaTypes) && !isObject(supportedMediaTypes)) {\n      throw new Error(\n        'Supported media types must be provided as an Array or an Object',\n      );\n    }\n\n    const fieldValueParts = [];\n\n    mediaTypes.forEach(item => {\n      const { transferSyntaxUID, mediaType } = item;\n      DICOMwebClient._assertMediaTypeIsValid(mediaType);\n      let fieldValue = `multipart/related; type=\"${mediaType}\"`;\n\n      if (isObject(supportedMediaTypes)) {\n        // SupportedMediaTypes is a lookup table that maps Transfer Syntax UID\n        // to one or more Media Types\n        if (\n          !Object.values(supportedMediaTypes)\n            .flat(1)\n            .includes(mediaType)\n        ) {\n          if (!mediaType.endsWith('/*') || !mediaType.endsWith('/')) {\n            debugLog(\n              `Media type ${mediaType} is not supported for requested resource`,\n            );\n            return;\n          }\n        }\n\n        if (transferSyntaxUID) {\n          if (transferSyntaxUID !== '*') {\n            if (!Object.keys(supportedMediaTypes).includes(transferSyntaxUID)) {\n              throw new Error(\n                `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n              );\n            }\n\n            const expectedMediaTypes = supportedMediaTypes[transferSyntaxUID];\n\n            if (!expectedMediaTypes.includes(mediaType)) {\n              const actualType = DICOMwebClient._parseMediaType(mediaType)[0];\n              expectedMediaTypes.map(expectedMediaType => {\n                const expectedType = DICOMwebClient._parseMediaType(\n                  expectedMediaType,\n                )[0];\n                const haveSameType = actualType === expectedType;\n\n                if (\n                  haveSameType &&\n                  (mediaType.endsWith('/*') || mediaType.endsWith('/'))\n                ) {\n                  return;\n                }\n\n                throw new Error(\n                  `Transfer syntax ${transferSyntaxUID} is not supported for requested resource`,\n                );\n              });\n            }\n          }\n\n          fieldValue += `; transfer-syntax=${transferSyntaxUID}`;\n        }\n      } else if (\n        Array.isArray(supportedMediaTypes) &&\n        !supportedMediaTypes.includes(mediaType)\n      ) {\n        if( this.verbose ) {\n          console.warn(\n            `Media type ${mediaType} is not supported for requested resource`,\n          );\n        }\n        return;\n      }\n\n      fieldValueParts.push(fieldValue);\n    });\n\n    if( !fieldValueParts.length ) {\n      throw new Error(`No acceptable media types found among ${JSON.stringify(mediaTypes)} testing against ${JSON.stringify(acceptableMediaTypes)}`);\n    }\n\n    return fieldValueParts.join(', ');\n  }\n\n  /**\n   * Builds a range header field value for HTTP GET request messages.\n   *\n   * @param {Array} byteRange - Start and end of byte range\n   * @returns {String} Range header field value\n   * @private\n   */\n  static _buildRangeHeaderFieldValue(byteRange = []) {\n    if (byteRange.length === 1) {\n      return `bytes=${byteRange[0]}-`;\n    }\n    if (byteRange.length === 2) {\n      return `bytes=${byteRange[0]}-${byteRange[1]}`;\n    }\n\n    return 'bytes=0-';\n  }\n\n  /**\n   * Gets types that are shared among acceptable media types.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Types that are shared among acceptable media types\n   */\n  static _getSharedMediaTypes(mediaTypes) {\n    const types = new Set();\n\n    if (!mediaTypes || !mediaTypes.length) {\n      return types;\n    }\n\n    mediaTypes.forEach(item => {\n      const { mediaType } = item;\n      const type = DICOMwebClient._parseMediaType(mediaType)[0];\n      types.add(`${type}/`);\n    });\n\n    return Array.from(types);\n  }\n\n  /**\n   * Gets common base type of acceptable media types and asserts that only\n   one type is specified. For example, ``(\"image/jpeg\", \"image/jp2\")``\n   will pass, but ``(\"image/jpeg\", \"video/mpeg2\")`` will raise an\n   exception.\n   *\n   * @param {Object[]} mediaTypes - Acceptable media types and optionally the UIDs of the\n   corresponding transfer syntaxes\n   * @private\n   * @returns {String[]} Common media type, eg `image/` for the above example.\n   */\n  static _getCommonMediaType(mediaTypes) {\n    if (!mediaTypes || !mediaTypes.length) {\n      throw new Error('No acceptable media types provided');\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length === 0) {\n      throw new Error('No common acceptable media type could be identified.');\n    } else if (sharedMediaTypes.length > 1) {\n      throw new Error('Acceptable media types must have the same type.');\n    }\n\n    return sharedMediaTypes[0];\n  }\n\n  /**\n   * Searches for DICOM studies.\n   *\n   * @param {Object} options\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} request - Request Options\n   * @return {Object[]} Study representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2)\n   */\n  searchForStudies(options = {}) {\n    debugLog('search for studies');\n    let url = `${this.qidoURL}/studies`;\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    const request = getRequestOptions(options.request)\n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {Request} options.request - Request Options\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the study\n   */\n  retrieveStudyMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of study metadata',\n      );\n    }\n    debugLog(`retrieve metadata of study ${options.studyInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/metadata`;\n    const request =getRequestOptions(options.request)    \n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /**\n   * Searches for DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} request - Request Options\n   * @returns {Object[]} Series representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2a)\n   */\n  searchForSeries(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      debugLog(`search series of study ${options.studyInstanceUID}`);\n      url += `/studies/${options.studyInstanceUID}`;\n    }\n    url += '/series';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    \n    const request = getRequestOptions(options.request)\n\n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /**\n   * Retrieves metadata for a DICOM series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Request} options.request - Request Options\n   * @returns {Promise<InstanceMetadata[]>} Metadata elements in DICOM JSON format for each instance\n                      belonging to the series\n   */\n  retrieveSeriesMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of series metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of series metadata',\n      );\n    }\n\n    debugLog(`retrieve metadata of series ${options.seriesInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/metadata`;\n    \n    const request = getRequestOptions(options.request)\n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /**\n   * Searches for DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {String} [options.seriesInstanceUID] - Series Instance UID\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} [options.request] - Request Options\n   * @returns {Object[]} Instance representations (http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.7.html#table_6.7.1-2b)\n   */\n  searchForInstances(options = {}) {\n    let url = this.qidoURL;\n    if ('studyInstanceUID' in options) {\n      url += `/studies/${options.studyInstanceUID}`;\n      if ('seriesInstanceUID' in options) {\n        debugLog(\n          `search for instances of series ${options.seriesInstanceUID}`,\n        );\n        url += `/series/${options.seriesInstanceUID}`;\n      } else {\n        debugLog(\n          `search for instances of study ${options.studyInstanceUID}`,\n        );\n      }\n    } else {\n      debugLog('search for instances');\n    }\n    url += '/instances';\n    if ('queryParams' in options) {\n      url += DICOMwebClient._parseQueryParameters(options.queryParams);\n    }\n    const request = getRequestOptions(options.request)\n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /** Returns a WADO-URI URL for an instance\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @returns {String} WADO-URI URL\n   */\n  buildInstanceWadoURIUrl(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required.');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required.');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required.');\n    }\n\n    const contentType = options.contentType || MEDIATYPES.DICOM;\n    const transferSyntax = options.transferSyntax || '*';\n    const params = [];\n\n    params.push('requestType=WADO');\n    params.push(`studyUID=${options.studyInstanceUID}`);\n    params.push(`seriesUID=${options.seriesInstanceUID}`);\n    params.push(`objectUID=${options.sopInstanceUID}`);\n    params.push(`contentType=${contentType}`);\n    params.push(`transferSyntax=${transferSyntax}`);\n\n    const paramString = params.join('&');\n\n    return `${this.wadoURL}?${paramString}`;\n  }\n\n  /**\n   * Retrieves metadata for a DICOM Instance.\n   *\n   * @param {Object} options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {Request} request - Request Options\n   * @returns {Promise<InstanceMetadata>} metadata elements in DICOM JSON format\n   */\n  retrieveInstanceMetadata(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance metadata',\n      );\n    }\n    debugLog(`retrieve metadata of instance ${options.sopInstanceUID}`);\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/metadata`;\n    \n    const request = getRequestOptions(options.request);\n    return this._httpGetApplicationJson(url, {}, request);\n  }\n\n  /**\n   * Retrieves frames for a DICOM Instance.\n   * @param {Object} options options object\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Request} options.request - Request Options\n   * @returns {Array} frame items as byte arrays of the pixel data element\n   */\n  retrieveInstanceFrames(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of instance frames',\n      );\n    }\n    debugLog(\n      `retrieve frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}`;\n\n    const { mediaTypes } = options;\n    \n    const request = getRequestOptions(options.request)\n    request.responseType = 'arraybuffer';\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        false,\n        false,\n        false,\n        request,\n      );\n    }\n\n    const sharedMediaTypes = DICOMwebClient._getSharedMediaTypes(mediaTypes);\n    if (sharedMediaTypes.length > 1) {\n      /**\n       * Enable request of frames that are stored either compressed\n       * (image/* media type) or uncompressed (application/octet-stream\n       * media type).\n       */\n      const supportedMediaTypes = {\n        '1.2.840.10008.1.2.1': ['application/octet-stream'],\n        '1.2.840.10008.1.2.5': ['image/x-dicom-rle'],\n        '1.2.840.10008.1.2.4.50': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.51': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.57': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.70': ['image/jpeg'],\n        '1.2.840.10008.1.2.4.80': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.81': ['image/x-jls', 'image/jls'],\n        '1.2.840.10008.1.2.4.90': ['image/jp2'],\n        '1.2.840.10008.1.2.4.91': ['image/jp2'],\n        '1.2.840.10008.1.2.4.92': ['image/jpx'],\n        '1.2.840.10008.1.2.4.93': ['image/jpx'],\n        '1.2.840.10008.1.2.4.201': ['image/jhc'],\n        '1.2.840.10008.1.2.4.202': ['image/jhc'],\n      };\n\n      const headers = {\n        Accept: DICOMwebClient._buildMultipartAcceptHeaderFieldValue(\n          mediaTypes,\n          supportedMediaTypes,\n        ),\n      };\n      return this._httpGet(url, headers, request);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n    if (commonMediaType.startsWith('application')) {\n      return this._httpGetMultipartApplicationOctetStream(\n        url,\n        mediaTypes,\n        false,\n        false,\n        request,\n      );\n    }\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetMultipartImage(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        request,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetMultipartVideo(\n        url,\n        mediaTypes,\n        false,\n        false,\n        false,\n        request,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of frames.`,\n    );\n  }\n\n /**\n * Element in mediaTypes parameter\n * @typedef {Object} MediaType\n * @param {String} [MediaType.mediaType] - ie 'image/jpeg', 'image/png'...\n */\n\n  /**\n   * Retrieves an individual, server-side rendered DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} [options.request] - Request Options - Request Options\n   * @returns {Promise<ArrayBuffer>} Rendered DICOM Instance\n   */\n  retrieveInstanceRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    const request = getRequestOptions(options.request)\n\n    if (!mediaTypes) {\n      request.responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        request,\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        request,\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        request\n      );\n    }\n    if (commonMediaType.startsWith('text')) {\n      return this._httpGetText(\n        url,\n        mediaTypes,\n        queryParams,\n        request,\n      );\n    }\n    if (commonMediaType === MEDIATYPES.PDF) {\n      return this._httpGetApplicationPdf(\n        url,\n        queryParams,\n        request,\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves a thumbnail of an DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} [options.request] - Request Options - Request Options\n   * @returns {ArrayBuffer} Thumbnail\n   */\n  retrieveInstanceThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance',\n      );\n    }\n\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n   \n    const request = getRequestOptions(options.request)\n\n    if (!mediaTypes) {\n      request.responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        request\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        request\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered instance.',\n    );\n  }\n\n  /**\n   * Retrieves rendered frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {MediaType[]} [options.mediaTypes] - Acceptable HTTP media types\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} [options.request] - Request Options - Request Options\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesRendered(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    debugLog(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/rendered`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    const request = getRequestOptions(options.request)\n\n    if (!mediaTypes) {\n      if (queryParams) {\n        request.responseType = 'arraybuffer';\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(url, headers, request);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        request\n      );\n    }\n    if (commonMediaType.startsWith('video')) {\n      return this._httpGetVideo(\n        url,\n        mediaTypes,\n        queryParams,\n        request\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves thumbnail of frames for a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {String} options.frameNumbers - One-based indices of Frame Items\n   * @param {Object} [options.queryParams] - HTTP query parameters\n   * @param {Request} [options.request] - Request Options - Request Options\n   * @returns {ArrayBuffer[]} Rendered Frame Items as byte arrays\n   */\n  retrieveInstanceFramesThumbnail(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error(\n        'Study Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error(\n        'Series Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error(\n        'SOP Instance UID is required for retrieval of rendered instance frames',\n      );\n    }\n    if (!('frameNumbers' in options)) {\n      throw new Error(\n        'frame numbers are required for retrieval of rendered instance frames',\n      );\n    }\n\n    console.debug(\n      `retrieve rendered frames ${options.frameNumbers.toString()} of instance ${\n        options.sopInstanceUID\n      }`,\n    );\n    let url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${\n      options.seriesInstanceUID\n    }/instances/${\n      options.sopInstanceUID\n    }/frames/${options.frameNumbers.toString()}/thumbnail`;\n\n    const { mediaTypes, queryParams } = options;\n    const headers = {};\n    const request = getRequestOptions(options.request);\n\n    if (!mediaTypes) {\n      request.responseType = 'arraybuffer';\n      if (queryParams) {\n        url += DICOMwebClient._parseQueryParameters(queryParams);\n      }\n      return this._httpGet(\n        url,\n        headers,\n        request\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType.startsWith('image')) {\n      return this._httpGetImage(\n        url,\n        mediaTypes,\n        queryParams,\n        request\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported ` +\n        'for retrieval of rendered frame.',\n    );\n  }\n\n  /**\n   * Retrieves a DICOM Instance.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {String} options.sopInstanceUID - SOP Instance UID\n   * @param {string[]} options.mediaTypes\n   * @param {Request} options.request - Request Options\n   * @returns {Promise<ArrayBuffer>} DICOM Part 10 file as Arraybuffer\n   */\n  retrieveInstance(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n    if (!('sopInstanceUID' in options)) {\n      throw new Error('SOP Instance UID is required');\n    }\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}/instances/${options.sopInstanceUID}`;\n\n    const { mediaTypes } = options;\n\n    const request = getRequestOptions(options.request)\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        request\n      ).then(getFirstResult);\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        request\n      ).then(getFirstResult);\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of instance.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Series.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {String} options.seriesInstanceUID - Series Instance UID\n   * @param {Request} options.request - Request Options\n   * @returns {Promise<ArrayBuffer[]>} DICOM Instances\n   */\n  retrieveSeries(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n    if (!('seriesInstanceUID' in options)) {\n      throw new Error('Series Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}/series/${options.seriesInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const request = getRequestOptions(options.request)\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        request\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        request\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of series.`,\n    );\n  }\n\n  /**\n   * Retrieves all DICOM Instances of a Study.\n   *\n   * @param {Object} options\n   * @param {String} options.studyInstanceUID - Study Instance UID\n   * @param {Request} options.request - Request Options\n   * @returns {ArrayBuffer[]} DICOM Instances\n   */\n  retrieveStudy(options) {\n    if (!('studyInstanceUID' in options)) {\n      throw new Error('Study Instance UID is required');\n    }\n\n    const url = `${this.wadoURL}/studies/${options.studyInstanceUID}`;\n\n    const { mediaTypes } = options;\n    const request = getRequestOptions(options.request);\n\n    if (!mediaTypes) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        false,\n        false,\n        request\n      );\n    }\n\n    const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n    if (commonMediaType === MEDIATYPES.DICOM) {\n      return this._httpGetMultipartApplicationDicom(\n        url,\n        mediaTypes,\n        false,\n        request\n      );\n    }\n\n    throw new Error(\n      `Media type ${commonMediaType} is not supported for retrieval of study.`,\n    );\n  }\n\n  /**\n   * Retrieves and parses BulkData from a BulkDataURI location.\n   * Decodes the multipart encoded data and returns the resulting data\n   * as an ArrayBuffer.\n   *\n   * See http://dicom.nema.org/medical/dicom/current/output/chtml/part18/sect_6.5.5.html\n   *\n   * @param {Object} options\n   * @param {string} options.BulkDataURI to retrieve\n   * @param {Array}  options.mediaTypes to use to fetch the URI\n   * @param {string} options.byteRange to request a sub-range (only valid on single part)\n   * @param {Request} options.request - Request Options\n   * @returns {Promise<Array>} Bulkdata parts\n   */\n  retrieveBulkData(options) {\n    if (!('BulkDataURI' in options)) {\n      throw new Error('BulkDataURI is required.');\n    }\n\n    const url = options.BulkDataURI;\n    const { mediaTypes, byteRange } = options;\n    const request = getRequestOptions(options.request);\n\n    if (this.singlepart.indexOf('bulkdata') !== -1) {\n      request.responseType = 'arraybuffer';\n      return this._httpGet(url, options.headers, request);\n    }\n\n    if (mediaTypes) {\n      try {\n        const commonMediaType = DICOMwebClient._getCommonMediaType(mediaTypes);\n\n        if (commonMediaType==='image/') {\n          return this._httpGetMultipartImage(\n            url,\n            mediaTypes,\n            byteRange,\n            false,\n            false,\n            progressCallback,\n            withCredentials,\n          );\n        }\n      } catch(e) {\n        // No-op - this happens sometimes if trying to fetch the specific desired type but want to fallback to octet-stream\n      }\n    }\n\n    // Just use the media types provided\n    return this._httpGetMultipartApplicationOctetStream(\n      url,\n      mediaTypes,\n      byteRange,\n      false,\n      request\n    );\n  }\n\n  /**\n   * Stores DICOM Instances.\n   *\n   * @param {Object} options\n   * @param {ArrayBuffer[]} options.datasets - DICOM Instances in PS3.10 format\n   * @param {String} [options.studyInstanceUID] - Study Instance UID\n   * @param {Request} [options.request] - Request Options\n   * @returns {Promise} Response message\n   */\n  storeInstances(options) {\n    if (!('datasets' in options)) {\n      throw new Error('datasets are required for storing');\n    }\n\n    let url = `${this.stowURL}/studies`;\n    if ('studyInstanceUID' in options) {\n      url += `/${options.studyInstanceUID}`;\n    }\n\n    const { data, boundary } = multipartEncode(options.datasets);\n    const headers = {\n      'Content-Type': `multipart/related; type=\"application/dicom\"; boundary=\"${boundary}\"`,\n    };    \n\n    const request = getRequestOptions(options.request);\n    return this._httpPost(\n      url,\n      headers,\n      data,\n      request\n    );\n  }\n}\n\n\nexport { DICOMwebClient };\nexport default DICOMwebClient;\n","export default '0.5.2';\n","import { DICOMwebClient } from './api.js';\nimport {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n} from './utils.js';\n\nconst api = {\n  DICOMwebClient,\n};\nconst utils = {\n  getStudyInstanceUIDFromUri,\n  getSeriesInstanceUIDFromUri,\n  getSOPInstanceUIDFromUri,\n  getFrameNumbersFromUri,\n};\n\nexport { default as version } from './version.js';\n\nexport { api, utils };\n"],"names":["stringToUint8Array","str","arr","Uint8Array","length","i","j","charCodeAt","containsToken","message","token","offset","arguments","undefined","index","findToken","maxSearchLength","searchLength","Math","min","multipartEncode","datasets","boundary","guid","s4","floor","random","toString","substring","concat","contentTypeString","header","footer","headerArray","footerArray","headerLength","footerLength","contentArrays","map","datasetBuffer","contentArray","contentLength","multipartArray","set","position","forEach","data","buffer","addHeaders","destination","headerString","headerLines","split","filter","Boolean","headers","Map","transferSyntaxUID","contentType","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","Symbol","iterator","next","done","line","value","colon","indexOf","name","toLowerCase","trim","has","get","push","endSimpleType","transferSyntaxStart","endTsuid","err","return","Object","defineProperty","multipartDecode","response","ArrayBuffer","isView","separator","headerIndex","Error","itemLimit","String","fromCharCode","uint8ArrayToString","boundaryString","parts","identifyBoundary","boundaryIndex","boundaryLength","components","headerTokenIndex","slice","isObject","obj","_typeof","isEmptyObject","keys","constructor","getRequestOptions","request","instance","XMLHttpRequest","progressCallback","withCredentials","responseType","getFirstResult","result","MEDIATYPES","DICOM","DICOM_JSON","OCTET_STREAM","PDF","JPEG","PNG","debugLog","api","DICOMwebClient","options","_classCallCheck","this","baseURL","url","console","error","username","password","qidoURLPrefix","qidoURL","wadoURLPrefix","wadoURL","stowURLPrefix","stowURL","singlepart","requestHooks","errorInterceptor","verbose","setDebug","debug","key","debugLevel","debugLogFunction","log","_httpRequest","method","_this","Promise","resolve","reject","requestInstance","open","setRequestHeader","functions","userHeaders","onloadstart","onloadend","onreadystatechange","readyState","status","getResponseHeader","getAllResponseHeaders","warn","onprogress","isValid","Array","isArray","every","requestHook","areValidRequestHooks","combinedHeaders","assign","metadata","pipedRequest","args","reduce","props","fn","send","params","urlWithQueryParams","_parseQueryParameters","Accept","_httpGet","_httpGetImage","mediaTypes","_buildAcceptHeaderFieldValue","_httpGetText","_httpGetVideo","byteRange","supportedMediaTypes","Range","_buildRangeHeaderFieldValue","_buildMultipartAcceptHeaderFieldValue","defaultMediaType","acceptableMediaTypes","mediaType","_toConsumableArray","values","_objectSpread","_httpPost","queryParams","_httpGetApplicationJson","studyInstanceUID","seriesInstanceUID","transferSyntax","sopInstanceUID","paramString","join","frameNumbers","_httpGetMultipartApplicationOctetStream","_getSharedMediaTypes","commonMediaType","_getCommonMediaType","startsWith","_httpGetMultipartImage","_httpGetMultipartVideo","_httpGetApplicationPdf","_httpGetMultipartApplicationDicom","then","BulkDataURI","e","_multipartEncode","queryString","encodeURIComponent","sepIndex","mediaTypeType","includes","_assertMediaTypeIsValid","item","_this2","fieldValueParts","fieldValue","flat","endsWith","expectedMediaTypes","actualType","_parseMediaType","expectedMediaType","expectedType","JSON","stringify","types","Set","type","add","from","sharedMediaTypes"],"sourceRoot":""}