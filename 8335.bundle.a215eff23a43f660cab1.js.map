{"version":3,"file":"8335.bundle.a215eff23a43f660cab1.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/types/segmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/callInputDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/colorPickerDialog.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/segmentationIO/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/panels/PanelSegmentation.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getPanelModule.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/hydrationUtils.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getToolbarModule.ts","webpack:///../../../extensions/cornerstone/src/Viewport/Overlays/utils.ts"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-seg';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import { utils } from '@ohif/core';\r\nimport { metaData, cache, triggerEvent, eventTarget } from '@cornerstonejs/core';\r\nimport { CONSTANTS } from '@cornerstonejs/tools';\r\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4'];\r\n\r\nconst loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager\r\n) {\r\n  const instance = instances[0];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'SEG',\r\n    loading: false,\r\n    isReconstructable: true, // by default for now since it is a volumetric SEG currently\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    segments: {},\r\n    sopClassUids,\r\n    instance,\r\n    instances: [instance],\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n  };\r\n\r\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n\r\n  if (!referencedSeriesSequence) {\r\n    console.error('ReferencedSeriesSequence is missing for the SEG');\r\n    return;\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\r\n\r\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n\r\n  displaySet.getReferenceDisplaySet = () => {\r\n    const { displaySetService } = servicesManager.services;\r\n    const referencedDisplaySets = displaySetService.getDisplaySetsForSeries(\r\n      displaySet.referencedSeriesInstanceUID\r\n    );\r\n\r\n    if (!referencedDisplaySets || referencedDisplaySets.length === 0) {\r\n      throw new Error('Referenced DisplaySet is missing for the SEG');\r\n    }\r\n\r\n    const referencedDisplaySet = referencedDisplaySets[0];\r\n\r\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\r\n\r\n    // Todo: this needs to be able to work with other reference volumes (other than streaming) such as nifti, etc.\r\n    displaySet.referencedVolumeURI = referencedDisplaySet.displaySetInstanceUID;\r\n    const referencedVolumeId = `cornerstoneStreamingImageVolume:${displaySet.referencedVolumeURI}`;\r\n    displaySet.referencedVolumeId = referencedVolumeId;\r\n\r\n    return referencedDisplaySet;\r\n  };\r\n\r\n  displaySet.load = async ({ headers }) =>\r\n    await _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(\r\n  segDisplaySet,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager,\r\n  headers\r\n) {\r\n  const { SOPInstanceUID } = segDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  if (\r\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExists(segDisplaySet, segmentationService)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  segDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\r\n      await _loadSegments({\r\n        extensionManager,\r\n        servicesManager,\r\n        segDisplaySet,\r\n        headers,\r\n      });\r\n    }\r\n\r\n    const suppressEvents = true;\r\n    segmentationService\r\n      .createSegmentationForSEGDisplaySet(segDisplaySet, null, suppressEvents)\r\n      .then(() => {\r\n        segDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        segDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nasync function _loadSegments({\r\n  extensionManager,\r\n  servicesManager,\r\n  segDisplaySet,\r\n  headers,\r\n}: withAppTypes) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n\r\n  const { segmentationService, uiNotificationService } = servicesManager.services;\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\r\n\r\n  const cachedReferencedVolume = cache.getVolume(segDisplaySet.referencedVolumeId);\r\n\r\n  if (!cachedReferencedVolume) {\r\n    throw new Error(\r\n      'Referenced Volume is missing for the SEG, and stack viewport SEG is not supported yet'\r\n    );\r\n  }\r\n\r\n  const { imageIds } = cachedReferencedVolume;\r\n\r\n  // Todo: what should be defaults here\r\n  const tolerance = 0.001;\r\n  const skipOverlapping = true;\r\n\r\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\r\n    const { percentComplete } = evt.detail;\r\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\r\n      percentComplete,\r\n    });\r\n  });\r\n\r\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.generateToolState(\r\n    imageIds,\r\n    arrayBuffer,\r\n    metaData,\r\n    { skipOverlapping, tolerance, eventTarget, triggerEvent }\r\n  );\r\n\r\n  let usedRecommendedDisplayCIELabValue = true;\r\n  results.segMetadata.data.forEach((data, i) => {\r\n    if (i > 0) {\r\n      data.rgba = data.RecommendedDisplayCIELabValue;\r\n\r\n      if (data.rgba) {\r\n        data.rgba = dicomlabToRGB(data.rgba);\r\n      } else {\r\n        usedRecommendedDisplayCIELabValue = false;\r\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\r\n      }\r\n    }\r\n  });\r\n\r\n  if (results.overlappingSegments) {\r\n    uiNotificationService.show({\r\n      title: 'Overlapping Segments',\r\n      message:\r\n        'Unsupported overlapping segments detected, segmentation rendering results may be incorrect.',\r\n      type: 'warning',\r\n    });\r\n  }\r\n\r\n  if (!usedRecommendedDisplayCIELabValue) {\r\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\r\n    uiNotificationService.show({\r\n      title: 'DICOM SEG import',\r\n      message:\r\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\r\n      type: 'warning',\r\n      duration: 5000,\r\n    });\r\n  }\r\n\r\n  Object.assign(segDisplaySet, results);\r\n}\r\n\r\nfunction _segmentationExists(segDisplaySet, segmentationService: AppTypes.SegmentationService) {\r\n  // This should be abstracted with the CornerstoneCacheService\r\n  return segmentationService.getSegmentation(segDisplaySet.displaySetInstanceUID);\r\n}\r\n\r\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'dicom-seg',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import dcmjs from 'dcmjs';\r\n\r\n/**\r\n * Converts a CIELAB color to an RGB color using the dcmjs library.\r\n * @param cielab - The CIELAB color to convert.\r\n * @returns The RGB color as an array of three integers between 0 and 255.\r\n */\r\nfunction dicomlabToRGB(cielab: number[]): number[] {\r\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\r\n\r\n  return rgb;\r\n}\r\n\r\nexport { dicomlabToRGB };\r\n","import { Types } from '@ohif/core';\r\n\r\nconst segProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/seg',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  name: 'Segmentations',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'segDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    segDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SEG',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'Segmentations',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: { allowUnmatchedView: true },\r\n          displaySets: [\r\n            {\r\n              id: 'segDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: segProtocol.id,\r\n      protocol: segProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { segProtocol };\r\n","export enum SegmentationPanelMode {\r\n  Expanded = 'expanded',\r\n  Dropdown = 'dropdown',\r\n}\r\n","import React from 'react';\r\nimport { Input, Dialog, ButtonEnums } from '@ohif/ui';\r\n\r\nfunction callInputDialog(uiDialogService, label, callback) {\r\n  const dialogId = 'enter-segment-label';\r\n\r\n  const onSubmitHandler = ({ action, value }) => {\r\n    switch (action.id) {\r\n      case 'save':\r\n        callback(value.label, action.id);\r\n        break;\r\n      case 'cancel':\r\n        callback('', action.id);\r\n        break;\r\n    }\r\n    uiDialogService.dismiss({ id: dialogId });\r\n  };\r\n\r\n  if (uiDialogService) {\r\n    uiDialogService.create({\r\n      id: dialogId,\r\n      centralize: true,\r\n      isDraggable: false,\r\n      showOverlay: true,\r\n      content: Dialog,\r\n      contentProps: {\r\n        title: 'Segment',\r\n        value: { label },\r\n        noCloseButton: true,\r\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\r\n        actions: [\r\n          { id: 'cancel', text: 'Cancel', type: ButtonEnums.type.secondary },\r\n          { id: 'save', text: 'Confirm', type: ButtonEnums.type.primary },\r\n        ],\r\n        onSubmit: onSubmitHandler,\r\n        body: ({ value, setValue }) => {\r\n          return (\r\n            <Input\r\n              label=\"Enter the segment label\"\r\n              labelClassName=\"text-white text-[14px] leading-[1.2]\"\r\n              autoFocus\r\n              className=\"border-primary-main bg-black\"\r\n              type=\"text\"\r\n              value={value.label}\r\n              onChange={event => {\r\n                event.persist();\r\n                setValue(value => ({ ...value, label: event.target.value }));\r\n              }}\r\n              onKeyPress={event => {\r\n                if (event.key === 'Enter') {\r\n                  onSubmitHandler({ value, action: { id: 'save' } });\r\n                }\r\n              }}\r\n            />\r\n          );\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default callInputDialog;\r\n","import React from 'react';\r\nimport { Dialog } from '@ohif/ui';\r\nimport { ChromePicker } from 'react-color';\r\n\r\nimport './colorPickerDialog.css';\r\n\r\nfunction callColorPickerDialog(uiDialogService, rgbaColor, callback) {\r\n  const dialogId = 'pick-color';\r\n\r\n  const onSubmitHandler = ({ action, value }) => {\r\n    switch (action.id) {\r\n      case 'save':\r\n        callback(value.rgbaColor, action.id);\r\n        break;\r\n      case 'cancel':\r\n        callback('', action.id);\r\n        break;\r\n    }\r\n    uiDialogService.dismiss({ id: dialogId });\r\n  };\r\n\r\n  if (uiDialogService) {\r\n    uiDialogService.create({\r\n      id: dialogId,\r\n      centralize: true,\r\n      isDraggable: false,\r\n      showOverlay: true,\r\n      content: Dialog,\r\n      contentProps: {\r\n        title: 'Segment Color',\r\n        value: { rgbaColor },\r\n        noCloseButton: true,\r\n        onClose: () => uiDialogService.dismiss({ id: dialogId }),\r\n        actions: [\r\n          { id: 'cancel', text: 'Cancel', type: 'primary' },\r\n          { id: 'save', text: 'Save', type: 'secondary' },\r\n        ],\r\n        onSubmit: onSubmitHandler,\r\n        body: ({ value, setValue }) => {\r\n          const handleChange = color => {\r\n            setValue({ rgbaColor: color.rgb });\r\n          };\r\n\r\n          return (\r\n            <ChromePicker\r\n              color={value.rgbaColor}\r\n              onChange={handleChange}\r\n              presetColors={[]}\r\n              width={300}\r\n            />\r\n          );\r\n        },\r\n      },\r\n    });\r\n  }\r\n}\r\n\r\nexport default callColorPickerDialog;\r\n","import {Button, ButtonEnums, useViewportGrid, Icon} from '@ohif/ui';\r\nimport React, {useEffect, useState} from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport {saveAs, FileSaver} from 'file-saver'\r\nimport JSZip from 'jszip';\r\nimport { segmentation as cstSegmentation, utilities as csToolsUtils, Enums } from '@cornerstonejs/tools';\r\nimport { DicomMetadataStore } from '@ohif/core';\r\nimport { formatPN } from '../../../../cornerstone/src/Viewport/Overlays/utils'\r\nimport axios, { AxiosRequestConfig } from 'axios';\r\nimport pako from 'pako';\r\n\r\nfunction SegmentationImportExport({\r\n  segmentationService,\r\n  uiNotificationService,\r\n  hangingProtocolService,\r\n  toolGroupService,\r\n  viewportGridService,\r\n  cornerstoneCacheService\r\n}) : React.JSX.Element {\r\n\r\n  const exportActiveSegmentation = async () => {\r\n    let segmentation = segmentationService.getActiveSegmentation();\r\n    if (!segmentation) {\r\n      uiNotificationService.show({\r\n        title: `Export Active Segmentation`,\r\n        message: `No active segmentation detected`,\r\n        type: 'info',\r\n        duration: 3000,\r\n      });\r\n      return;\r\n    }\r\n    const dentascanSegmentations = segmentationService.getDentascanSegmentations();\r\n    if (dentascanSegmentations?.includes(segmentation)) {\r\n      // Always export main segmentation\r\n      segmentation = segmentationService.getHiddenSegmentation(segmentation.id);\r\n    }\r\n\r\n    const { segments: segmentsInfo, label: segmentationLabel } = segmentation;\r\n    const { dimensions, scalarData } = segmentationService.getLabelmapVolume(segmentation.id);\r\n    const layerSize = dimensions[0] * dimensions[1];\r\n    const nbLayers = dimensions[2];\r\n\r\n    // One zip file per segmentation\r\n    const zip = new JSZip();\r\n\r\n    // One PNG image per layer\r\n    for (let layerI = 0; layerI < nbLayers; layerI++) {\r\n      const pixelData = new Uint8ClampedArray(layerSize * 4).fill(0);\r\n      for (let i = 0; i < layerSize; i++) {\r\n        const segmentIndex = scalarData[layerI * layerSize + i];\r\n        if (segmentIndex !== 0) {\r\n          // Not background\r\n          const { color } = segmentsInfo[segmentIndex];\r\n          pixelData[i * 4] = color[0];\r\n          pixelData[i * 4 + 1] = color[1];\r\n          pixelData[i * 4 + 2] = color[2];\r\n        }\r\n        pixelData[i * 4 + 3] = 255;\r\n      }\r\n\r\n      // Store PNG image in zip\r\n      const canvas = document.createElement('canvas');\r\n      const ctx = canvas.getContext('2d');\r\n      canvas.width = dimensions[0];\r\n      canvas.height = dimensions[1];\r\n      const imgData = new ImageData(pixelData, dimensions[0], dimensions[1], { colorSpace: 'srgb' });\r\n      ctx.putImageData(imgData, 0, 0);\r\n      ctx.putImageData(imgData, 0, 0);\r\n\r\n      const pngBlob = await new Promise<Blob>((resolve, reject) => {\r\n        canvas.toBlob(blob => blob ? resolve(blob) : reject(new Error('Conversion to blob failed')), 'image/png');\r\n      });\r\n      zip.file(`layer_${layerI}.png`, pngBlob);\r\n    }\r\n\r\n    // Add scalar data as binary file\r\n    const binaryBlob = new Blob([new Uint8ClampedArray(scalarData)], { type: 'application/octet-stream' });\r\n    zip.file(`labelmapVolume_${segmentationLabel}.bin`, binaryBlob);\r\n\r\n    // Add segments information as JSON File\r\n    const jsonBlob = new Blob([JSON.stringify(segmentsInfo, null, '\\t')], { type: 'text/plain;charset=utf-8' });\r\n    zip.file(`segmentsInfo_${segmentationLabel}.json`, jsonBlob);\r\n\r\n    // Get study metadata\r\n    const { activeStudyUID } = hangingProtocolService.getState();\r\n    const study = DicomMetadataStore.getStudy(activeStudyUID);\r\n    const { StudyDate, PatientName } = study?.series[0]?.instances[0];\r\n    const patientNameFormatted = formatPN(PatientName[0]);\r\n\r\n    // Save zip file\r\n    const content = await zip.generateAsync({ type:'blob' });\r\n    saveAs(content, `${StudyDate ?? ''}_${patientNameFormatted ?? ''}_${segmentationLabel}.zip`);\r\n  }\r\n\r\n  const importConfiguration = (configurationFile) => {\r\n    // Default viewport needs to be accessible\r\n    const displaySetUID = viewportGridService.getDisplaySetsUIDsForViewport('default')[0];\r\n    if (!displaySetUID) {\r\n      uiNotificationService.show({\r\n        title: `Import Segmentation`,\r\n        message: `Default viewport not found`,\r\n        type: 'info',\r\n        duration: 3000,\r\n      });\r\n      return;\r\n    }\r\n    const toolGroupId = toolGroupService.getToolGroupForViewport('default').id;\r\n    const LABELMAP = Enums.SegmentationRepresentations.Labelmap;\r\n\r\n    const reader = new FileReader();\r\n    // Read configuration file\r\n    reader.onload = async function(event) {\r\n      try {\r\n        if (typeof event.target.result !== 'string') {\r\n          // TODO error message\r\n          console.error('ERROR::JSON_READING::CORRUPTED_CONTENT');\r\n          return;\r\n        }\r\n        // Copy segmentation\r\n        // TODO does not handle _ in segmentation label\r\n        const segmentationLabel = configurationFile.name.split('_').pop().replace(/\\.[^/.]+$/, '');\r\n        const options = { label: segmentationLabel };\r\n        const segId = await segmentationService.createSegmentationForDisplaySet(displaySetUID, options);\r\n        await segmentationService.addSegmentationRepresentationToToolGroup(toolGroupId, segId, true, LABELMAP);\r\n        segmentationService.setActiveSegmentationForToolGroup(segId, toolGroupId);\r\n\r\n        // Copy segments\r\n        const segments = JSON.parse(event.target.result);\r\n        for (const segment of segments) {\r\n          if (!segment) {\r\n            // Skip segment 0 (background) and deleted segments\r\n            continue;\r\n          }\r\n          const { segmentIndex } = segment;\r\n          segmentationService.addSegment(segId, {\r\n            segmentIndex: segmentIndex,\r\n            toolGroupId: toolGroupId,\r\n            properties: segment\r\n          }, true);\r\n        }\r\n      } catch (error) {\r\n        // TODO error message\r\n        console.error('ERROR::JSON_READING', error);\r\n      }\r\n    };\r\n    reader.readAsText(configurationFile);\r\n  }\r\n\r\n  const importBinary = async (binaryFile) => {\r\n    // TODO promise?\r\n    const reader = new FileReader();\r\n    // Read binary file\r\n    reader.onload = async function(event) {\r\n      const newScalarData = new Uint8Array(event.target.result as ArrayBuffer);\r\n      const segmentationLabel = binaryFile.name.split('_').pop().replace(/\\.[^/.]+$/, '');\r\n      const segmentation = segmentationService.getSegmentations().filter(s => s.label === segmentationLabel)[0];\r\n      if (!segmentation) {\r\n        uiNotificationService.show({\r\n          title: `Import Segmentation`,\r\n          message: `Segmentation with name ${segmentationLabel} does not match segmentation of configuration file`,\r\n          type: 'info',\r\n          duration: 3000,\r\n        });\r\n        return;\r\n      }\r\n\r\n      const scalarData = segmentationService.getLabelmapVolume(segmentation.id).getScalarData();\r\n      for (let i = 0; i < scalarData.length; i++) {\r\n        scalarData[i] = newScalarData[i];\r\n      }\r\n      // Triggers rendering\r\n      cstSegmentation.triggerSegmentationEvents.triggerSegmentationDataModified(segmentation.id);\r\n    }\r\n    reader.readAsArrayBuffer(binaryFile);\r\n  }\r\n\r\n  const importSegmentationFromFolder = () => {\r\n    // Default viewport needs to be accessible\r\n    const displaySetUID = viewportGridService.getDisplaySetsUIDsForViewport('default')[0];\r\n    if (!displaySetUID) {\r\n      uiNotificationService.show({\r\n        title: `Import Segmentation`,\r\n        message: `Default viewport not found`,\r\n        type: 'info',\r\n        duration: 3000,\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Load binary file\r\n    const input = document.createElement('input');\r\n    input.type = 'file';\r\n    input.webkitdirectory = true;\r\n    input.onchange = async _ => {\r\n      const files = Array.from(input.files);\r\n      const configurationFile = files.filter(filter => filter.type === 'application/json')[0];\r\n      const binaryFile = files.filter(file => file.type === 'application/octet-stream')[0];\r\n      if (!configurationFile || !binaryFile) {\r\n        uiNotificationService.show({\r\n          title: `Import Segmentation`,\r\n          message: `Missing configuration or binary file`,\r\n          type: 'info',\r\n          duration: 3000,\r\n        });\r\n        return;\r\n      }\r\n      importConfiguration(configurationFile);\r\n      importBinary(binaryFile);\r\n    };\r\n    input.click();\r\n  }\r\n\r\n  const exportGeneratedSegmentation = async () => {\r\n    const { cbctSegmentationUUID, accessKey } = cornerstoneCacheService.getCbctSegmentationMetadata();\r\n    if (!cbctSegmentationUUID || !accessKey) {\r\n      uiNotificationService.show({\r\n        title: `Export Generated Segmentation`,\r\n        message: `No credentials found`,\r\n        type: 'info',\r\n        duration: 3000,\r\n      });\r\n      return;\r\n    }\r\n\r\n    const generatedSegmentation = segmentationService.getGeneratedSegmentation();\r\n    if (!generatedSegmentation) {\r\n      uiNotificationService.show({\r\n        title: `Export Generated Segmentation`,\r\n        message: `No generated segmentation detected`,\r\n        type: 'info',\r\n        duration: 3000,\r\n      });\r\n      return;\r\n    }\r\n    const scalarData = segmentationService.getLabelmapVolume(generatedSegmentation.id).getScalarData();\r\n    const segmentationConfig = JSON.stringify(generatedSegmentation.segments)\r\n\r\n    try {\r\n      const formData: FormData = new FormData();\r\n      const volumeArray = pako.deflate(scalarData);\r\n      formData.append('modified_volume', new Blob([volumeArray]), `${cbctSegmentationUUID}.zlib`);\r\n      formData.append('modified_config', segmentationConfig);\r\n      const url = `https://localhost/api/v1/cbct/${cbctSegmentationUUID}/`;\r\n      const headers = accessKey ? { Authorization: 'Bearer ' + accessKey } : undefined;\r\n      const config: AxiosRequestConfig = { method: 'put', url, headers, data: formData };\r\n      const response = await axios(config);\r\n      console.log('Server response for segmented volume export', response.data);\r\n\r\n      return response;\r\n    } catch (error) {\r\n      console.error('Server error for segmented volume export', error);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className='flex flex-col min-h-0 font-inter font-[300]'>\r\n      <div className='bg-primary-dark pt-[6px] pb-[6px]'>\r\n        <p className='text-[#d8d8d8] text-[12px] font-[300] pl-[9px] pr-[9px] pb-[6px] flex'>{'Segmentation'}</p>\r\n        <div className='text-[#d8d8d8] text-[12px] font-[300] justify-evenly flex'>\r\n          <Button\r\n            size={ButtonEnums.size.small}\r\n            onClick={importSegmentationFromFolder}\r\n          >{'Import'}</Button>\r\n          <Button\r\n            size={ButtonEnums.size.small}\r\n            onClick={exportActiveSegmentation}\r\n          >{'Export'}</Button>\r\n        </div>\r\n        <p className='text-[#d8d8d8] text-[12px] font-[300] pl-[9px] pr-[9px] pb-[6px] flex'>{'Generated segmentation'}</p>\r\n        <div className='text-[#d8d8d8] text-[12px] font-[300] justify-evenly flex'>\r\n          <Button\r\n            size={ButtonEnums.size.small}\r\n            onClick={exportGeneratedSegmentation}\r\n          >{'Export generated segmentation'}</Button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SegmentationImportExport\r\n","import { createReportAsync } from '@ohif/extension-default';\r\nimport React, {useCallback, useEffect, useState} from 'react';\r\nimport PropTypes, {element} from 'prop-types';\r\nimport {Button, SegmentationGroupTable, SegmentationGroupTableExpanded, useViewportGrid, ListMenu} from '@ohif/ui';\r\nimport { SegmentationPanelMode } from '../types/segmentation';\r\nimport callInputDialog from './callInputDialog';\r\nimport callColorPickerDialog from './colorPickerDialog';\r\nimport BaseToolEdit from \"./segToolsEditSection/baseToolEdit\";\r\nimport SegmentationImportExport from \"./segmentationIO\";\r\nimport {useTranslation} from 'react-i18next';\r\nimport { DisplaySet, RGB } from 'platform/core/src/types';\r\nimport { VolumeData } from 'extensions/cornerstone/src/types/CornerstoneCacheService';\r\nimport { Enums } from '@cornerstonejs/tools';\r\n\r\nconst components = {\r\n  [SegmentationPanelMode.Expanded]: SegmentationGroupTableExpanded,\r\n  [SegmentationPanelMode.Dropdown]: SegmentationGroupTable,\r\n};\r\n\r\nconst seededRandom = (seed: number) => {\r\n  let value = seed % 2147483647;\r\n  return () => {\r\n      value = (value * 16807) % 2147483647;\r\n      return value / 2147483647;\r\n  };\r\n}\r\nconst random = seededRandom(42);\r\n\r\nexport default function PanelSegmentation({\r\n  servicesManager,\r\n  commandsManager,\r\n  extensionManager,\r\n  configuration,\r\n}: withAppTypes) {\r\n  const [{ activeViewportId, viewports }] = useViewportGrid();\r\n  const {\r\n    segmentationService,\r\n    viewportGridService,\r\n    uiDialogService,\r\n    displaySetService,\r\n    cornerstoneViewportService,\r\n    toolbarService,\r\n    uiNotificationService,\r\n    cornerstoneCacheService,\r\n    hangingProtocolService,\r\n    toolGroupService,\r\n  } = servicesManager.services;\r\n\r\n  const { t } = useTranslation('PanelSegmentation');\r\n\r\n  const [addSegmentationClassName, setAddSegmentationClassName] = useState('');\r\n  const [segmentationConfiguration, setSegmentationConfiguration] = useState(\r\n    segmentationService.getConfiguration()\r\n  );\r\n\r\n  const isDentascanViewport = (viewportId): boolean => {\r\n    const { volume } = cornerstoneViewportService.getViewportInfo(viewportId)?.getViewportData().data[0] as VolumeData;\r\n    return volume?.metadata.SeriesInstanceUID.includes('dentascan') || false;\r\n  }\r\n\r\n  const viewportDentascanIsActive = isDentascanViewport(viewportGridService.getActiveViewportId());\r\n  const [visibleSegmentations, setVisibleSegmentations] = useState(\r\n    () => viewportDentascanIsActive ? segmentationService.getDentascanSegmentations()\r\n                                    : segmentationService.getAxialSegmentations()\r\n  );\r\n  const [hiddenSegmentations, setHiddenSegmentations] = useState(\r\n    () => viewportDentascanIsActive ? segmentationService.getAxialSegmentations()\r\n                                    : segmentationService.getDentascanSegmentations()\r\n  );\r\n  const [isMinimized, setIsMinimized] = useState({});\r\n\r\n  const onToggleMinimizeSegmentation = useCallback(id => {\r\n    setIsMinimized(prevState => ({ ...prevState, [id]: !prevState[id] }));\r\n  }, [setIsMinimized]);\r\n\r\n  // Only expand the last segmentation added to the list and collapse the rest\r\n  useEffect(() => {\r\n    const lastSegmentationId = visibleSegmentations[visibleSegmentations.length - 1]?.id;\r\n    if (lastSegmentationId) {\r\n      setIsMinimized(prevState => ({ ...prevState, [lastSegmentationId]: false, }));\r\n    }\r\n  }, [visibleSegmentations, setIsMinimized]);\r\n\r\n  useEffect(() => {\r\n    // ~~ Subscription\r\n    const added = segmentationService.EVENTS.SEGMENTATION_ADDED;\r\n    const updated = segmentationService.EVENTS.SEGMENTATION_UPDATED;\r\n    const removed = segmentationService.EVENTS.SEGMENTATION_REMOVED;\r\n    const configChanged = segmentationService.EVENTS.SEGMENTATION_CONFIGURATION_CHANGED;\r\n    const subscriptions: any[] = [];\r\n\r\n    [added, updated, removed].forEach(evt => {\r\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\r\n        const viewportDentascanIsActive = isDentascanViewport(viewportGridService.getActiveViewportId());\r\n        setVisibleSegmentations(viewportDentascanIsActive ? segmentationService.getDentascanSegmentations()\r\n                                                          : segmentationService.getAxialSegmentations());\r\n        setHiddenSegmentations(viewportDentascanIsActive ? segmentationService.getAxialSegmentations()\r\n                                                         : segmentationService.getDentascanSegmentations());\r\n      });\r\n      subscriptions.push(unsubscribe);\r\n    });\r\n\r\n    [configChanged].forEach(evt => {\r\n      const { unsubscribe } = segmentationService.subscribe(evt, () => {\r\n        setSegmentationConfiguration(segmentationService.getConfiguration());\r\n      });\r\n      subscriptions.push(unsubscribe);\r\n    });\r\n\r\n    return () => {\r\n      subscriptions.forEach(unsub => {\r\n        unsub();\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  // temporary measure to not allow add segmentation when the selected viewport\r\n  // is stack viewport\r\n  useEffect(() => {\r\n    const handleActiveViewportChange = viewportId => {\r\n      const activeDisplaySetsUIDs = viewportGridService.getDisplaySetsUIDsForViewport(\r\n        viewportId || viewportGridService.getActiveViewportId()\r\n      );\r\n\r\n      if (!activeDisplaySetsUIDs) {\r\n        return;\r\n      }\r\n\r\n      const isReconstructable =\r\n          activeDisplaySetsUIDs?.some(displaySetUID => {\r\n          const displaySet = displaySetService.getDisplaySetByUID(displaySetUID);\r\n          return displaySet?.isReconstructable;\r\n        }) || false;\r\n\r\n      if (isReconstructable) {\r\n        setAddSegmentationClassName('');\r\n      } else {\r\n        setAddSegmentationClassName('ohif-disabled');\r\n      }\r\n    };\r\n\r\n    // Handle initial state\r\n    handleActiveViewportChange();\r\n\r\n    const changedGrid = viewportGridService.EVENTS.ACTIVE_VIEWPORT_ID_CHANGED;\r\n    const ready = viewportGridService.EVENTS.VIEWPORTS_READY;\r\n\r\n    const subsGrid = [];\r\n    [ready, changedGrid].forEach(evt => {\r\n      const { unsubscribe } = viewportGridService.subscribe(evt, ({ viewportId }) => {\r\n        handleActiveViewportChange(viewportId);\r\n      });\r\n\r\n      subsGrid.push(unsubscribe);\r\n    });\r\n\r\n    const changedData = cornerstoneViewportService.EVENTS.VIEWPORT_DATA_CHANGED;\r\n\r\n    const subsData = [];\r\n    [changedData].forEach(evt => {\r\n      const { unsubscribe } = cornerstoneViewportService.subscribe(evt, () => {\r\n        handleActiveViewportChange();\r\n      });\r\n\r\n      subsData.push(unsubscribe);\r\n    });\r\n\r\n    // Clean up\r\n    return () => {\r\n      subsGrid.forEach(unsub => unsub());\r\n      subsData.forEach(unsub => unsub());\r\n    };\r\n  }, []);\r\n\r\n  const onSegmentationAdd = async () => {\r\n    const displaySetUID = viewportGridService.getDisplaySetsUIDsForViewport('default')[0];\r\n    const toolGroupId = toolGroupService.getToolGroupForViewport('default').id;\r\n    const LABELMAP = Enums.SegmentationRepresentations.Labelmap;\r\n    const options = { label: `Segmentation ${visibleSegmentations.length + 1}` };\r\n\r\n    const segId = await segmentationService.createSegmentationForDisplaySet(displaySetUID, options);\r\n    await segmentationService.addSegmentationRepresentationToToolGroup(toolGroupId, segId, true, LABELMAP);\r\n\r\n    // Also create hidden segmentation\r\n    const dentascanDisplaySet = displaySetService.getActiveDisplaySets().find(\r\n      displaySet => displaySet.SeriesInstanceUID.includes('dentascan')\r\n    );\r\n    if (dentascanDisplaySet) {\r\n      const dentascanSegId = await segmentationService.createSegmentationForDisplaySet(\r\n        dentascanDisplaySet.displaySetInstanceUID, options\r\n      );\r\n      await segmentationService.addSegmentationRepresentationToToolGroup(toolGroupId, dentascanSegId, true, LABELMAP);\r\n\r\n      const activeViewportId = viewportGridService.getActiveViewportId();\r\n      if (!isDentascanViewport(activeViewportId)) {\r\n        segmentationService.setActiveSegmentationForToolGroup(segId, toolGroupId);\r\n      }\r\n    }\r\n\r\n    onSegmentAdd(segId);\r\n  };\r\n\r\n  const onSegmentationClick = (segmentationId: string) => {\r\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\r\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\r\n    };\r\n  };\r\n\r\n  const onSegmentationDelete = (segmentationId: string) => {\r\n    // Also delete hidden segmentation\r\n    // Delete hidden segmentation first so the new active segmentation is visible\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      segmentationService.remove(hiddenSegmentation.id);\r\n    }\r\n\r\n    segmentationService.remove(segmentationId);\r\n  };\r\n\r\n  const onSegmentClick = (segmentationId, segmentIndex) => {\r\n    segmentationService.setActiveSegment(segmentationId, segmentIndex);\r\n\r\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\r\n      segmentationService.setActiveSegmentationForToolGroup(segmentationId, toolGroupId);\r\n      segmentationService.jumpToSegmentCenter(segmentationId, segmentIndex, toolGroupId);\r\n    };\r\n\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      segmentationService.setActiveSegment(hiddenSegmentation.id, segmentIndex);\r\n      // Also jump for hidden segment\r\n      for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(hiddenSegmentation.id)) {\r\n        segmentationService.jumpToSegmentCenter(hiddenSegmentation.id, segmentIndex, toolGroupId);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onSegmentEdit = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n    const segment = segmentation.segments[segmentIndex];\r\n    const { label } = segment;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.setSegmentLabel(segmentationId, segmentIndex, label);\r\n      // Also edit hidden segment\r\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n      if (hiddenSegmentation) {\r\n        segmentationService.setSegmentLabel(hiddenSegmentation.id, segmentIndex, label);\r\n      }\r\n    });\r\n  };\r\n\r\n  const onSegmentAdd = (segmentationId) => {\r\n    const segmentIndex = Math.max(1, segmentationService.getSegmentation(segmentationId).segments.length);\r\n    const toolGroupId = toolGroupService.getToolGroupForViewport('default').id;\r\n    const config = {\r\n      segmentIndex: segmentIndex,\r\n      toolGroupId: toolGroupId,\r\n      properties: {\r\n        label: `Segment ${segmentIndex}`,\r\n        color: [Math.floor(random() * 256), Math.floor(random() * 256), Math.floor(random() * 256)] as RGB,\r\n        opacity: 255,\r\n        visibility: true,\r\n        isLocked: false,\r\n        active: true\r\n      }\r\n    }\r\n\r\n    segmentationService.addSegment(segmentationId, config);\r\n\r\n    // Also add on hidden segmentation\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      segmentationService.addSegment(hiddenSegmentation.id, config);\r\n    }\r\n  }\r\n\r\n  const onSegmentationEdit = (segmentationId) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const { label } = segmentation;\r\n\r\n    callInputDialog(uiDialogService, label, (label, actionId) => {\r\n      if (label === '') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.addOrUpdateSegmentation(\r\n        {\r\n          id: segmentationId,\r\n          label,\r\n        },\r\n        false, // suppress event\r\n        true // notYetUpdatedAtSource\r\n      );\r\n\r\n      // Also update hidden segmentation\r\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n      if (hiddenSegmentation) {\r\n        segmentationService.addOrUpdateSegmentation({ id: hiddenSegmentation.id, label }, false, true);\r\n      }\r\n    });\r\n  };\r\n\r\n  const onSegmentColorClick = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n    const segment = segmentation.segments[segmentIndex];\r\n    const { color, opacity } = segment;\r\n\r\n    const rgbaColor = {\r\n      r: color[0],\r\n      g: color[1],\r\n      b: color[2],\r\n      a: opacity / 255.0,\r\n    };\r\n\r\n    callColorPickerDialog(uiDialogService, rgbaColor, (newRgbaColor, actionId) => {\r\n      if (actionId === 'cancel') {\r\n        return;\r\n      }\r\n\r\n      segmentationService.setSegmentRGBAColor(segmentationId, segmentIndex, [\r\n        newRgbaColor.r,\r\n        newRgbaColor.g,\r\n        newRgbaColor.b,\r\n        newRgbaColor.a * 255.0,\r\n      ]);\r\n\r\n      // Also update hidden segment\r\n      const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n      if (hiddenSegmentation) {\r\n        segmentationService.setSegmentRGBAColor(hiddenSegmentation.id, segmentIndex, [\r\n          newRgbaColor.r,\r\n          newRgbaColor.g,\r\n          newRgbaColor.b,\r\n          newRgbaColor.a * 255.0,\r\n        ]);\r\n      }\r\n    });\r\n  };\r\n\r\n  const onSegmentDelete = (segmentationId, segmentIndex) => {\r\n    segmentationService.removeSegment(segmentationId, segmentIndex);\r\n    // Also delete hidden segment\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      segmentationService.removeSegment(hiddenSegmentation.id, segmentIndex);\r\n    }\r\n  };\r\n\r\n  // segment hide\r\n  const onToggleSegmentVisibility = (segmentationId, segmentIndex) => {\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const segmentInfo = segmentation.segments[segmentIndex];\r\n    const isVisible = !segmentInfo.isVisible;\r\n\r\n    // Todo: right now we apply the visibility to all tool groups\r\n    for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(segmentationId)) {\r\n      segmentationService.setSegmentVisibility(\r\n        segmentationId,\r\n        segmentIndex,\r\n        isVisible,\r\n        toolGroupId\r\n      );\r\n    };\r\n\r\n    // Also hide hidden segment\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      for (const toolGroupId of segmentationService.getToolGroupIdsWithSegmentation(hiddenSegmentation.id)) {\r\n        segmentationService.setSegmentVisibility(\r\n          hiddenSegmentation.id,\r\n          segmentIndex,\r\n          isVisible,\r\n          toolGroupId\r\n        );\r\n      };\r\n    }\r\n  };\r\n\r\n  const onToggleSegmentLock = (segmentationId, segmentIndex) => {\r\n    segmentationService.toggleSegmentLocked(segmentationId, segmentIndex);\r\n    // Also lock hidden segment\r\n    const hiddenSegmentation = segmentationService.getHiddenSegmentation(segmentationId);\r\n    if (hiddenSegmentation) {\r\n      segmentationService.toggleSegmentLocked(hiddenSegmentation.id, segmentIndex);\r\n    }\r\n  };\r\n\r\n  const onToggleSegmentationVisibility = segmentationId => {\r\n    segmentationService.toggleSegmentationVisibility(segmentationId);\r\n    const segmentation = segmentationService.getSegmentation(segmentationId);\r\n    const isVisible = segmentation.isVisible;\r\n    const segments = segmentation.segments;\r\n\r\n    const toolGroupIds = segmentationService.getToolGroupIdsWithSegmentation(segmentationId);\r\n\r\n    toolGroupIds.forEach(toolGroupId => {\r\n      segments.forEach((segment, segmentIndex) => {\r\n        segmentationService.setSegmentVisibility(\r\n          segmentationId,\r\n          segmentIndex,\r\n          isVisible,\r\n          toolGroupId\r\n        );\r\n      });\r\n    });\r\n  };\r\n\r\n  const _setSegmentationConfiguration = useCallback(\r\n    (key, value) => {\r\n      segmentationService.setConfiguration({[key]: value});\r\n    }, [segmentationService]\r\n  );\r\n\r\n  const onSegmentationDownload = segmentationId => {\r\n    commandsManager.runCommand('downloadSegmentation', {\r\n      segmentationId,\r\n    });\r\n  };\r\n\r\n  const storeSegmentation = async segmentationId => {\r\n    const datasources = extensionManager.getActiveDataSource();\r\n\r\n    const displaySetInstanceUIDs = await createReportAsync({\r\n      servicesManager,\r\n      getReport: () =>\r\n        commandsManager.runCommand('storeSegmentation', {\r\n          segmentationId,\r\n          dataSource: datasources[0],\r\n        }),\r\n      reportType: 'Segmentation',\r\n    });\r\n\r\n    // Show the exported report in the active viewport as read only (similar to SR)\r\n    if (displaySetInstanceUIDs) {\r\n      // clear the segmentation that we exported, similar to the storeMeasurement\r\n      // where we remove the measurements and prompt again the user if they would like\r\n      // to re-read the measurements in a SR read only viewport\r\n      segmentationService.remove(segmentationId);\r\n\r\n      viewportGridService.setDisplaySetsForViewport({\r\n        viewportId: viewportGridService.getActiveViewportId(),\r\n        displaySetInstanceUIDs,\r\n      });\r\n    }\r\n  };\r\n\r\n  const onSegmentationDownloadRTSS = segmentationId => {\r\n    commandsManager.runCommand('downloadRTSS', {\r\n      segmentationId,\r\n    });\r\n  };\r\n\r\n  const SegmentationGroupTableComponent =\r\n    components[configuration?.segmentationPanelMode] || SegmentationGroupTable;\r\n  const allowAddSegment = configuration?.addSegment;\r\n  const onSegmentationAddWrapper =\r\n    configuration?.onSegmentationAdd && typeof configuration?.onSegmentationAdd === 'function'\r\n      ? configuration?.onSegmentationAdd\r\n      : onSegmentationAdd;\r\n\r\n  return (\r\n    <div className=\"flex flex-col flex-auto min-h-0F mt-1\">\r\n      {/* Segmentation tool edition */}\r\n      {/* <BaseToolEdit\r\n        segmentationService={segmentationService}\r\n        cornerstoneViewportService={cornerstoneViewportService}\r\n        toolbarService={toolbarService}\r\n      /> */}\r\n      {/* show segmentation table */}\r\n      <SegmentationGroupTableComponent\r\n        title={t('Segmentations')}\r\n        segmentations={visibleSegmentations}\r\n        hiddenSegmentations={hiddenSegmentations}\r\n        segmentationConfig={{ initialConfig: segmentationConfiguration }}\r\n        disableEditing={configuration.disableEditing}\r\n        showAddSegment={allowAddSegment}\r\n        showDeleteSegment={true}\r\n        onSegmentationAdd={onSegmentationAddWrapper}\r\n        onSegmentationEdit={onSegmentationEdit}\r\n        onSegmentationClick={onSegmentationClick}\r\n        onSegmentationDelete={onSegmentationDelete}\r\n        onSegmentationDownload={onSegmentationDownload}\r\n        onSegmentationDownloadRTSS={onSegmentationDownloadRTSS}\r\n        storeSegmentation={storeSegmentation}\r\n        onSegmentClick={onSegmentClick}\r\n        onSegmentAdd={onSegmentAdd}\r\n        onSegmentDelete={onSegmentDelete}\r\n        onSegmentEdit={onSegmentEdit}\r\n        onToggleSegmentationVisibility={onToggleSegmentationVisibility}\r\n        onToggleSegmentVisibility={onToggleSegmentVisibility}\r\n        onToggleSegmentLock={onToggleSegmentLock}\r\n        onSegmentColorClick={onSegmentColorClick}\r\n        setFillAlpha={value => _setSegmentationConfiguration('fillAlpha', value)}\r\n        setFillAlphaInactive={value => _setSegmentationConfiguration('fillAlphaInactive', value)}\r\n        setOutlineWidthActive={value => _setSegmentationConfiguration('outlineWidthActive', value)}\r\n        setOutlineOpacityActive={value => _setSegmentationConfiguration('outlineOpacity', value)}\r\n        setRenderFill={value => _setSegmentationConfiguration('renderFill', value)}\r\n        setRenderInactiveSegmentations={value => _setSegmentationConfiguration('renderInactiveSegmentations', value)}\r\n        setRenderOutline={value => _setSegmentationConfiguration('renderOutline', value)}\r\n\r\n        addSegmentationClassName={addSegmentationClassName}\r\n      />\r\n      <div className=\"h-[6px] bg-black \"></div>\r\n      <SegmentationImportExport\r\n        segmentationService={segmentationService}\r\n        uiNotificationService={uiNotificationService}\r\n        hangingProtocolService={hangingProtocolService}\r\n        toolGroupService={toolGroupService}\r\n        viewportGridService={viewportGridService}\r\n        cornerstoneCacheService={cornerstoneCacheService}\r\n      />\r\n    </div>\r\n  )\r\n}\r\n\r\nPanelSegmentation.propTypes = {\r\n  commandsManager: PropTypes.shape({\r\n    runCommand: PropTypes.func.isRequired,\r\n  }),\r\n  servicesManager: PropTypes.shape({\r\n    services: PropTypes.shape({\r\n      segmentationService: PropTypes.shape({\r\n        getSegmentation: PropTypes.func.isRequired,\r\n        getSegmentations: PropTypes.func.isRequired,\r\n        toggleSegmentationVisibility: PropTypes.func.isRequired,\r\n        subscribe: PropTypes.func.isRequired,\r\n        EVENTS: PropTypes.object.isRequired,\r\n      }).isRequired,\r\n    }).isRequired,\r\n  }).isRequired,\r\n};\r\n","import React from 'react';\r\n\r\nimport { useAppConfig } from '@state';\r\nimport { Toolbox } from '@ohif/ui';\r\nimport PanelSegmentation from './panels/PanelSegmentation';\r\n\r\nconst getPanelModule = ({\r\n  commandsManager,\r\n  servicesManager,\r\n  extensionManager,\r\n  configuration,\r\n  title,\r\n}: withAppTypes) => {\r\n  const { customizationService } = servicesManager.services;\r\n\r\n  const wrappedPanelSegmentation = configuration => {\r\n    const [appConfig] = useAppConfig();\r\n\r\n    return (\r\n      <PanelSegmentation\r\n        commandsManager={commandsManager}\r\n        servicesManager={servicesManager}\r\n        extensionManager={extensionManager}\r\n        configuration={{\r\n          ...configuration,\r\n          disableEditing: appConfig.disableEditing,\r\n          ...customizationService.get('segmentation.panel'),\r\n        }}\r\n      />\r\n    );\r\n  };\r\n\r\n  const wrappedPanelSegmentationWithTools = configuration => {\r\n    const [appConfig] = useAppConfig();\r\n\r\n    return (\r\n      <>\r\n        <Toolbox\r\n          commandsManager={commandsManager}\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          buttonSectionId=\"segmentationToolbox\"\r\n          title=\"Segmentation Tools\"\r\n          configuration={{\r\n            ...configuration,\r\n          }}\r\n        />\r\n        <PanelSegmentation\r\n          commandsManager={commandsManager}\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          configuration={{\r\n            ...configuration,\r\n            disableEditing: appConfig.disableEditing,\r\n            ...customizationService.get('segmentation.panel'),\r\n          }}\r\n        />\r\n      </>\r\n    );\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'panelSegmentation',\r\n      iconName: 'tab-segmentation',\r\n      iconLabel: 'Segmentation',\r\n      label: 'Segmentation',\r\n      component: wrappedPanelSegmentation,\r\n    },\r\n    {\r\n      name: 'panelSegmentationWithTools',\r\n      iconName: 'tab-segmentation',\r\n      iconLabel: 'Segmentation',\r\n      label: 'Segmentation',\r\n      component: wrappedPanelSegmentationWithTools,\r\n    },\r\n  ];\r\n};\r\n\r\nexport default getPanelModule;\r\n","import { Enums, cache } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Updates the viewports in preparation for rendering segmentations.\r\n * Evaluates each viewport to determine which need modifications,\r\n * then for those viewports, changes them to a volume type and ensures\r\n * they are ready for segmentation rendering.\r\n *\r\n * @param {Object} params - Parameters for the function.\r\n * @param params.viewportId - ID of the viewport to be updated.\r\n * @param params.loadFn - Function to load the segmentation data.\r\n * @param params.servicesManager - The services manager.\r\n * @param params.displaySet -  the display set.\r\n * @param params.initialSliceIndex - The initial slice index.\r\n *\r\n * @returns Returns true upon successful update of viewports for segmentation rendering.\r\n */\r\nasync function updateViewportsForSegmentationRendering({\r\n  viewportId,\r\n  loadFn,\r\n  servicesManager,\r\n  displaySet,\r\n  initialSliceIndex = null,\r\n}: {\r\n  viewportId: string;\r\n  loadFn: () => Promise<string>;\r\n  servicesManager: AppTypes.ServicesManager;\r\n  displaySet?: any;\r\n  initialSliceIndex?: number;\r\n}) {\r\n  const { cornerstoneViewportService, segmentationService, viewportGridService } =\r\n    servicesManager.services;\r\n\r\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n  const targetViewportId = viewport.viewportOptions.viewportId;\r\n\r\n  const referencedDisplaySetInstanceUID =\r\n    displaySet?.referencedDisplaySetInstanceUID || viewport?.displaySetInstanceUIDs[0];\r\n\r\n  const updatedViewports = getUpdatedViewportsForSegmentation({\r\n    viewportId,\r\n    servicesManager,\r\n    displaySet,\r\n  });\r\n\r\n  // create Segmentation callback which needs to be waited until\r\n  // the volume is created (if coming from stack)\r\n  const createSegmentationForVolume = async () => {\r\n    const segmentationId = await loadFn();\r\n    segmentationService.hydrateSegmentation(segmentationId);\r\n  };\r\n\r\n  // the reference volume that is used to draw the segmentation. so check if the\r\n  // volume exists in the cache (the target Viewport is already a volume viewport)\r\n  const volumeExists = Array.from(cache._volumeCache.keys()).some(volumeId =>\r\n    volumeId.includes(referencedDisplaySetInstanceUID)\r\n  );\r\n\r\n  updatedViewports.forEach(async viewport => {\r\n    viewport.viewportOptions = {\r\n      ...viewport.viewportOptions,\r\n      viewportType: displaySet?.Modality === 'RTSTRUCT' ? 'stack' : 'volume',\r\n      needsRerendering: true,\r\n    };\r\n    const viewportId = viewport.viewportId;\r\n\r\n    // maintain the prehydration slice on the target viewport only\r\n    if (viewportId === targetViewportId) {\r\n      viewport.viewportOptions.initialImageOptions = {\r\n        index: initialSliceIndex,\r\n        useOnce: true,\r\n      };\r\n    }\r\n\r\n    const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n    const prevCamera = csViewport.getCamera();\r\n\r\n    // only run the createSegmentationForVolume for the targetViewportId\r\n    // since the rest will get handled by cornerstoneViewportService\r\n    if ((volumeExists || displaySet.Modality === 'RTSTRUCT') && viewportId === targetViewportId) {\r\n      await createSegmentationForVolume();\r\n      return;\r\n    }\r\n\r\n    const createNewSegmentationWhenVolumeMounts = async evt => {\r\n      const isTheActiveViewportVolumeMounted = evt.detail.volumeActors?.find(ac =>\r\n        ac.uid.includes(referencedDisplaySetInstanceUID)\r\n      );\r\n\r\n      // Note: make sure to re-grab the viewport since it might have changed\r\n      // during the time it took for the volume to be mounted, for instance\r\n      // the stack viewport has been changed to a volume viewport\r\n      const volumeViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n      volumeViewport.setCamera(prevCamera);\r\n\r\n      volumeViewport.element.removeEventListener(\r\n        Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n        createNewSegmentationWhenVolumeMounts\r\n      );\r\n\r\n      if (!isTheActiveViewportVolumeMounted) {\r\n        // it means it is one of those other updated viewports so just update the camera\r\n        return;\r\n      }\r\n\r\n      if (viewportId === targetViewportId) {\r\n        await createSegmentationForVolume();\r\n      }\r\n    };\r\n\r\n    csViewport.element.addEventListener(\r\n      Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME,\r\n      createNewSegmentationWhenVolumeMounts\r\n    );\r\n  });\r\n\r\n  // Set the displaySets for the viewports that require to be updated\r\n  viewportGridService.setDisplaySetsForViewports(updatedViewports);\r\n\r\n  return true;\r\n}\r\n\r\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\r\n  const { viewports, activeViewportId } = viewportGridService.getState();\r\n  const targetViewportId = viewportId || activeViewportId;\r\n\r\n  const viewport = viewports.get(targetViewportId);\r\n\r\n  return viewport;\r\n};\r\n\r\n/**\r\n * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\r\n * This function evaluates viewports based on their compatibility with the provided segmentation's\r\n * frame of reference UID and appends them to the updated list if they should render the segmentation.\r\n *\r\n * @param {Object} params - Parameters for the function.\r\n * @param params.viewportId - the ID of the viewport to be updated.\r\n * @param params.servicesManager - The services manager\r\n * @param params.displaySet -  the display set.\r\n *\r\n * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\r\n */\r\nfunction getUpdatedViewportsForSegmentation({\r\n  viewportId,\r\n  servicesManager,\r\n  displaySet,\r\n}: withAppTypes) {\r\n  const { hangingProtocolService, displaySetService, segmentationService, viewportGridService } =\r\n    servicesManager.services;\r\n\r\n  const { viewports, isHangingProtocolLayout } = viewportGridService.getState();\r\n\r\n  const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n  const targetViewportId = viewport.viewportOptions.viewportId;\r\n\r\n  const displaySetInstanceUIDs = viewports.get(targetViewportId).displaySetInstanceUIDs;\r\n\r\n  const referenceDisplaySetInstanceUID =\r\n    displaySet?.referencedDisplaySetInstanceUID || displaySetInstanceUIDs[0];\r\n\r\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(referenceDisplaySetInstanceUID);\r\n  const segmentationFrameOfReferenceUID = referencedDisplaySet.instances[0].FrameOfReferenceUID;\r\n\r\n  const updatedViewports = hangingProtocolService.getViewportsRequireUpdate(\r\n    targetViewportId,\r\n    referenceDisplaySetInstanceUID,\r\n    isHangingProtocolLayout\r\n  );\r\n\r\n  viewports.forEach((viewport, viewportId) => {\r\n    if (\r\n      targetViewportId === viewportId ||\r\n      updatedViewports.find(v => v.viewportId === viewportId)\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    const shouldDisplaySeg = segmentationService.shouldRenderSegmentation(\r\n      viewport.displaySetInstanceUIDs,\r\n      segmentationFrameOfReferenceUID\r\n    );\r\n\r\n    if (shouldDisplaySeg) {\r\n      updatedViewports.push({\r\n        viewportId,\r\n        displaySetInstanceUIDs: viewport.displaySetInstanceUIDs,\r\n        viewportOptions: {\r\n          viewportType: displaySet?.Modality === 'RTSTRUCT' ? 'stack' : 'volume',\r\n          needsRerendering: true,\r\n        },\r\n      });\r\n    }\r\n  });\r\n\r\n  return updatedViewports.filter(v => v.viewportOptions?.viewportType !== 'volume3d');\r\n}\r\n\r\nexport {\r\n  updateViewportsForSegmentationRendering,\r\n  getUpdatedViewportsForSegmentation,\r\n  getTargetViewport,\r\n};\r\n","import dcmjs from 'dcmjs';\r\nimport { createReportDialogPrompt } from '@ohif/extension-default';\r\nimport { Types } from '@ohif/core';\r\nimport { cache, metaData } from '@cornerstonejs/core';\r\nimport {\r\n  segmentation as cornerstoneToolsSegmentation,\r\n  Enums as cornerstoneToolsEnums,\r\n  utilities,\r\n} from '@cornerstonejs/tools';\r\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\r\nimport { classes, DicomMetadataStore } from '@ohif/core';\r\n\r\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\r\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\r\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\r\n\r\nimport {\r\n  updateViewportsForSegmentationRendering,\r\n  getUpdatedViewportsForSegmentation,\r\n  getTargetViewport,\r\n} from './utils/hydrationUtils';\r\nconst { segmentation: segmentationUtils } = utilities;\r\n\r\nconst { datasetToBlob } = dcmjs.data;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    Segmentation: { generateLabelMaps2DFrom3D, generateSegmentation },\r\n  },\r\n} = adaptersSEG;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    RTSS: { generateRTSSFromSegmentations },\r\n  },\r\n} = adaptersRT;\r\n\r\nconst { downloadDICOMData } = helpers;\r\n\r\nconst commandsModule = ({\r\n  servicesManager,\r\n  extensionManager,\r\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\r\n  const {\r\n    uiNotificationService,\r\n    segmentationService,\r\n    uiDialogService,\r\n    displaySetService,\r\n    viewportGridService,\r\n    toolGroupService,\r\n    cornerstoneViewportService,\r\n  } = servicesManager.services;\r\n\r\n  const actions = {\r\n    /**\r\n     * Retrieves a list of viewports that require updates in preparation for segmentation rendering.\r\n     * This function evaluates viewports based on their compatibility with the provided segmentation's\r\n     * frame of reference UID and appends them to the updated list if they should render the segmentation.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - the ID of the viewport to be updated.\r\n     * @param params.servicesManager - The services manager\r\n     * @param params.referencedDisplaySetInstanceUID - Optional UID for the referenced display set instance.\r\n     *\r\n     * @returns {Array} Returns an array of viewports that require updates for segmentation rendering.\r\n     */\r\n    getUpdatedViewportsForSegmentation,\r\n    /**\r\n     * Creates an empty segmentation for a specified viewport.\r\n     * It first checks if the display set associated with the viewport is reconstructable.\r\n     * If not, it raises a notification error. Otherwise, it creates a new segmentation\r\n     * for the display set after handling the necessary steps for making the viewport\r\n     * a volume viewport first\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    createEmptySegmentationForViewport: async ({ viewportId }) => {\r\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n      // Todo: add support for multiple display sets\r\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n      if (!displaySet.isReconstructable) {\r\n        uiNotificationService.show({\r\n          title: 'Segmentation',\r\n          message: 'Segmentation is not supported for non-reconstructible displaysets yet',\r\n          type: 'error',\r\n        });\r\n        return;\r\n      }\r\n\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        displaySet,\r\n        loadFn: async () => {\r\n          const currentSegmentations = segmentationService.getSegmentations();\r\n          const segmentationId = await segmentationService.createSegmentationForDisplaySet(\r\n            displaySetInstanceUID,\r\n            { label: `Segmentation ${currentSegmentations.length + 1}` }\r\n          );\r\n\r\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\r\n\r\n          await segmentationService.addSegmentationRepresentationToToolGroup(\r\n            toolGroupId,\r\n            segmentationId\r\n          );\r\n\r\n          // Add only one segment for now\r\n          segmentationService.addSegment(segmentationId, {\r\n            toolGroupId,\r\n            segmentIndex: 1,\r\n            properties: {\r\n              label: 'Segment 1',\r\n              color: [255, 0, 0],\r\n              opacity: 255,\r\n              visibility: true,\r\n              isLocked: false,\r\n              active: true\r\n            },\r\n          });\r\n\r\n          return segmentationId;\r\n        },\r\n      });\r\n    },\r\n    /**\r\n     * Loads segmentations for a specified viewport.\r\n     * The function prepares the viewport for rendering, then loads the segmentation details.\r\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentations - Array of segmentations to be loaded.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        loadFn: async () => {\r\n          // Todo: handle adding more than one segmentation\r\n          const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n          const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n          const segmentation = segmentations[0];\r\n          const segmentationId = segmentation.id;\r\n          const label = segmentation.label;\r\n          const segments = segmentation.segments;\r\n\r\n          delete segmentation.segments;\r\n\r\n          await segmentationService.createSegmentationForDisplaySet(displaySetInstanceUID, {\r\n            segmentationId,\r\n            label,\r\n          });\r\n\r\n          if (segmentation.scalarData) {\r\n            const labelmapVolume = segmentationService.getLabelmapVolume(segmentationId);\r\n            labelmapVolume.scalarData.set(segmentation.scalarData);\r\n          }\r\n\r\n          segmentationService.addOrUpdateSegmentation(segmentation);\r\n\r\n          const toolGroupId = viewport.viewportOptions.toolGroupId;\r\n          await segmentationService.addSegmentationRepresentationToToolGroup(\r\n            toolGroupId,\r\n            segmentationId\r\n          );\r\n\r\n          segments.forEach(segment => {\r\n            if (segment === null) {\r\n              return;\r\n            }\r\n            segmentationService.addSegment(segmentationId, {\r\n              segmentIndex: segment.segmentIndex,\r\n              toolGroupId,\r\n              properties: {\r\n                color: segment.color,\r\n                label: segment.label,\r\n                opacity: segment.opacity,\r\n                isLocked: segment.isLocked,\r\n                visibility: segment.isVisible,\r\n                active: segmentation.activeSegmentIndex === segment.segmentIndex,\r\n              },\r\n            });\r\n          });\r\n\r\n          if (segmentation.centroidsIJK) {\r\n            segmentationService.setCentroids(segmentation.id, segmentation.centroidsIJK);\r\n          }\r\n\r\n          return segmentationId;\r\n        },\r\n      });\r\n    },\r\n    /**\r\n     * Loads segmentation display sets for a specified viewport.\r\n     * Depending on the modality of the display set (SEG or RTSTRUCT),\r\n     * it chooses the appropriate service function to create\r\n     * the segmentation for the display set.\r\n     * The function then prepares the viewport for rendering segmentation.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.viewportId - ID of the viewport where the segmentation display sets should be loaded.\r\n     * @param params.displaySets - Array of display sets to be loaded for segmentation.\r\n     *\r\n     */\r\n    loadSegmentationDisplaySetsForViewport: async ({ viewportId, displaySets }) => {\r\n      // Todo: handle adding more than one segmentation\r\n      const displaySet = displaySets[0];\r\n      const referencedDisplaySet = displaySetService.getDisplaySetByUID(\r\n        displaySet.referencedDisplaySetInstanceUID\r\n      );\r\n      const viewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\r\n      const initialSliceIndex = viewport.getSliceIndex();\r\n\r\n      updateViewportsForSegmentationRendering({\r\n        viewportId,\r\n        servicesManager,\r\n        displaySet,\r\n        loadFn: async () => {\r\n          const segDisplaySet = displaySet;\r\n          const suppressEvents = false;\r\n          const serviceFunction =\r\n            segDisplaySet.Modality === 'SEG'\r\n              ? 'createSegmentationForSEGDisplaySet'\r\n              : 'createSegmentationForRTDisplaySet';\r\n\r\n          const boundFn = segmentationService[serviceFunction].bind(segmentationService);\r\n          const segmentationId = await boundFn(segDisplaySet, null, suppressEvents);\r\n          const segmentation = segmentationService.getSegmentation(segmentationId);\r\n          segmentation.description = `S${referencedDisplaySet.SeriesNumber}: ${referencedDisplaySet.SeriesDescription}`;\r\n          return segmentationId;\r\n        },\r\n        initialSliceIndex,\r\n      });\r\n    },\r\n    /**\r\n     * Generates a segmentation from a given segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * its referenced volume, extracts label maps from the\r\n     * segmentation volume, and produces segmentation data\r\n     * alongside associated metadata.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be generated.\r\n     * @param params.options - Optional configuration for the generation process.\r\n     *\r\n     * @returns Returns the generated segmentation data.\r\n     */\r\n    generateSegmentation: ({ segmentationId, options = {} }) => {\r\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\r\n\r\n      const { referencedVolumeId } = segmentation.representationData.LABELMAP;\r\n\r\n      const segmentationVolume = cache.getVolume(segmentationId);\r\n      const referencedVolume = cache.getVolume(referencedVolumeId);\r\n      const referencedImages = referencedVolume.getCornerstoneImages();\r\n\r\n      const labelmapObj = generateLabelMaps2DFrom3D(segmentationVolume);\r\n\r\n      // Generate fake metadata as an example\r\n      labelmapObj.metadata = [];\r\n\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      segmentationInOHIF.segments.forEach(segment => {\r\n        // segmentation service already has a color for each segment\r\n        if (!segment) {\r\n          return;\r\n        }\r\n        const segmentIndex = segment.segmentIndex;\r\n        const { label, color } = segment;\r\n\r\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\r\n          color.slice(0, 3).map(value => value / 255)\r\n        ).map(value => Math.round(value));\r\n\r\n        const segmentMetadata = {\r\n          SegmentNumber: segmentIndex.toString(),\r\n          SegmentLabel: label,\r\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\r\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\r\n          RecommendedDisplayCIELabValue,\r\n          SegmentedPropertyCategoryCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n          SegmentedPropertyTypeCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n        };\r\n        labelmapObj.metadata[segmentIndex] = segmentMetadata;\r\n      });\r\n\r\n      const generatedSegmentation = generateSegmentation(\r\n        referencedImages,\r\n        labelmapObj,\r\n        metaData,\r\n        options\r\n      );\r\n\r\n      return generatedSegmentation;\r\n    },\r\n    /**\r\n     * Downloads a segmentation based on the provided segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * uses it to generate the corresponding DICOM dataset, which\r\n     * is then downloaded with an appropriate filename.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\r\n     *\r\n     */\r\n    downloadSegmentation: ({ segmentationId }) => {\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const generatedSegmentation = actions.generateSegmentation({\r\n        segmentationId,\r\n      });\r\n\r\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\r\n    },\r\n    /**\r\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\r\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\r\n     * and in its absence, defaults to 'Research Derived Series'.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be stored.\r\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\r\n     *\r\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\r\n     * otherwise throws an error.\r\n     */\r\n    storeSegmentation: async ({ segmentationId, dataSource }) => {\r\n      const promptResult = await createReportDialogPrompt(uiDialogService, {\r\n        extensionManager,\r\n      });\r\n\r\n      if (promptResult.action !== 1 && promptResult.value) {\r\n        return;\r\n      }\r\n\r\n      const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n      if (!segmentation) {\r\n        throw new Error('No segmentation found');\r\n      }\r\n\r\n      const { label } = segmentation;\r\n      const SeriesDescription = promptResult.value || label || 'Research Derived Series';\r\n\r\n      const generatedData = actions.generateSegmentation({\r\n        segmentationId,\r\n        options: {\r\n          SeriesDescription,\r\n        },\r\n      });\r\n\r\n      if (!generatedData || !generatedData.dataset) {\r\n        throw new Error('Error during segmentation generation');\r\n      }\r\n\r\n      const { dataset: naturalizedReport } = generatedData;\r\n\r\n      await dataSource.store.dicom(naturalizedReport);\r\n\r\n      // The \"Mode\" route listens for DicomMetadataStore changes\r\n      // When a new instance is added, it listens and\r\n      // automatically calls makeDisplaySets\r\n\r\n      // add the information for where we stored it to the instance as well\r\n      naturalizedReport.wadoRoot = dataSource.getConfig().wadoRoot;\r\n\r\n      DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n      return naturalizedReport;\r\n    },\r\n    /**\r\n     * Converts segmentations into RTSS for download.\r\n     * This sample function retrieves all segentations and passes to\r\n     * cornerstone tool adapter to convert to DICOM RTSS format. It then\r\n     * converts dataset to downloadable blob.\r\n     *\r\n     */\r\n    downloadRTSS: ({ segmentationId }) => {\r\n      const segmentations = segmentationService.getSegmentation(segmentationId);\r\n      const vtkUtils = {\r\n        vtkImageMarchingSquares,\r\n        vtkDataArray,\r\n        vtkImageData,\r\n      };\r\n\r\n      const RTSS = generateRTSSFromSegmentations(\r\n        segmentations,\r\n        classes.MetadataProvider,\r\n        DicomMetadataStore,\r\n        cache,\r\n        cornerstoneToolsEnums,\r\n        vtkUtils\r\n      );\r\n\r\n      try {\r\n        const reportBlob = datasetToBlob(RTSS);\r\n\r\n        //Create a URL for the binary.\r\n        const objectUrl = URL.createObjectURL(reportBlob);\r\n        window.location.assign(objectUrl);\r\n      } catch (e) {\r\n        console.warn(e);\r\n      }\r\n    },\r\n    setBrushSize: ({ value, toolNames }) => {\r\n      const brushSize = Number(value);\r\n\r\n      toolGroupService.getToolGroupIds()?.forEach(toolGroupId => {\r\n        if (toolNames?.length === 0) {\r\n          segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize);\r\n        } else {\r\n          toolNames?.forEach(toolName => {\r\n            segmentationUtils.setBrushSizeForToolGroup(toolGroupId, brushSize, toolName);\r\n          });\r\n        }\r\n      });\r\n    },\r\n    setThresholdRange: ({\r\n      value,\r\n      toolNames = ['ThresholdCircularBrush', 'ThresholdSphereBrush'],\r\n      toolGroupIds = toolGroupService.getToolGroupIds(),\r\n    }) => {\r\n      toolGroupIds?.forEach(toolGroupId => {\r\n        const toolGroup = toolGroupService.getToolGroup(toolGroupId);\r\n        if (toolGroup) {\r\n          toolNames?.forEach(toolName => {\r\n            toolGroup.setToolConfiguration(toolName, {\r\n              strategySpecificConfiguration: { THRESHOLD: { threshold: value } },\r\n            });\r\n          });\r\n        }\r\n      });\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    getUpdatedViewportsForSegmentation: {\r\n      commandFn: actions.getUpdatedViewportsForSegmentation,\r\n    },\r\n    loadSegmentationDisplaySetsForViewport: {\r\n      commandFn: actions.loadSegmentationDisplaySetsForViewport,\r\n    },\r\n    loadSegmentationsForViewport: {\r\n      commandFn: actions.loadSegmentationsForViewport,\r\n    },\r\n    createEmptySegmentationForViewport: {\r\n      commandFn: actions.createEmptySegmentationForViewport,\r\n    },\r\n    generateSegmentation: {\r\n      commandFn: actions.generateSegmentation,\r\n    },\r\n    downloadSegmentation: {\r\n      commandFn: actions.downloadSegmentation,\r\n    },\r\n    storeSegmentation: {\r\n      commandFn: actions.storeSegmentation,\r\n    },\r\n    downloadRTSS: {\r\n      commandFn: actions.downloadRTSS,\r\n    },\r\n    setBrushSize: {\r\n      commandFn: actions.setBrushSize,\r\n    },\r\n    setThresholdRange: {\r\n      commandFn: actions.setThresholdRange,\r\n    },\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'SEGMENTATION',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import { id } from './id';\r\nimport React from 'react';\r\n\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getHangingProtocolModule from './getHangingProtocolModule';\r\nimport getPanelModule from './getPanelModule';\r\nimport getCommandsModule from './commandsModule';\r\nimport { getToolbarModule } from './getToolbarModule';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\r\n});\r\n\r\nconst OHIFCornerstoneSEGViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n  /**\r\n   * PanelModule should provide a list of panels that will be available in OHIF\r\n   * for Modes to consume and render. Each panel is defined by a {name,\r\n   * iconName, iconLabel, label, component} object. Example of a panel module\r\n   * is the StudyBrowserPanel that is provided by the default extension in OHIF.\r\n   */\r\n  getPanelModule,\r\n  getCommandsModule,\r\n  getToolbarModule,\r\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\r\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSEGViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          commandsManager={commandsManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n  getHangingProtocolModule,\r\n};\r\n\r\nexport default extension;\r\n","export function getToolbarModule({ servicesManager }: withAppTypes) {\r\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\r\n  return [\r\n    {\r\n      name: 'evaluate.cornerstone.segmentation',\r\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\r\n        // Todo: we need to pass in the button section Id since we are kind of\r\n        // forcing the button to have black background since initially\r\n        // it is designed for the toolbox not the toolbar on top\r\n        // we should then branch the buttonSectionId to have different styles\r\n        const segmentations = segmentationService.getSegmentations();\r\n        if (!segmentations?.length) {\r\n          return {\r\n            disabled: true,\r\n            className: '!text-common-bright !bg-black opacity-50',\r\n            disabledText: disabledText ?? 'No segmentations available',\r\n          };\r\n        }\r\n\r\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\r\n\r\n        if (!toolGroup) {\r\n          return {\r\n            disabled: true,\r\n            className: '!text-common-bright ohif-disabled',\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        const toolName = toolbarService.getToolNameForButton(button);\r\n\r\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\r\n          return {\r\n            disabled: true,\r\n            className: '!text-common-bright ohif-disabled',\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        const isPrimaryActive = toolNames\r\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\r\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\r\n\r\n        return {\r\n          disabled: false,\r\n          className: isPrimaryActive\r\n            ? '!text-black !bg-primary-light hover:bg-primary-light hover-text-black hover:cursor-pointer'\r\n            : '!text-common-bright !bg-black hover:bg-primary-light hover:cursor-pointer hover:text-black',\r\n          // Todo: isActive right now is used for nested buttons where the primary\r\n          // button needs to be fully rounded (vs partial rounded) when active\r\n          // otherwise it does not have any other use\r\n          isActive: isPrimaryActive,\r\n        };\r\n      },\r\n    },\r\n  ];\r\n}\r\n","import moment from 'moment';\r\nimport { metaData } from '@cornerstonejs/core';\r\n\r\n/**\r\n * Checks if value is valid.\r\n *\r\n * @param {number} value\r\n * @returns {boolean} is valid.\r\n */\r\nexport function isValidNumber(value) {\r\n  return typeof value === 'number' && !isNaN(value);\r\n}\r\n\r\n/**\r\n * Formats number precision.\r\n *\r\n * @param {number} number\r\n * @param {number} precision\r\n * @returns {number} formatted number.\r\n */\r\nexport function formatNumberPrecision(number, precision = 0) {\r\n  if (number !== null) {\r\n    return parseFloat(number).toFixed(precision);\r\n  }\r\n}\r\n\r\n/**\r\n * Formats DICOM date.\r\n *\r\n * @param {string} date\r\n * @param {string} strFormat\r\n * @returns {string} formatted date.\r\n */\r\nexport function formatDICOMDate(date, strFormat = 'MMM D, YYYY') {\r\n  return moment(date, 'YYYYMMDD').format(strFormat);\r\n}\r\n\r\n/**\r\n *    DICOM Time is stored as HHmmss.SSS, where:\r\n *      HH 24 hour time:\r\n *        m mm        0..59   Minutes\r\n *        s ss        0..59   Seconds\r\n *        S SS SSS    0..999  Fractional seconds\r\n *\r\n *        Goal: '24:12:12'\r\n *\r\n * @param {*} time\r\n * @param {string} strFormat\r\n * @returns {string} formatted name.\r\n */\r\nexport function formatDICOMTime(time, strFormat = 'HH:mm:ss') {\r\n  return moment(time, 'HH:mm:ss').format(strFormat);\r\n}\r\n\r\n/**\r\n * Formats a patient name for display purposes\r\n *\r\n * @param {string} name\r\n * @returns {string} formatted name.\r\n */\r\nexport function formatPN(name) {\r\n  if (!name) {\r\n    return '';\r\n  }\r\n  if (typeof name === 'object') {\r\n    name = name.Alphabetic;\r\n    if (!name) {\r\n      return '';\r\n    }\r\n  }\r\n\r\n  const cleaned = name\r\n    .split('^')\r\n    .filter(s => !!s)\r\n    .join(', ')\r\n    .trim();\r\n  return cleaned === ',' || cleaned === '' ? '' : cleaned;\r\n}\r\n\r\n/**\r\n * Gets compression type\r\n *\r\n * @param {number} imageId\r\n * @returns {string} compression type.\r\n */\r\nexport function getCompression(imageId) {\r\n  const generalImageModule = metaData.get('generalImageModule', imageId) || {};\r\n  const { lossyImageCompression, lossyImageCompressionRatio, lossyImageCompressionMethod } =\r\n    generalImageModule;\r\n\r\n  if (lossyImageCompression === '01' && lossyImageCompressionRatio !== '') {\r\n    const compressionMethod = lossyImageCompressionMethod || 'Lossy: ';\r\n    const compressionRatio = formatNumberPrecision(lossyImageCompressionRatio, 2);\r\n    return compressionMethod + compressionRatio + ' : 1';\r\n  }\r\n\r\n  return 'Lossless / Uncompressed';\r\n}\r\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","instance","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","utils","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","getReferenceDisplaySet","displaySetService","services","referencedDisplaySets","getDisplaySetsForSeries","length","Error","referencedDisplaySet","referencedVolumeURI","referencedVolumeId","load","async","headers","segDisplaySet","segmentationService","getSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","cachedReferencedVolume","cache","getVolume","imageIds","tolerance","skipOverlapping","eventTarget","addEventListener","Enums","Events","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","EVENTS","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","generateToolState","metaData","triggerEvent","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","map","x","Math","round","CONSTANTS","overlappingSegments","show","title","message","type","duration","assign","_loadSegments","suppressEvents","createSegmentationForSEGDisplaySet","then","catch","_load","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","SegmentationPanelMode","uiDialogService","label","callback","dialogId","onSubmitHandler","action","value","dismiss","create","centralize","isDraggable","showOverlay","content","Dialog","contentProps","noCloseButton","onClose","actions","text","ButtonEnums","secondary","primary","onSubmit","body","setValue","React","Input","labelClassName","autoFocus","className","onChange","event","persist","target","onKeyPress","key","rgbaColor","ChromePicker","color","rgb","presetColors","width","hangingProtocolService","toolGroupService","viewportGridService","cornerstoneCacheService","Button","size","small","onClick","importSegmentationFromFolder","getDisplaySetsUIDsForViewport","input","document","createElement","webkitdirectory","onchange","files","Array","from","configurationFile","filter","binaryFile","file","displaySetUID","getToolGroupForViewport","LABELMAP","Labelmap","reader","FileReader","onload","result","options","split","pop","replace","segId","createSegmentationForDisplaySet","addSegmentationRepresentationToToolGroup","setActiveSegmentationForToolGroup","JSON","parse","segment","segmentIndex","addSegment","readAsText","importConfiguration","newScalarData","Uint8Array","segmentationLabel","segmentation","getSegmentations","s","scalarData","getLabelmapVolume","getScalarData","cstSegmentation","readAsArrayBuffer","importBinary","click","getActiveSegmentation","dentascanSegmentations","getDentascanSegmentations","includes","getHiddenSegmentation","segmentsInfo","dimensions","layerSize","nbLayers","zip","JSZip","layerI","pixelData","Uint8ClampedArray","fill","canvas","ctx","getContext","height","imgData","ImageData","colorSpace","putImageData","pngBlob","toBlob","blob","binaryBlob","Blob","jsonBlob","stringify","activeStudyUID","getState","study","DicomMetadataStore","getStudy","StudyDate","PatientName","series","patientNameFormatted","formatPN","generateAsync","saveAs","cbctSegmentationUUID","accessKey","getCbctSegmentationMetadata","generatedSegmentation","getGeneratedSegmentation","segmentationConfig","formData","FormData","volumeArray","pako","append","url","config","method","Authorization","undefined","response","axios","log","components","Expanded","SegmentationGroupTableExpanded","Dropdown","SegmentationGroupTable","random","seed","seededRandom","PanelSegmentation","commandsManager","configuration","activeViewportId","useViewportGrid","cornerstoneViewportService","toolbarService","t","useTranslation","addSegmentationClassName","setAddSegmentationClassName","useState","segmentationConfiguration","setSegmentationConfiguration","getConfiguration","isDentascanViewport","viewportId","volume","getViewportInfo","getViewportData","metadata","viewportDentascanIsActive","getActiveViewportId","visibleSegmentations","setVisibleSegmentations","getAxialSegmentations","hiddenSegmentations","setHiddenSegmentations","isMinimized","setIsMinimized","useCallback","prevState","useEffect","lastSegmentationId","added","SEGMENTATION_ADDED","updated","SEGMENTATION_UPDATED","removed","SEGMENTATION_REMOVED","configChanged","SEGMENTATION_CONFIGURATION_CHANGED","subscriptions","unsubscribe","subscribe","push","unsub","handleActiveViewportChange","activeDisplaySetsUIDs","some","getDisplaySetByUID","changedGrid","ACTIVE_VIEWPORT_ID_CHANGED","ready","VIEWPORTS_READY","subsGrid","changedData","VIEWPORT_DATA_CHANGED","subsData","onSegmentAdd","segmentationId","max","floor","opacity","visibility","isLocked","active","hiddenSegmentation","_setSegmentationConfiguration","setConfiguration","SegmentationGroupTableComponent","segmentationPanelMode","allowAddSegment","onSegmentationAddWrapper","onSegmentationAdd","dentascanDisplaySet","getActiveDisplaySets","find","dentascanSegId","segmentations","initialConfig","disableEditing","showAddSegment","showDeleteSegment","onSegmentationEdit","callInputDialog","actionId","addOrUpdateSegmentation","onSegmentationClick","getToolGroupIdsWithSegmentation","onSegmentationDelete","remove","onSegmentationDownload","runCommand","onSegmentationDownloadRTSS","storeSegmentation","datasources","getActiveDataSource","displaySetInstanceUIDs","createReportAsync","getReport","dataSource","reportType","setDisplaySetsForViewport","onSegmentClick","setActiveSegment","jumpToSegmentCenter","onSegmentDelete","removeSegment","onSegmentEdit","setSegmentLabel","onToggleSegmentationVisibility","toggleSegmentationVisibility","isVisible","setSegmentVisibility","onToggleSegmentVisibility","onToggleSegmentLock","toggleSegmentLocked","onSegmentColorClick","r","g","b","a","callColorPickerDialog","newRgbaColor","setSegmentRGBAColor","setFillAlpha","setFillAlphaInactive","setOutlineWidthActive","setOutlineOpacityActive","setRenderFill","setRenderInactiveSegmentations","setRenderOutline","SegmentationImportExport","propTypes","PropTypes","isRequired","getPanelModule","customizationService","iconName","iconLabel","component","appConfig","useAppConfig","get","Toolbox","buttonSectionId","updateViewportsForSegmentationRendering","loadFn","initialSliceIndex","viewport","getTargetViewport","targetViewportId","updatedViewports","getUpdatedViewportsForSegmentation","createSegmentationForVolume","hydrateSegmentation","volumeExists","_volumeCache","volumeId","needsRerendering","initialImageOptions","index","useOnce","csViewport","getCornerstoneViewport","prevCamera","getCamera","createNewSegmentationWhenVolumeMounts","isTheActiveViewportVolumeMounted","volumeActors","ac","uid","volumeViewport","setCamera","element","removeEventListener","VOLUME_VIEWPORT_NEW_VOLUME","setDisplaySetsForViewports","isHangingProtocolLayout","referenceDisplaySetInstanceUID","segmentationFrameOfReferenceUID","FrameOfReferenceUID","getViewportsRequireUpdate","v","shouldRenderSegmentation","segmentationUtils","utilities","datasetToBlob","generateLabelMaps2DFrom3D","generateSegmentation","RTSS","generateRTSSFromSegmentations","adaptersRT","downloadDICOMData","helpers","commandsModule","createEmptySegmentationForViewport","currentSegmentations","loadSegmentationsForViewport","set","activeSegmentIndex","centroidsIJK","setCentroids","loadSegmentationDisplaySetsForViewport","getSliceIndex","serviceFunction","boundFn","bind","description","cornerstoneToolsSegmentation","representationData","segmentationVolume","getCornerstoneImages","labelmapObj","rgb2DICOMLAB","slice","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","algorithmType","SegmentAlgorithmName","algorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","segmentationInOHIF","dataset","promptResult","createReportDialogPrompt","generatedData","naturalizedReport","store","dicom","getConfig","addInstances","downloadRTSS","vtkUtils","vtkImageMarchingSquares","vtkDataArray","vtkImageData","classes","MetadataProvider","cornerstoneToolsEnums","reportBlob","objectUrl","URL","createObjectURL","window","location","e","warn","setBrushSize","toolNames","brushSize","Number","getToolGroupIds","setBrushSizeForToolGroup","toolName","setThresholdRange","toolGroup","getToolGroup","setToolConfiguration","strategySpecificConfiguration","THRESHOLD","threshold","definitions","commandFn","defaultContext","Component","OHIFCornerstoneSEGViewport","props","fallback","getCommandsModule","getToolbarModule","evaluate","button","disabledText","disabled","getToolNameForButton","hasTool","isPrimaryActive","getActivePrimaryMouseButtonTool","isActive","getViewportModule","_extends","getSopClassHandlerModule","getHangingProtocolModule","formatNumberPrecision","number","precision","parseFloat","toFixed","formatDICOMDate","date","strFormat","moment","format","formatDICOMTime","time","Alphabetic","cleaned","join","trim"],"sourceRoot":""}