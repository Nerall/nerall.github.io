{"version":3,"file":"1202.bundle.b462afe6182912a89a7e.js","mappings":";8uLAAA,IAAMA,EAAU,SAAAC,GAAK,OAACC,MAAMC,QAAQF,GAAKA,EAAI,CAACA,EAAzB,ECOfG,EAAoB,SAACC,GACvB,OAAO,SAACC,GACJ,OACIA,EAAYC,wBAAwBC,cAAgBH,CAE5D,CACJ,ECXQI,EAAkB,KAAI,c,0EAYd,SACZC,EACAC,GAEA,IAAIC,EACJ,GAAIF,aAA2BG,YAC3BD,EAAO,IAAIE,KAAK,CAACJ,GAAkB,CAAEK,KAAM,0BACxC,CACH,IAAKL,EAAgBM,MACjB,MAAM,IAAIC,MAAM,sCAGpB,IAAMC,EAAS,KAAOC,KAAKV,EAAcC,GAAiBU,SAC1DR,EAAO,IAAIE,KAAK,CAACI,GAAS,CAAEH,KAAM,qB,CAGtC,IAAMM,EAAOC,SAASC,cAAc,KACpCF,EAAKG,KAAOC,OAAOC,IAAIC,gBAAgBf,GACvCS,EAAKO,SAAWjB,EAChBU,EAAKQ,OACT,E,kBC7B0B,SAAAC,GACtB,OAAO,SAAAxB,GACH,OAAOA,GAAeA,EAAYyB,cAAgBD,CACtD,CACJ,E,YCLQE,EAA0BC,EAAAA,GAA1BD,QAASE,EAAiBD,EAAAA,GAAjBC,aAETC,EAAqBC,EAAAA,GAArBD,iBAEAE,EAAeC,EAAAA,GAAfD,WAEAE,EAAsDP,EAAtDO,yBAA0BC,EAA4BR,EAA5BQ,wBAE1BC,EAAwBC,EAAAA,GAAxBD,oBAEFE,EAAU,CAAEC,uBAAwB,MAAOC,UAAW,UACtDC,EAAe,CAAEF,uBAAwB,MAAOC,UAAW,aAC3DE,EAAmB,CAAEH,uBAAwB,MAAOC,UAAW,UAE/DG,EAAiB,SAACC,EAAOC,EAAMC,GACjC,IAAQ5C,EAA4B0C,EAA5B1C,wBACR,GAAKA,EAAL,CACA,IAAQqC,EAAsCrC,EAAtCqC,uBAAwBC,EAActC,EAAdsC,UAChC,OACKD,GAA0BM,EAAKN,wBAC5BC,GAAaK,EAAKL,WACrBM,GACGP,GAA0BO,EAAQP,wBAClCC,GAAaM,EAAQN,SAPO,CASxC,EAyCC,IAEoBO,EAAiB,oBAAAA,IAAAC,EAAA,KAAAD,EAAA,QAAAE,EAAAF,EAAA,OAAAG,IAAA,0BAAAC,MAClC,SAA+BC,GAC3B,IAAQC,EAAoBD,EAApBC,gBAEFC,EAAqB3D,EAAQ0D,GAC7BE,EAAeD,EAAmBE,KAAK,SAAAZ,GAAK,OAC9CD,EAAeC,EAAON,EAAQ,GAE5BmB,EACFH,EAAmBI,OAAO,SAAAd,GAAK,OAC3BD,EAAeC,EAAOH,EAAcC,E,IACnC,GACHiB,EAAWL,EAAmBE,KAChC,SAAAZ,GAAK,MAAwB,QAApBA,EAAMgB,SAAmB,GAEhCC,EAAclE,EAAQgE,EAASN,iBAAiBG,KAClD,SAAAZ,GAAK,MAAwB,WAApBA,EAAMgB,SAAsB,GAEjCE,EAA0BD,EAAYR,gBAAtCS,sBACAC,EACJD,EADIC,yBAA0BC,EAC9BF,EAD8BE,sBAG5BC,EAAe,CACjBC,eAAgBH,EAChBI,WAAYH,GAAyB,EACrCI,UAAU,EACVC,QAASd,EACH1B,EAAa0B,EAAae,0BAC1BC,EACNC,aAAcf,EAAkBgB,IAAI,SAAAC,GAChC,OAAO7C,EAAa6C,EAAIJ,oB,IAG5BL,EAAaI,UACbJ,EAAaU,YAAcV,EAAaI,QAAQlE,aAEpD,IAAMyE,EACFX,EAAaO,cAAgBP,EAAaO,aAAa,GAM3D,OALII,IACAX,EAAaY,SACRD,EAAY,IAAMA,EAAY,GAAGzE,aAClCyE,EAAYzE,aAEb,CACH8D,aAAAA,EACAV,aAAAA,EACAE,kBAAAA,EACAE,SAAAA,EACAE,YAAAA,EACAC,sBAAAA,EACAC,yBAAAA,EACAC,sBAAAA,EAER,GAAC,CAAAd,IAAA,iBAAAC,MAED,SAAsB2B,EAAWC,EAAkBC,GAI/C,IAAIC,EAAuB,GACrBC,EAAeC,OAAOC,KAAKN,GAAW,GAC5C,IAAKI,EACD,MAAM,IAAItE,MAAM,6BASpB,IAAMyE,EAAsBN,EAAiBO,IACzC,sBACAJ,GAQIK,EAAwCF,EAAxCE,iBAAkBC,EAAsBH,EAAtBG,kBAG1BL,OAAOC,KAAKN,GAAWW,QAAQ,SAAAC,GAC3B,IAAMC,EAAkBZ,EAAiBO,IACrC,kBACAI,GAEEE,EAAcb,EAAiBO,IAAI,cAAeI,GAClDG,EAAWf,EAAUY,GACrBI,EAAYX,OAAOC,KAAKS,GAExB/B,EAAwB,CAC1BiC,sBAAuBJ,EAAgBK,YACvCjC,yBAA0B4B,EAAgBM,gBAI1CjE,EAAWkE,wBAAwBP,EAAgBK,eAEnDlC,EAAsBE,sBAAwB4B,GAIlD,IAAMO,EAAoB,GAE1BL,EAAUL,QAAQ,SAAAW,GACd,IAAMxD,EAvItB,SAA6BwD,EAAUP,EAAU/B,GAC7C,IAAMuC,EAAeR,EAASO,GACxBE,EACFvD,EAAkBwD,sCAAsCH,GAC5D,GACKC,GACAA,EAAahE,MACbgE,EAAahE,KAAKmE,QAClBF,EAJL,CAWA,IAAMG,EAAeJ,EAAahE,KAAKoC,IAAI,SAAAiC,GACvC,OA9BR,SACIA,EACAN,EACAtC,EACAwC,GAEA,IAAMK,EAAOL,EAAUM,iCAAiCF,GAKxD,OAJAC,EAAK7C,sBAAwBA,EAEH,IAAIwC,EAAUO,qBAAqBF,EAGjE,CAkBeG,CACHJ,EACAN,EACAtC,EACAwC,EAER,GAEA,OAAO,IAAInE,EAAwBsE,EAbnC,CAcJ,CA8G8BM,CACVX,EACAP,EACA/B,GAEAlB,GACAuD,EAAkBa,KAAKpE,EAE/B,GAEAqC,EACIA,EAAqBgC,OAAOd,EACpC,GAEA,IAAMpD,EAAoB,IAAIb,EAC1B,CAAEgF,yBAA0BjC,GAC5BD,GAMEmC,EAAkC,IAAIC,WAAW,GACvDD,EAAgC,GAAK,EAErC,IAAME,EAA0B,CAC5BC,iBAAkB/B,EAClBgC,kBAAmB/B,GAKjB7E,EAAQ,CACV6G,2BAA4B,CACxBC,MAAO,CAACN,EAAgCtG,QACxC6G,GAAI,MAIRC,kBAAmB,CACfF,MAAO,CAAC,uBACRC,GAAI,MAERE,uBAAwB,CACpBH,MAAO,CAACrF,EAAoByF,OAC5BH,GAAI,MAERI,0BAA2B,CACvBL,MAAO,CAAC,SACRC,GAAI,OAQZL,EAAwB1G,MAAQA,EAChC0G,EAAwBU,OALT,CACXC,UAAW,MAMf,IAAMC,EAAS,IAAInG,EAAiB,CAACuF,IAE/BpH,EAAc8C,EAAkB9C,YAClCoH,GAQJ,OAJAY,EAAOC,QAAU/C,OAAOgD,OAAOF,EAAOC,QAASjI,GAC/CgI,EAAOC,QAAQvH,MAAQA,EACvBsH,EAAOC,QAAQE,qBAAuB,aAE/BH,CACX,GAEA,CAAA/E,IAAA,oBAAAC,MAOA,SAAyB+E,GAAqB,IAAZG,EAAKC,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,CAAC,EAEvC,GAA2D,SAAvDJ,EAAQK,wBAAwBC,mBAChC,MAAM,IAAI5H,MACN,+DAIR,IAKM6H,EAA4B9I,EAAQuI,EAAQ7E,iBAAiBG,KAC/DzD,EANW,yBAUToG,EAAoBxG,EACtB8I,EAA0BpF,iBAC5BK,OAAO3D,EAXK,sBAcR2I,EAAkB,CAAC,EAEnBC,EACF5F,EAAkB6F,yCAEhBC,EAAwB,GA8C9B,OA5CA1D,OAAOC,KAAKuD,GAAwBlD,QAAQ,SAAAvC,GACxC2F,EAAsB7B,KAAK2B,EAAuBzF,IAClDwF,EAAgBxF,GAAO,EAC3B,GAEAiD,EAAkBV,QAAQ,SAAAqD,GACtB,IAWMC,EAXkCpJ,EACpCmJ,EAAiBzF,iBAIeG,KAC5B,SAAAvD,GAAW,MAhCK,wBAiCZA,EAAYC,wBAAwBC,WACjB,GAGyB6I,UAElD1C,EAAY+B,EAAMY,aAClBZ,EAAMY,aACFH,EACAZ,EACAW,GAEJA,EAAsBrF,KAAK,SAAA0F,GAAE,OACzBA,EAAGC,qCACCJ,EACH,GAGX,GAAIzC,EAAW,CACX,IAAM8C,EACF9C,EAAU+C,mBAAmBP,GAEjCQ,QAAQC,IAAGtC,OAAAA,OAAQX,EAAUF,SAAQ,SACrCkD,QAAQC,IAAIH,GAEZV,EAAgBpC,EAAUF,UAAUY,KAAKoC,EAC7C,CACJ,GAIOV,CACX,GAAC,CAAAxF,IAAA,eAAAC,MAED,SAAoBmD,GAChBvD,EAAkB6F,yCACdtC,EAAUkD,iBACVlD,EACJvD,EAAkBwD,sCACdD,EAAUF,UACVE,EACJvD,EAAkB0G,wBAAwBnD,EAAUF,UAChDE,EAAUkD,eAClB,IAAC,CAnRiC,GAsRtCzG,EAAkB0G,wBAA0B,CAAC,EAC7C1G,EAAkB6F,yCAA2C,CAAC,EAC9D7F,EAAkBwD,sCAAwC,CAAC,EChW3D,MAAe,0BCICmD,EAAiB9H,EAAAA,GAAU+H,OAAnCC,OAEFC,EAAS,SAETD,EAAM,oBAAAA,IAAA5G,EAAA,KAAA4G,EAAA,QAAA3G,EAAA2G,EAAA,OAAA1G,IAAA,qBAAAC,MAER,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAAUE,EAAWiG,EAAXjG,YAG1BmG,EAAKC,EAAAA,EAAA,GACJhG,GAAY,IACfuC,OAAQ7C,EAASuG,sBAAsBC,aACvC/D,SAAUwD,EAAOxD,SACjBgE,QAAS,CACLC,MAAO,CAAC,EACRC,IAAK,CAAC,EACNC,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAOEjH,EAAYkH,YAAW,GAE3B,OANIf,EAAMI,QAAQC,MAAMzK,EAACiL,EAAA,GACrBb,EAAMI,QAAQC,MAAMW,EAACH,EAAA,GACrBb,EAAMI,QAAQE,IAAI1K,EAACiL,EAAA,GACnBb,EAAMI,QAAQE,IAAIU,EAACH,EAAA,GAGhBb,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAQ0D,EAAmC1D,EAAnC0D,QAAS/F,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aAO1B,MAAO,CACHyG,OAPWb,EAAQC,MAQnBa,OAPWd,EAAQE,IAQnBa,SAPazE,EAAKF,OAQlB4E,4BANgC,iCAOhC/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CAjDO,GAoDZoF,EAAOxD,SAAWyD,EAClBD,EAAOJ,gBAAkBK,EACzBD,EAAO/C,qBAAuB6C,EAC9BE,EAAOT,qCAAuC,SAAAkC,GAC1C,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAayD,CACxB,EAEA9G,EAAkB4I,aAAa/B,GCxE/B,IAAkBgC,EAAmBhK,EAAAA,GAAU+H,OAAvCkC,SAEFC,EAAW,oBAAAA,IAAA9I,EAAA,KAAA8I,EAAA,QAAA7I,EAAA6I,EAAA,OAAA5I,IAAA,qBAAAC,MACb,SAA0BC,GAyBtB,IAxBA,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcJ,EAAWiG,EAAXjG,YAAaF,EAAQmG,EAARnG,SAG7BqG,EAAKC,EAAAA,EAAA,GACJhG,GAAY,IACfmC,SAAU0F,EAAY1F,SACtBgE,QAAS,CACL2B,OAAQ,GACRxB,QAAS,CACLyB,QAAQ,EACRxB,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBqB,YAAa,CACTC,KAAMvI,EAAWA,EAASuG,sBAAsBC,aAAe,GAEnEgC,WAAO5H,EACP6H,aAAa,IAETrB,EAAgBlH,EAAhBkH,YACCsB,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EACzCrC,EAAMI,QAAQ2B,OAAO/E,KAAK,CACtBpH,EAAGmL,EAAYsB,GACfrB,EAAGD,EAAYsB,EAAI,KAI3B,OAAOrC,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAQ0D,EAAqD1D,EAArD0D,QAAS/F,EAA4CqC,EAA5CrC,QAASG,EAAmCkC,EAAnClC,aAAY8H,EAAuB5F,EAArBuF,YAAAA,OAAW,IAAAK,EAAG,CAAC,EAACA,EAChDP,EAAW3B,EAAX2B,OACRQ,EAAoCN,EAA5BC,KAAAA,OAAO,IAAHK,EAAG,EAACA,EAAAC,EAAoBP,EAAlBQ,UAKlB,MAAO,CACHV,OAAAA,EACAG,KAAAA,EACAO,eAR0B,IAAHD,EAAG,EAACA,EAS3BpB,4BANA,sCAOA/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CApDY,GAuDjBsH,EAAY1F,SAAW,cACvB0F,EAAYtC,gBAAkB,cAC9BsC,EAAYjF,qBAAuB+E,EACnCE,EAAY3C,qCAAuC,SAAAkC,GAC/C,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAa0F,EAAY1F,QACpC,EAEArD,EAAkB4I,aAAaG,GC1E/B,IAAuBY,EAAwB9K,EAAAA,GAAU+H,OAAjDgD,cAEFC,EAAgB,gBAMhBD,EAAa,oBAAAA,IAAA3J,EAAA,KAAA2J,EAAA,QAAA1J,EAAA0J,EAAA,OAAAzJ,IAAA,qBAAAC,MAEf,SAA0BC,GACtB,IAAQC,EAAoBD,EAApBC,gBAEFE,EAAe5D,EAAQ0D,GAAiBG,KAC1C,SAAAZ,GAAK,MATD,WASKA,EAAM1C,wBAAwBsC,SAAqB,GAG1DiB,EAAoB9D,EAAQ0D,GAAiBK,OAC/C,SAAAd,GAAK,MAZI,WAYAA,EAAM1C,wBAAwBsC,SAA0B,GAG/DqK,EAAmBlN,EAAQ0D,GAAiBG,KAC9C,SAAAZ,GAAK,MAnBC,cAmBGA,EAAM1C,wBAAwBC,WAAyB,GAG9D2M,EAAsBnN,EACxBkN,EAAiBxJ,iBACnBG,KAAK,SAAAZ,GAAK,MAAwB,WAApBA,EAAMgB,S,GAEhBmJ,EAAoBpN,EAAQ0D,GAAiBG,KAC/C,SAAAZ,GAAK,MA1BE,eA0BEA,EAAM1C,wBAAwBC,WAA0B,GAG/D6M,EAAuBrN,EACzBoN,EAAkB1J,iBACpBG,KAAK,SAAAZ,GAAK,MAAwB,WAApBA,EAAMgB,S,GAEdE,EAA0BgJ,EAAoBzJ,gBAA9CS,sBACAC,EACJD,EADIC,yBAA0BC,EAC9BF,EAD8BE,sBAK5BiJ,EAAkBC,OACpBL,EAAiB3C,sBAAsBC,cAGrCgD,EAAmBD,OACrBH,EAAkB7C,sBAAsBC,cAGtCiD,EACCC,KAAKC,IACJR,EAAoB/B,YAAY,GAChC+B,EAAoB/B,YAAY,GAChCiC,EAAqBjC,YAAY,GACjCiC,EAAqBjC,YAAY,IALnCqC,EAOCC,KAAKC,IACJR,EAAoB/B,YAAY,GAChC+B,EAAoB/B,YAAY,GAChCiC,EAAqBjC,YAAY,GACjCiC,EAAqBjC,YAAY,IAsEzC,MAlEc,CACV7G,eAAgBH,EAChBI,WAAYH,GAAyB,EACrCoC,SAAUuG,EAAcvG,SACxB4F,QAAQ,EACR5B,QAAS,CACLC,MAAO,CACHzK,EAAGkN,EAAoB/B,YAAY,GACnCC,EAAG8B,EAAoB/B,YAAY,GACnCL,oBAAoB,EACpBC,qBAAqB,EACrBqB,QAAQ,EACRuB,WAAW,EACXC,MAAO,GAEXlD,IAAK,CACD1K,EAAGkN,EAAoB/B,YAAY,GACnCC,EAAG8B,EAAoB/B,YAAY,GACnCL,oBAAoB,EACpBC,qBAAqB,EACrBqB,QAAQ,EACRuB,WAAW,EACXC,MAAO,GAEXC,mBAAoB,CAChB7N,EAAGoN,EAAqBjC,YAAY,GACpCC,EAAGgC,EAAqBjC,YAAY,GACpCL,oBAAoB,EACpBC,qBAAqB,EACrBqB,QAAQ,EACRuB,WAAW,EACXC,MAAO,GAEXE,iBAAkB,CACd9N,EAAGoN,EAAqBjC,YAAY,GACpCC,EAAGgC,EAAqBjC,YAAY,GACpCL,oBAAoB,EACpBC,qBAAqB,EACrBqB,QAAQ,EACRuB,WAAW,EACXC,MAAO,GAEXjD,QAAS,CACLgD,WAAW,EACX/C,UAAU,EACVwB,QAAQ,EACRvB,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,EAChBhL,EAAGwN,EAAgB,GACnBpC,EAAGoC,EAAgB,KAG3BhB,aAAa,EACbuB,YAAY,EACZV,gBAAAA,EACAE,iBAAAA,EACAS,SAAU,gBACVC,SAAS,EACTxJ,QAASd,EACHA,EAAae,yBACbC,EACNC,aAAcf,EAAkBgB,IAAI,SAAAC,GAAG,OAAIA,EAAIJ,mBAAmB,GAI1E,GAAC,CAAApB,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAAoH,EACIpH,EAAK0D,QADDC,EAAKyD,EAALzD,MAAOC,EAAGwD,EAAHxD,IAAKmD,EAAkBK,EAAlBL,mBAAoBC,EAAgBI,EAAhBJ,iBAEhCP,EACJzG,EADIyG,iBAMR,MAAO,CACHY,SAAU,CACN9C,OAAQZ,EACRa,OAAQZ,GAEZ0D,UAAW,CACP/C,OAAQwC,EACRvC,OAAQwC,GAEZO,eAdAvH,EADsBuG,gBAgBtBiB,gBAAiBf,EACjB/B,4BAbA,wCAcA/G,QAjBAqC,EADuCrC,QAmBvCG,aAlBAkC,EADgDlC,cAmBlB,GAEtC,IAAC,CAvJc,GA0JnBmI,EAAcvG,SAAWwG,EACzBD,EAAcnD,gBAAkBoD,EAChCD,EAAc9F,qBAAuB6F,EACrCC,EAAcxD,qCAAuC,SAAAkC,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAawG,CACxB,EAEA7J,EAAkB4I,aAAagB,GCpL/B,IAAiBwB,EAAkBvM,EAAAA,GAAU+H,OAArCyE,QAEFC,EAAgB,gBAEhBC,EAAa,oBAAAA,IAAAtL,EAAA,KAAAsL,EAAA,QAAArL,EAAAqL,EAAA,OAAApL,IAAA,qBAAAC,MAEf,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAGdoH,EAHmCjB,EAAXjG,YAGxBkH,YAEFwD,EAAY,CACd,CAAE3O,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,IACpC,CAAEnL,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,KAElCyD,EAAY,CACd,CAAE5O,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,IACpC,CAAEnL,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,KAKlC0D,EAAkBpB,KAAKqB,KACzBrB,KAAKsB,IAAIH,EAAU,GAAG5O,EAAI4O,EAAU,GAAG5O,EAAG,GACtCyN,KAAKsB,IAAIH,EAAU,GAAGxD,EAAIwD,EAAU,GAAGxD,EAAG,IAG5C4D,GACEJ,EAAU,GAAG5O,EAAI4O,EAAU,GAAG5O,GAAK6O,EADrCG,GAEEJ,EAAU,GAAGxD,EAAIwD,EAAU,GAAGxD,GAAKyD,EAGrCI,EAAsBJ,EAAkB,EAGxCK,EAAU,CACZlP,EAAG2O,EAAU,GAAG3O,EAAIgP,EAAuBC,EAC3C7D,EAAGuD,EAAU,GAAGvD,EAAI4D,EAAuBC,GAIzCE,EAAU,CACZnP,EAAG2O,EAAU,GAAG3O,EAAIgP,EAAuBC,EAC3C7D,EAAGuD,EAAU,GAAGvD,EAAI4D,EAAuBC,GAmC/C,OAjCW5E,EAAAA,EAAA,GACJhG,GAAY,IACfmC,SAAUkI,EAAclI,SACxB4F,QAAQ,EACRC,YAAa,CACTC,KAAMvI,EAAWA,EAASuG,sBAAsBC,aAAe,GAEnEC,QAAS,CACLE,IAAK,CACD1K,EAAGkP,EAAQlP,EACXoL,EAAG8D,EAAQ9D,EACXuC,WAAW,EACXvB,QAAQ,GAEZgD,gBAAiB,EACjB3E,MAAO,CACHzK,EAAGmP,EAAQnP,EACXoL,EAAG+D,EAAQ/D,EACXuC,WAAW,EACXvB,QAAQ,GAEZzB,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBwB,aAAa,EACbyB,SAAS,GAIjB,GAAC,CAAA3K,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAA4F,EAA6D5F,EAArDuF,YAAAA,OAAW,IAAAK,EAAG,CAAC,EAACA,EAAElC,EAAmC1D,EAAnC0D,QAAS/F,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aACpC6F,EAAeD,EAAfC,MAAOC,EAAQF,EAARE,IACP4B,EAASD,EAATC,KAEF+C,EAAc5B,KAAK6B,IAAI7E,EAAMzK,EAAI0K,EAAI1K,GAAK,EAC1CuP,EAAc9B,KAAK6B,IAAI7E,EAAMW,EAAIV,EAAIU,GAAK,EAE1Ce,EAAS,GAETqD,EAAS,CAAExP,GAAIyK,EAAMzK,EAAI0K,EAAI1K,GAAK,EAAGoL,GAAIX,EAAMW,EAAIV,EAAIU,GAAK,GAE9DiE,EAAcE,GAGdpD,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAIqP,EAAajE,EAAGoE,EAAOpE,IACnDe,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAIqP,EAAajE,EAAGoE,EAAOpE,IAEnDe,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAGoL,EAAGoE,EAAOpE,EAAImE,IACzCpD,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAGoL,EAAGoE,EAAOpE,EAAImE,MAIzCpD,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAGoL,EAAGoE,EAAOpE,EAAImE,IACzCpD,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAGoL,EAAGoE,EAAOpE,EAAImE,IAEzCpD,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAIqP,EAAajE,EAAGoE,EAAOpE,IACnDe,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAOxP,EAAIqP,EAAajE,EAAGoE,EAAOpE,KAMvD,MAAO,CACHkB,KAAAA,EACAH,OAAAA,EACAX,4BALA,wCAMA/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CAtHc,GAyHnB8J,EAAclI,SAAWiI,EACzBC,EAAc9E,gBAAkB6E,EAChCC,EAAczH,qBAAuBsH,EACrCG,EAAcnF,qCAAuC,SAAAkC,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAaiI,CACxB,EAEAtL,EAAkB4I,aAAa2C,GC9I/B,IAAgBe,GAAiBzN,EAAAA,GAAU+H,OAAnC2F,OAEFC,GAAY,YAEZC,GAAS,oBAAAA,IAAAxM,EAAA,KAAAwM,EAAA,QAAAvM,EAAAuM,EAAA,OAAAtM,IAAA,qBAAAC,MAEX,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAGdoH,EAHmCjB,EAAXjG,YAGxBkH,YAEFqE,EAAS,CAAExP,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,IAC7CT,EAAM,CAAE1K,EAAGmL,EAAY,GAAIC,EAAGD,EAAY,IAsChD,OApCWd,EAAAA,EAAA,GACJhG,GAAY,IACfmC,SAAUoJ,EAAUpJ,SACpB4F,QAAQ,EACRC,YAAa,CACTC,KAAMvI,EACAA,EAASuG,sBAAsBC,aAC/B,EAENsF,OAAQ,EACRhD,UAAW,GAEfrC,QAAS,CACLE,IAAGL,EAAAA,EAAA,GACIK,GAAG,IACNiD,WAAW,EACXvB,QAAQ,IAEZgD,gBAAiB,EACjB3E,MAAKJ,EAAAA,EAAA,GACEmF,GAAM,IACT7B,WAAW,EACXvB,QAAQ,IAEZzB,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBwB,aAAa,EACbyB,SAAS,GAIjB,GAEA,CAAA3K,IAAA,mCAAAC,MAMA,SAAwCuD,GACpC,IAAA4F,EAA6D5F,EAArDuF,YAAAA,OAAW,IAAAK,EAAG,CAAC,EAACA,EAAElC,EAAmC1D,EAAnC0D,QAAS/F,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aAC7B4K,EAAgBhF,EAAvBC,MAAeC,EAAQF,EAARE,IACf4B,EAAiBD,EAAjBC,KAAMuD,EAAWxD,EAAXwD,OAERhD,EAAY,EAAIY,KAAKqC,GAAKD,EAC1B1D,EAAS,GAEfA,EAAO/E,KAAKoI,GACZrD,EAAO/E,KAAKsD,GAIZ,MAAO,CACH4B,KAAAA,EACAO,UAAAA,EACAgD,OAAAA,EACA1D,OAAAA,EACAX,4BAPgC,oCAQhC/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CA9EU,GAiFfgL,GAAUpJ,SAAWmJ,GACrBC,GAAUhG,gBAAkB+F,GAC5BC,GAAU3I,qBAAuBwI,GACjCG,GAAUrG,qCAAuC,SAAAkC,GAC7C,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAamJ,EACxB,EAEAxM,EAAkB4I,aAAa6D,ICrG/B,IAAeG,GAAgB/N,EAAAA,GAAU+H,OAAjCiG,MAEFC,GAAiB,gBACjBC,GAAsB,sBAEtBC,GAAa,oBAAAA,IAAA/M,EAAA,KAAA+M,EAAA,QAAA9M,EAAA8M,EAAA,OAAA7M,IAAA,qBAAAC,MACf,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcJ,EAAWiG,EAAXjG,YAGhBmM,EAHyClG,EAAZvG,aAGTe,oBAAoBnE,YAEtC4K,EAAgBlH,EAAhBkH,YAwCR,OAtCWd,EAAAA,EAAA,GACJhG,GAAY,IACfmC,SAAU2J,EAAc3J,SACxB4F,QAAQ,EACR5B,QAAS,CACLC,MAAO,CACHzK,EAAGmL,EAAY,GACfC,EAAGD,EAAY,GACfwC,WAAW,EACXvB,QAAQ,GAIZ1B,IAAK,CACD1K,EAC0B,GAAtBmL,EAAYvE,OACNuE,EAAY,GACZA,EAAY,GAAK,GAC3BC,EAC0B,GAAtBD,EAAYvE,OACNuE,EAAY,GACZA,EAAY,GAAK,GAC3BwC,WAAW,EACXvB,QAAQ,GAEZzB,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBwB,aAAa,EACb4D,KAAAA,EACAnC,SAAS,GAIjB,GAAC,CAAA3K,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAMqF,EAAS,CAACrF,EAAK0D,QAAQC,MAAO3D,EAAK0D,QAAQE,KAE3CjG,EAA0BqC,EAA1BrC,QAEA4L,EAAgC,CAClClE,OAAAA,EACAX,4BAAoE,wCACpE5G,aAL4BkC,EAAjBlC,cAKmB,IAclC,OAVKH,GAAWA,EAAQ7B,YAAcsN,KAClCzL,EAAU,CACN7B,UAAWsN,GACXvN,uBAAwB,OACxBpC,YAAauG,EAAKsJ,OAI1BC,EAA8B5L,QAAUA,EAEjC4L,CACX,IAAC,CAzEc,GA4EnBF,GAAc3J,SAAWyJ,GACzBE,GAAcvG,gBAAkBqG,GAChCE,GAAclJ,qBAAuB8I,GACrCI,GAAc5G,qCAAuC,SAAAkC,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAayJ,EACxB,EAEA9M,EAAkB4I,aAAaoE,ICnG/B,IAAmBG,GAAoBtO,EAAAA,GAAU+H,OAAzCwG,UAEFC,GAAa,YAEbD,GAAS,oBAAAA,IAAAnN,EAAA,KAAAmN,EAAA,QAAAlN,EAAAkN,EAAA,OAAAjN,IAAA,qBAAAC,MAEX,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAAUE,EAAWiG,EAAXjG,YAG1BmG,EAAKC,EAAAA,EAAA,GACJhG,GAAY,IACfoM,OAAQ1M,EAASuG,sBAAsBC,aACvC/D,SAAU+J,EAAU/J,SACpBgE,QAAS,CACLC,MAAO,CAAC,EACRC,IAAK,CAAC,EACNgG,OAAQ,CACJ/C,WAAW,EACX7C,oBAAoB,GAExB6F,KAAM,CACFhD,WAAW,EACX7C,oBAAoB,GAExBH,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAWEjH,EAAYkH,YAAW,GAE3B,OAVIf,EAAMI,QAAQC,MAAMzK,EAACiL,EAAA,GACrBb,EAAMI,QAAQC,MAAMW,EAACH,EAAA,GACrBb,EAAMI,QAAQE,IAAI1K,EAACiL,EAAA,GACnBb,EAAMI,QAAQE,IAAIU,EAACH,EAAA,GACnBb,EAAMI,QAAQkG,OAAO1Q,EAACiL,EAAA,GACtBb,EAAMI,QAAQkG,OAAOtF,EAACH,EAAA,GACtBb,EAAMI,QAAQmG,KAAK3Q,EAACiL,EAAA,GACpBb,EAAMI,QAAQmG,KAAKvF,EAACH,EAAA,GAGjBb,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAQ0D,EAAmC1D,EAAnC0D,QAAS/F,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aAS1B,MAAO,CACHyG,OATWb,EAAQC,MAUnBa,OATWd,EAAQE,IAUnBkG,OATWpG,EAAQkG,OAUnBG,OATWrG,EAAQmG,KAUnBF,OATW3J,EAAK2J,OAUhBjF,4BARgC,oCAShC/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CAjEU,GAoEf2L,GAAU/J,SAAWgK,GACrBD,GAAU3G,gBAAkB4G,GAC5BD,GAAUtJ,qBAAuBqJ,GACjCC,GAAUhH,qCAAuC,SAAAkC,GAC7C,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAagK,EACxB,EAEArN,EAAkB4I,aAAawE,ICxF/B,IAAeO,GAAgB9O,EAAAA,GAAU+H,OAAjCgH,MAEFC,GAAQ,QAERD,GAAK,oBAAAA,IAAA3N,EAAA,KAAA2N,EAAA,QAAA1N,EAAA0N,EAAA,OAAAzN,IAAA,qBAAAC,MAIP,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAAUE,EAAWiG,EAAXjG,YAG1BmG,EAAKC,EAAAA,EAAA,GACJhG,GAAY,IACfoM,OAAQ1M,EAASuG,sBAAsBC,aACvC/D,SAAUuK,EAAMvK,SAChBgE,QAAS,CACLC,MAAO,CAAC,EACRwG,OAAQ,CAAC,EACTvG,IAAK,CAAC,EACNC,QAAS,CACLC,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAWEjH,EAAYkH,YAAW,GAE3B,OAVIf,EAAMI,QAAQC,MAAMzK,EAACiL,EAAA,GACrBb,EAAMI,QAAQC,MAAMW,EAACH,EAAA,GACrBb,EAAMI,QAAQyG,OAAOjR,EAACiL,EAAA,GACtBb,EAAMI,QAAQyG,OAAO7F,EAACH,EAAA,GACtBb,EAAMI,QAAQyG,OAAOjR,EAACiL,EAAA,GACtBb,EAAMI,QAAQyG,OAAO7F,EAACH,EAAA,GACtBb,EAAMI,QAAQE,IAAI1K,EAACiL,EAAA,GACnBb,EAAMI,QAAQE,IAAIU,EAACH,EAAA,GAGhBb,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAQ0D,EAAmC1D,EAAnC0D,QAAS/F,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aAS1B,MAAO,CACHyG,OATWb,EAAQC,MAUnBa,OATWd,EAAQyG,OAUnBL,OATWpG,EAAQyG,OAUnBJ,OATWrG,EAAQE,IAUnB+F,OATW3J,EAAK2J,OAUhBjF,4BARgC,gCAShC/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CA5DM,GA+DXmM,GAAMvK,SAAWwK,GACjBD,GAAMnH,gBAAkBoH,GACxBD,GAAM9J,qBAAuB6J,GAC7BC,GAAMxH,qCAAuC,SAAAkC,GACzC,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAawK,EACxB,EAEA7N,EAAkB4I,aAAagF,ICrF/B,IAAkB/E,GAAmBhK,EAAAA,GAAU+H,OAAvCkC,SAEFiF,GAAY,oBAAAA,IAAA9N,EAAA,KAAA8N,EAAA,QAAA7N,EAAA6N,EAAA,OAAA5N,IAAA,qBAAAC,MACd,SAA0BC,GACtB,IAAA0G,EACI/G,EAAkBgH,wBAAwB3G,GADtCa,EAAY6F,EAAZ7F,aAAcJ,EAAWiG,EAAXjG,YAAaF,EAAQmG,EAARnG,SAG7BqG,EAAKC,EAAAA,EAAA,GACJhG,GAAY,IACfmC,SAAU0K,EAAa1K,SACvBgE,QAAS,CACLC,MAAO,CAAC,EACRC,IAAK,CAAC,EACNC,QAAS,CACLyB,QAAQ,EACRxB,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,GAEpBoE,gBAAiB,GAErB/C,YAAa,CACTC,KAAMvI,EAAWA,EAASuG,sBAAsBC,aAAe,GAEnEgC,WAAO5H,EACP6H,aAAa,IAEOvB,EAAAC,EASpBjH,EAAYkH,YAAW,GAE3B,OARIf,EAAMI,QAAQC,MAAMzK,EAACiL,EAAA,GACrBb,EAAMI,QAAQC,MAAMW,EAACH,EAAA,GACPA,EAAA,GACAA,EAAA,GACdb,EAAMI,QAAQE,IAAI1K,EAACiL,EAAA,GACnBb,EAAMI,QAAQE,IAAIU,EAACH,EAAA,GAGhBb,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,GACpC,IAAQrC,EAAqDqC,EAArDrC,QAASG,EAA4CkC,EAA5ClC,aAAY8H,EAAgC5F,EAA9BuF,YAAAA,OAAW,IAAAK,EAAG,CAAC,EAACA,EAAElC,EAAY1D,EAAZ0D,QACzCC,EAAeD,EAAfC,MAAOC,EAAQF,EAARE,IAYf,MAAO,CACHyB,OAZW,CACX1B,EACA,CAAEzK,EAAGyK,EAAMzK,EAAGoL,EAAGV,EAAIU,GACrBV,EACA,CAAE1K,EAAG0K,EAAI1K,EAAGoL,EAAGX,EAAMW,IASrBkB,KAPwBD,EAApBC,KAQJO,UARwBR,EAAdQ,UASVrB,4BANA,uCAOA/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CA/Da,GAkElBsM,GAAa1K,SAAW,eACxB0K,GAAatH,gBAAkB,eAC/BsH,GAAajK,qBAAuB+E,GACpCkF,GAAa3H,qCAAuC,SAAAkC,GAChD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAiEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA1DC,EAAeF,EAAA,GAAEnF,EAAQmF,EAAA,GAEhC,OAAIE,IAAoBC,GAIjBtF,IAAa0K,GAAa1K,QACrC,EAEArD,EAAkB4I,aAAamF,ICtF/B,IAAAC,GAKInP,EAAAA,GAAUoP,YAJVC,GAA6BF,GAA7BE,8BAC6BC,GAAOH,GAApCI,4BACAC,GAAYL,GAAZK,aACAC,GAAgBN,GAAhBM,iBAGIC,GACJ1P,EAAAA,GADI0P,cAAeC,GACnB3P,EAAAA,GADmB2P,SAAUC,GAC7B5P,EAAAA,GAD6B4P,aAAcpP,GAC3CR,EAAAA,GAD2CQ,oBAGvCJ,GAAeC,EAAAA,GAAfD,WACcyP,GAA2B1P,EAAAA,GAAzC2P,aAEFA,GAAe,CACjBC,qBAsBJ,SACIC,EACAC,GAEF,IADE7M,EAAOsD,UAAA9B,OAAA8B,QAAA/D,IAAA+D,UAAA/D,GAAA+D,UAAG,IAAEwJ,qBAAqB,GAEzBhN,EAAwB+M,EAAxB/M,UAAWiN,EAAaF,EAAbE,SAGbC,EAASJ,EAAO,GAEhBK,EAAO,CACTrS,EAAGoS,EAAOE,QACVlH,EAAGgH,EAAOG,KACVC,EAAGR,EAAOpL,QAOd,GAJAyL,EAAKI,GAAKJ,EAAKrS,EAAIqS,EAAKjH,GAEJsH,GAAaC,EAAKR,GAGlC,MAAM,IAAInR,MAAM,0BAWpB,IARA,IAAM4R,EAAeR,EAAOtM,QAAQ4F,SAAS,UACvCiH,EAgIV,SAA8BX,EAAQY,EAAcxN,GAChD,IAAMyN,EAAW,GAEjB,GAAID,EAAc,CACd,IACME,EADQd,EAAO,GACKvP,KAAKsQ,UAAU9R,OAEnC+R,EAAYpB,GAAaqB,SAASH,GAClCxK,EAAU9F,GAAoB0Q,kBAAkBF,EAAUG,MAEhE7K,EAAQvH,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MAE5DR,EAASzL,KAAKkB,EAClB,MACI,IAAK,IAAImE,EAAI,EAAGA,EAAIuF,EAAOpL,OAAQ6F,IAAK,CACpC,IACMqG,EADQd,EAAOvF,GACKhK,KAAKsQ,UAAU9R,OACnC+R,EAAYpB,GAAaqB,SAASH,GAClCxK,EAAU9F,GAAoB0Q,kBAChCF,EAAUG,MAGd7K,EAAQvH,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MAC5DR,EAASzL,KAAKkB,EAClB,CAGJ,IAAMgL,EAAalR,GAAWmR,mBAAmBV,GAEjD,OAAO,IAAIhB,GAAuB,CAACyB,GAAalO,EACpD,CA9JgBoO,CAAqBxB,EAAQY,EAAcxN,GAEvDqO,EAuEJ,SAAsCvO,EAAW8M,EAAQG,GAIrD,IAHA,IAAMuB,EAAkB,GAClBC,EAA6B,GAE1BlH,EAAI,EAAGA,EAAI0F,EAASvL,OAAQ6F,IAC7B0F,EAAS1F,KACTiH,EAAgBtM,KAAKqF,GACrBkH,EAA2BvM,KAAK,KAIxC,IAAK,IAAIoL,EAAI,EAAGA,EAAIR,EAAOpL,OAAQ4L,IAI/B,IAHA,IACMoB,EAA2B1O,EADjB8M,EAAOQ,GAAG1M,SAGjB2G,EAAI,EAAGA,EAAIiH,EAAgB9M,OAAQ6F,IAAK,CAC7C,IAAMoH,EAASH,EAAgBjH,GAG3BmH,GACAA,EAAyBE,OACzBF,EAAyBE,MAAMrR,MAC/BmR,EAAyBE,MAAMrR,KAAKoR,IACpCD,EAAyBE,MAAMrR,KAAKoR,GAAQE,WAE5CJ,EAA2BlH,GAAGrF,KAAKoL,EAE3C,CAGJ,MAAO,CACHmB,2BAAAA,EACAD,gBAAAA,EAER,CAxGQM,CAA6B9O,EAAW8M,EAAQG,GAD5CwB,EAA0BF,EAA1BE,2BAA4BD,EAAeD,EAAfC,gBAGhCO,EAAiB,EAEZxH,EAAI,EAAGA,EAAIkH,EAA2B/M,OAAQ6F,IACnDwH,GAAkBN,EAA2BlH,GAAG7F,OAGpD+L,EAAIuB,kBAAkBD,GAEtB,IAAK,IAAIxH,EAAI,EAAGA,EAAIiH,EAAgB9M,OAAQ6F,IAAK,CAC7C,IAAM0H,EAAeT,EAAgBjH,GAC/B2H,EAA0BT,EAA2BlH,GAGrD4H,EAAyBD,EAAwBvP,IAAI,SAAAyP,GACvD,OAAOA,EAAU,CACrB,GAEMC,EAAUpC,EAASgC,GAEzBxB,EAAI6B,WACAD,EACAE,GACIN,EACAC,EACAlP,EACA8M,EACAK,GAEJgC,EAER,CAMA,OAJA1B,EAAI+B,mBAEYhD,GAAciB,EAAIrK,QAGtC,EAxFIqM,kBAwNJ,SAA2BC,EAAU9B,EAAa3N,GAC9C,IAAM6N,EAAYpB,GAAaqB,SAASH,GAClCxK,EAAU9F,GAAoB0Q,kBAAkBF,EAAUG,MAChE7K,EAAQvH,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MAC5D,IAAMC,EAAalR,GAAWmR,mBAAmB,CAACjL,IAE5CuM,EAAmB1P,EAAiBO,IACtC,mBACAkP,EAAS,IAGRC,GACDnL,QAAQoL,KAAK,oDAqCjB,IAlCA,IAYMC,EA6QV,SAA8BC,GAC1B,IAAMC,EAAe,GAMrBA,EAAa,GAAKD,EAClBC,EAAa,GAAK3D,GAAQ4D,EAAEF,GAC5BC,EAAa,GAAK3D,GAAQ6D,EAAEH,GAE5B,IAAMI,EAAQ/D,GAA8B2D,EAAKvH,KAAKqC,GAAK,GAS3D,OAPAmF,EAAa,GAAKG,EAClBH,EAAa,GAAK3D,GAAQ4D,EAAEE,GAC5BH,EAAa,GAAK3D,GAAQ6D,EAAEC,GAE5BH,EAAa,GAAK5D,GAA8B2D,EAAKvH,KAAKqC,IAC1DmF,EAAa,GAAK5D,GAA8B2D,EAAK,IAAMvH,KAAKqC,IAEzDmF,CACX,CAlS8BI,CAZMpV,MAAMC,QAAQ2U,EAAiBS,YAAWjO,GAAAA,OAAAkO,EAChEV,EAAiBS,YAAUC,EAAKV,EAAiBW,gBACrD,CACIX,EAAiBS,WAAWtV,EAC5B6U,EAAiBS,WAAWlK,EAC5ByJ,EAAiBS,WAAW9C,EAC5BqC,EAAiBW,cAAcxV,EAC/B6U,EAAiBW,cAAcpK,EAC/ByJ,EAAiBW,cAAchD,IAMnCiD,EACFnC,EAAWmC,+BAETC,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACLjR,EAEJkR,EAAcvC,EAAWwC,QAAUxC,EAAWyC,KAC9CC,EAmVV,SAA4B1C,GACxB,IAAM7Q,EAAO,GAEPwT,EAAkB3C,EAAW4C,gBAEnC,GAAIjW,MAAMC,QAAQ+V,GACd,IAAK,IAAIpC,EAAS,EAAGA,EAASoC,EAAgBrP,OAAQiN,IAClDpR,EAAK2E,KAAK6O,EAAgBpC,SAI9BpR,EAAK2E,KAAK6O,GAGd,MAAO,CACHE,kBACI7C,EAAW8C,yBAAyBzO,kBACxClF,KAAAA,EAER,CAtWwB4T,CAAmB/C,GACjCS,EAkFV,SAAyBT,GACrB,IAAMgD,EAAUhD,EAAWiD,iBAE3B,GAAgB,WAAZD,EACA,OAAO3E,GAAS6E,OAAOlD,EAAWlL,WAGtC,IAAM2L,EAAY,IAAIvM,WAAW8L,EAAWlL,WAEtCsF,EAAM4F,EAAWmD,uBACjBC,OAEF/R,IADAoP,EAAUnQ,KAAK,SAAA0Q,GAAO,OAAgB,IAAZA,GAAiBA,IAAY5G,CAAG,GAG9D,IAAKgJ,EAID,YAHA/M,EAAAA,GAAImL,KACA,wEASR,OAJAnL,EAAAA,GAAImL,KACA,sEAGGf,CACX,CA5GsB4C,CAAgBrD,GAE5BsD,EACFtD,EAAWsD,iCAET1R,EAAY,CAAC,EAEf2R,GAAU,EAELpK,EAAI,EAAGA,EAAImK,EAAiChQ,OAAQ6F,IAAK,CAC9D,IAAMqK,EAA2BF,EAAiCnK,GAE5DsK,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAOHoB,EAAoBC,GALLC,IACjB,IAAI1P,WAAWuM,EAAU9S,OAAQwL,EAAIoJ,EAAaA,GAClD,CAACvC,EAAWyC,KAAMzC,EAAWwC,UAK7BiB,EACAhC,GAGJ,IAAKiC,EAAmB,CACpBtN,QAAQoL,KACJ,gIAEJ+B,GAAU,EACV,KACJ,CAEA,IAAM1C,EACF2C,EAAyBK,8BACpBC,wBAA0B,EAuBnCC,GACInS,EAPYoS,GAbZ7B,EAA+B8B,yBAC/B9B,EAA+B8B,wBAC1BC,oBAGD/B,EAA+B8B,wBAC1BC,oBAAoB/K,GAGzBqK,EAAyBS,wBACpBC,oBAKT5C,EACAzP,GAMAgP,EACA6C,EAER,CAEA,IAAKH,EACD,OAGJ,MAAO,CAAE3R,UAAAA,EAAW8Q,YAAAA,EACxB,GAhPA,SAASvB,GACLN,EACAsD,EACAvS,EACA8M,EACAK,GAMA,IAJA,IAAM0B,EAAY,IAAIvM,WAAW6K,EAAKI,GAAKgF,EAAiB7Q,QAExD8Q,EAAiB,EAEZjL,EAAI,EAAGA,EAAIgL,EAAiB7Q,OAAQ6F,IASzC,IARA,IAKMkL,EAF2BzS,EADjB8M,EAFFyF,EAAiBhL,IAED3G,SAIDgO,MAAMrR,KAAK0R,GAAcJ,UAE7C6D,EAAI,EAAGA,EAAID,EAAe/Q,OAAQgR,IACvC7D,EAAU2D,GAAkBC,EAAeC,GAC3CF,IAIR,OAAO3D,CACX,CAsCA,SAASrB,GAAaC,EAAKR,GAGvB,IAFA,IAAI0F,EAAc,EAETpL,EAAI,EAAGA,EAAI0F,EAASvL,OAAQ6F,IAC7B0F,EAAS1F,IACToL,IAIR,OAAOA,CACX,CAkNA,SAASR,GACLnS,EACAY,EACAqO,EACA2D,GAEK5S,EAAUY,GAIHZ,EAAUY,GAASgO,MAGnB5O,EAAUY,GAASgO,MAAMrR,OACjCyC,EAAUY,GAASgO,MAAMrR,KAAO,KAHhCyC,EAAUY,GAASgO,MAAQ,CAAC,EAC5B5O,EAAUY,GAASgO,MAAMrR,KAAO,KALhCyC,EAAUY,GAAW,CAAC,EACtBZ,EAAUY,GAASgO,MAAQ,CAAC,EAC5B5O,EAAUY,GAASgO,MAAMrR,KAAO,IAQpCyC,EAAUY,GAASgO,MAAMrR,KAAK0R,GAAgB,CAAC,EAE/C,IAAM4D,EAAa7S,EAAUY,GAASgO,MAAMrR,KAAK0R,GAEjD4D,EAAWhE,UAAY,IAAIvM,WAAWsQ,EAAYrV,KAAKmE,QAIvD,IAFA,IAAMoR,EAAkBD,EAAWhE,UAE1B6D,EAAI,EAAGA,EAAII,EAAgBpR,OAAQgR,IACpCE,EAAYrV,KAAKmV,GACjBI,EAAgBJ,GAAK,EAErBI,EAAgBJ,GAAK,CAGjC,CAWA,SAASN,GACLE,EACA5C,EACAzP,GAEA,IAAQhB,EACJqT,EADIrT,yBAA0BC,EAC9BoT,EAD8BpT,sBAGlC,OAAOA,EAqDX,SACIE,EACA0B,EACA4O,EACAzP,GAEA,IAAMW,EAAU8O,EAAShR,KAAK,SAAAkC,GAC1B,IAAMC,EAAkBZ,EAAiBO,IACrC,kBACAI,GAEJ,GAAKC,EAAL,CAIA,IAAMkS,EAAqBC,OAAOpS,EAAQ8F,MAAM,UAAU,IAE1D,OAEI7F,EAAgBM,iBAAmB/B,GACnC2T,IAAuBjS,EAAc,CAPzC,CASJ,GAEA,OAAOF,CACX,CA7EUqS,CACIhU,EACAC,EACAwQ,EACAzP,GAmBd,SACIb,EACAsQ,EACAzP,GAEA,OAAOyP,EAAShR,KAAK,SAAAkC,GACjB,IAAMC,EAAkBZ,EAAiBO,IACrC,kBACAI,GAEJ,GAAKC,EAIL,OAAOA,EAAgBM,iBAAmB/B,CAC9C,EACJ,CAjCU8T,CACIjU,EACAyQ,EACAzP,EAEd,CAyGA,SAAS8R,GAA6Ba,EAAa9C,EAAKC,GACpD,OAAIoD,GAAWrD,EAAKC,EAAa,IAEtB6C,EACAO,GAAWrD,EAAKC,EAAa,IAE7BzD,GAAa2D,EAAE2C,GACfO,GAAWrD,EAAKC,EAAa,IAE7BzD,GAAa0D,EAAE4C,GACfO,GAAWrD,EAAKC,EAAa,IAE7BxD,GAAiBqG,GACjBO,GAAWrD,EAAKC,EAAa,IAE7BzD,GAAa0D,EAAEzD,GAAiBqG,IAChCO,GAAWrD,EAAKC,EAAa,IAE7BzD,GAAa2D,EAAE1D,GAAiBqG,IAChCO,GAAWrD,EAAKC,EAAa,IAE7BxD,GAAiBA,GAAiBqG,IAClCO,GAAWrD,EAAKC,EAAa,IAE7BxD,GACHA,GAAiBA,GAAiBqG,UAHnC,CAMX,CAEA,IC5kBKQ,GD4kBCC,GAAK,KAUX,SAASF,GAAWG,EAAMC,GACtB,OACIhL,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,IAC9B9K,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,IAC9B9K,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,IAC9B9K,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,IAC9B9K,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,IAC9B9K,KAAK6B,IAAIkJ,EAAK,GAAKC,EAAK,IAAMF,EAEtC,EC/lBA,SAAKD,GAID,6EACH,CALD,CAAKA,KAAAA,GAKJ,KAED,OAAeA,G,6CCEfnH,GAMInP,EAAAA,GAAUoP,YALVC,GAA6BF,GAA7BE,8BAC6BC,GAAOH,GAApCI,4BACAC,GAAYL,GAAZK,aACAC,GAAgBN,GAAhBM,iBACAiH,GAAWvH,GAAXuH,YAGI/G,GAAgDgH,EAAAA,GAAhDhH,SAAUC,GAAsC+G,EAAAA,GAAtC/G,aAAcpP,GAAwBmW,EAAAA,GAAxBnW,oBAExBJ,GAAeC,EAAAA,GAAfD,WACcyP,GAA2B1P,EAAAA,GAAzC2P,aAER8G,GAA2B5W,EAAAA,GAAU6W,YAA7BC,GAAMF,GAANE,OAAQC,GAAMH,GAANG,OASVC,GAAqC,CACvC9G,qBAAqB,EACrB+G,WAAW,GAiCf,SAASC,GAAiBC,EAAcC,GAepC,IAfwE,IAAlBC,EAAW3Q,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC/DtD,EAAUG,OAAOgD,OACnB,CAAC,EACDyQ,GACAK,GAIEC,EAAcrZ,MAAMC,QAAQkZ,GAC5BA,EACA,CAACA,GAEHG,EAAiB,EACfC,EAA8B,GAAGC,EAAAA,WAYnC,IALA,IAAMC,EAAaJ,EAAYK,GACvBC,EAA0BF,EAA1BE,YAAaC,EAAaH,EAAbG,SAEflG,EAA6B,GAE1BlH,EAAI,EAAGA,EAAIoN,EAASjT,OAAQ6F,IAC7BoN,EAASpN,KACTkH,EAA2BlH,GAAK,IAIxC,IAFC,IAAAqN,EAAA,SAAAC,GAGG,IAAMC,EAAaJ,EAAYnN,GAE3BmN,EAAYnN,IACmBuN,EAAvBC,mBAEWpU,QAAQ,SAAAsO,GACF,IAAjBA,IACAR,EAA2BQ,GAAc/M,KAAKqF,GAC9C8M,IAER,E,EAXC9M,EAAI,EAAGA,EAAImN,EAAYhT,OAAQ6F,IAAGqN,EAAAC,GAe3CP,EAA4BG,GAAiBhG,C,EA9BzCgG,EAAgB,EACpBA,EAAgBL,EAAY1S,OAC5B+S,IAAeF,IA+BnBN,EAAajF,kBAAkBqF,GAE/B,IACI,IAAII,EAAgB,EACpBA,EAAgBL,EAAY1S,OAC5B+S,IAQA,IANA,IAAMhG,EACF6F,EAA4BG,GAE1BD,EAAaJ,EAAYK,GACvBE,EAAaH,EAAbG,SAGA1F,EAAe,EACnBA,EAAeR,EAA2B/M,OAC1CuN,IACF,CACE,IAAMC,EACFT,EAA2BQ,GAE/B,GAAIC,EAAyB,CAEzB,IAAMC,EAAyBD,EAAwBvP,IACnD,SAAAyP,GACI,OAAOA,EAAU,CACrB,GAEE4F,EAAkBL,EAAS1F,GAC3BgG,EAAYC,GACdV,EACAtF,GAGJ+E,EAAakB,uBACTH,EACAC,EACAhG,EACAE,EAER,CACJ,CAEJ,GAAIjP,EAAQ6T,UAAW,CACnB,IAAMqB,EAAmBxB,GACrBK,EAAa7Q,QAAQF,UACrBmR,EACAJ,EAAa7Q,QAAQyN,KACrBoD,EAAa7Q,QAAQwN,SAMzBqD,EAAaoB,gBAAgB,CACzBC,cAAe,IACfC,WAAY,IACZC,QAAS,IACTnE,iBAAkB,aAClBoE,2BAA4B,cAC5BlE,uBAAwB,QAG5B0C,EAAa7Q,QAAQvH,MAAMgH,kBAAoB,CAC3CF,MAAO,CAAC,uBACRC,GAAI,MAERqR,EAAa7Q,QAAQE,qBAAuB,aAC5C2Q,EAAa7Q,QAAQH,OAAOC,UAAY,KACxC+Q,EAAa7Q,QAAQF,UAAYkS,CACrC,MAEInB,EAAazE,mBAGjB,OAAOyE,CACX,CAEA,SAASiB,GACLV,EACAtF,GAMA,IAJA,IAAQwF,EAAgBF,EAAhBE,YAEFO,EAAY,GAET1N,EAAI,EAAGA,EAAI2H,EAAwBxN,OAAQ6F,IAAK,CACrD,IAAMmO,EAAQxG,EAAwB3H,GAEtC0N,EAAU/S,KAAKwS,EAAYgB,GAAO7G,UACtC,CAEA,OAAOoG,CACX,CA0bA,SAAAU,K,MA7KC,O,EA6KDC,IAAAC,EAjYA,SAAAC,EACIpG,EACA9B,EACA3N,EACAC,GAAO,IAAA6V,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA1I,EAAA1K,EAAAgL,EAAAuB,EAAApP,EAAAkC,EAAAiO,EAAAb,EAAAc,EAAAG,EAAAjC,EAAA4H,EAAArB,EAAAlJ,EAAAwK,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAAzB,IAAA0B,EAAA,SAAAC,GAAA,cAAAA,EAAAC,GAAA,OAgD8D,GAhD9DzB,EASH7V,EANA8V,gBAAAA,OAAkB,IAAHD,GAAQA,EAAAE,EAMvB/V,EALAgW,UAAAA,OAAS,IAAAD,EAAG,KAAIA,EAAAE,EAKhBjW,EAJAkW,sBAAAA,OAAwB9T,IAAH6T,EAAG7T,WAAU6T,EAAAE,EAIlCnW,EAHAoW,iBAAAA,OAAgB,IAAAD,EAAG,MAASA,EAC5BE,EAEArW,EAFAqW,YACAC,EACAtW,EADAsW,aAEE1I,EAAYpB,GAAaqB,SAASH,IAClCxK,EAAU9F,GAAoB0Q,kBAAkBF,EAAUG,OACxDpS,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MACtDC,EAAalR,GAAWmR,mBAAmB,CAACjL,IAE5CuM,EAAmB1P,EAAiBO,IACtC,mBACAkP,EAAS,IAGPnP,EAAsBN,EAAiBO,IACzC,sBACAkP,EAAS,IAGPjN,EAAoBlC,EAAoBG,kBAEzCiP,GACDnL,QAAQoL,KAAK,oDAGXc,EAA0B3V,MAAMC,QAAQ2U,EAAiBS,YAAW,GAAAjO,OAAAkO,EAChEV,EAAiBS,YAAUC,EAAKV,EAAiBW,gBACrD,CACIX,EAAiBS,WAAWtV,EAC5B6U,EAAiBS,WAAWlK,EAC5ByJ,EAAiBS,WAAW9C,EAC5BqC,EAAiBW,cAAcxV,EAC/B6U,EAAiBW,cAAcpK,EAC/ByJ,EAAiBW,cAAchD,GAInCuC,EAAoBM,GAAqBO,GAEzCC,EAAcvC,EAAWwC,QAAUxC,EAAWyC,KAC9CC,EAAcK,GAAmB/C,EAAY3L,GAOzB,wBALA2L,EAAWvS,MAAMgH,kBAAkBF,MAAM,GAKpB,CAAA4U,EAAAC,EAAA,QASzC,GARIpC,EAAmBra,MAAMC,QAAQoT,EAAWlL,WAC5CkL,EAAWlL,UACX,CAACkL,EAAWlL,WAElB2L,EAAYgF,GACRuB,EACAhH,EAAWyC,KACXzC,EAAWwC,SAGe,IAA1BxC,EAAWmH,WAAgB,CAAAgC,EAAAC,EAAA,QAC6B,OAAxDhT,QAAQoL,KAAK,2CAA2C2H,EAAAE,EAAA,UAM5DhB,EAAkB,CAAC5H,GAAW0I,EAAAC,EAAA,eAEsC,GAApEf,EAAkBhF,GAAgBrD,EAAY,CAAEkI,iBAAAA,IAE1B,CAAFiB,EAAAC,EAAA,cACV,IAAI1b,MAAM,kDAAiD,OAInEoQ,EAAcwL,GAChBtJ,EACAyB,EACA,CAACF,EAAiBtC,KAAMsC,EAAiBvC,QAASsC,EAAShO,QAC3DwU,GAMEQ,EAAwBhH,EAASiI,OAAO,SAACC,EAAKhX,GAMhD,OADAgX,EAJ2B3X,EAAiBO,IACxC,qBACAI,GAFIO,gBAIcP,EACfgX,C,EACR,CAAC,GAEAjB,GAAc,EACbX,IACDW,EAAckB,GACVpB,EACArI,EACAsB,EACAG,EACA5P,EACAiW,EACAE,EACAM,IAEPW,EAIOnL,EAAWqL,EAAAC,EACV,WADUH,EACFA,EAOR,kBAPQA,EAOOA,EAKf,YALeA,EAKN,iBAPT,OAHGT,EADAD,EACiBmB,GAEAC,GACpBR,EAAAE,EAAA,kBAIK,IAAI3b,MACN,+FACH,aAEK,IAAIA,MACN,4FACH,OAiC6B,OAxBhC+a,EAAuB,IACR,GAAK,GACpBC,EAAkB,GAElBC,EACFpG,EAAcjB,EAAShO,OAAS0U,EAAsB4B,mBACpDhB,EAAsB,IACR,GAAK,IAAItb,YAAYqb,GAInCE,EAAcvH,EAASiI,OACzB,SAACC,EAAKK,EAAMvP,GAGR,OAFAkP,EAAIM,QAAQD,GAAQvP,EACpBkP,EAAIjD,SAASsD,GAAQhY,EAAiBO,IAAI,WAAYyX,GAC/CL,CACX,EACA,CAAEM,QAAS,CAAC,EAAGvD,SAAU,CAAC,IAOxBuC,EAAuB,IAAIiB,IAAKZ,EAAAC,EAAA,EAEJZ,EAC9BE,EACAD,EACAG,EACAP,EACArI,EACAsB,EACAG,EACA5P,EACAiW,EACAE,EACAc,EACAR,EACAO,EACAV,EACAC,GACH,OAgBE,OAhCGW,EAAmBI,EAAAtH,EAmBnBmH,EAAc,IAAIe,IAExBjB,EAAqBvW,QAAQ,SAACyX,EAAyBnJ,GACnD,IAAAoJ,EAAoCC,GAChCF,EACAhK,GAFImK,EAAIF,EAAJE,KAAMC,EAAIH,EAAJG,KAAMC,EAAIJ,EAAJI,KAAMC,EAAKL,EAALK,MAK1BtB,EAAYuB,IAAI1J,EAAc,CAC1BnU,EAAGyN,KAAKqQ,MAAML,EAAOG,GACrBxS,EAAGqC,KAAKqQ,MAAMJ,EAAOE,GACrBpL,EAAG/E,KAAKqQ,MAAMH,EAAOC,IAE7B,GAAGnB,EAAAE,EAEI,GACHT,oBAAAA,EACAlG,YAAAA,EACAgG,gBAAAA,EACAD,qBAAAA,EACAgC,UAAWzB,EACXD,oBAAAA,IACH,EAAArB,E,GA8KLH,G,4KA7KCA,GAAAmD,MAAA,KAAAtV,UAAA,CAwLD,SAASuV,GACL3K,EACA4K,EACAtJ,EACAzP,EACAiW,EACAQ,GAEA,IAAI9V,OAAUnB,EAEd,IAAK2O,EACD,OAAOxN,EAGX,IACIqY,EAIA7K,EAJA6K,oBACAvH,EAGAtD,EAHAsD,iCACAY,EAEAlE,EAFAkE,oBACApB,EACA9C,EADA8C,yBAGJ,IACKQ,GAC2C,IAA5CA,EAAiChQ,OAEjC,OAAOd,EAGX,IAAMsY,EACFxH,EAAiCsH,GAErC,IAAKE,EACD,OAAOtY,EAGX,IAAIuY,OAA2B1Z,EAC/B,GAAIyZ,EAAwB7G,wBAAyB,CACjD,IAAIA,EACA6G,EAAwB7G,wBACxBtX,MAAMC,QAAQqX,KAEVA,EADmC,IAAnCA,EAAwB3Q,OACE2Q,EAAwB,QAExB5S,GAI9B4S,IACA8G,EACI9G,EAAwBC,oBACxBvX,MAAMC,QAAQme,KAEVA,EADoC,IAApCA,EAAyBzX,OACEyX,EAAyB,QAEzB1Z,G,MAIhC6S,GAAsD,IAA/BA,EAAoB5Q,SAClD8C,QAAQoL,KACJ,0HAEJuJ,EAA2B7G,EAAoB0G,KAG/CG,IACAvY,EAusBR,SACI0R,EACAoE,GAEA,IAAQzX,EACJqT,EADIrT,yBAA0BC,EAC9BoT,EAD8BpT,sBAGlC,OAAOA,EAkFX,SACIE,EACA0B,EACA4V,GAEA,IAAM9V,EAAU8V,EAAsBtX,GAEtC,IAAKwB,EACD,OAGJ,IAAMmS,EAAqBC,OAAOpS,EAAQ8F,MAAM,UAAU,IAE1D,OAAOqM,IAAuBjS,EAAc,EAAIF,OAAUnB,CAC9D,CA/FUwT,CACIhU,EACAC,EACAwX,GAEJA,EAAsBzX,EAChC,CArtBkBma,CACND,EACAzC,SAIQjX,IAAZmB,GAAyBsQ,KAOzBtQ,EAstBR,SACIyY,EACAJ,EACAC,EACAxJ,EACAzP,EACAiW,GAEA,QACoCzW,IAAhC4Z,QACkD5Z,IAAlDyZ,EAAwBI,4BAC6B7Z,IAArDyZ,EAAwBI,sBAAsB,SAEhB7Z,IAD9ByZ,EAAwBI,sBAAsB,GACzCC,qBAEL,OAGJ,IACI,IAAIC,EAAiB,EACrBA,EAAiB9J,EAAShO,SACxB8X,EACJ,CACE,IAAMC,EAAsBxZ,EAAiBO,IACzC,WACAkP,EAAS8J,IAGb,QAC4B/Z,IAAxBga,QAC6Cha,IAA7Cga,EAAoBF,sBACpBE,EAAoBR,sBAAwBA,GAC5CQ,EAAoBhX,oBAChB4W,GAMJK,GACIR,EAAwBI,sBAAsB,GACzCC,qBACLE,EAAoBF,qBACpBrD,GAGJ,OAAOxG,EAAS8J,EAExB,CACJ,CAvwBkBG,EANuB5e,MAAMC,QAAQkW,GACzCA,EAAyB,GACzBA,GAEuBzO,kBAIzBwW,EACAC,EACAxJ,EACAzP,EACAiW,IAIR,OAAOtV,CACX,CAOA,SAASiX,GACLhJ,EACAT,EACAsB,EACAG,EACA5P,EACAiW,EACAE,EACAM,GAEA,IACInG,EAKAnC,EALAmC,+BACAmB,EAIAtD,EAJAsD,iCACAV,EAGA5C,EAHA4C,gBACAH,EAEAzC,EAFAyC,KACAD,EACAxC,EADAwC,QAIJ,GADmBI,EAAgBtP,OAChB,EACf,OAAO,EAkBX,IAfA,IAAM8O,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACLjR,EACJkR,EAAcC,EAAUC,EACxB+I,EAAYlI,EAAiChQ,OAQ/CmY,EAAuB,IAAI1B,IAAM2B,EAAAA,WAGjC,QAAqBra,IADAsa,GAAgB3L,EAAY4K,GAM3C,OAJFxU,QAAQoL,KACJ,0DACIoJ,EACA,0BACN,EAIN,IAAMpY,EAAUmY,GACZ3K,EACA4K,EACAtJ,EACAzP,EACAiW,EACAQ,GAGJ,IAAK9V,EAKC,OAJF4D,QAAQoL,KACJ,oDACIoJ,EACA,KACN,EAIN,IAAMgB,EAAetK,EAASuK,UAAU,SAAA7K,GAAO,OAAIA,IAAYxO,C,GAE/D,GAAIiZ,EAAqBK,IAAIF,GAAe,CACxC,IAAIG,EAAeN,EAAqBrZ,IAAIwZ,GACvCG,EAAa3T,SAASwS,KACvBmB,EAAajY,KAAK8W,GAClBa,EAAqBlB,IAAIqB,EAAcG,GAE/C,MACIN,EAAqBlB,IAAIqB,EAAc,CAAChB,G,EAtCvCA,EAAe,EAAGA,EAAeY,IAAaZ,EAAYc,IAwClE,IAEkDM,EAFlDC,EAAAC,EAEoBT,EAAqBU,WAAS,IAAnD,IAAAF,EAAAG,MAAAJ,EAAAC,EAAA7C,KAAAiD,MAGI,IAHiD,IAAzCC,EAAyC1U,EAAAoU,EAAA/b,MAAA,GAArC,GACRsc,EAAc,IAAIvE,EAAsBzF,GAAaiK,KAAK,GAErDrT,EAAI,EAAGA,EAAImT,EAAKhZ,SAAU6F,EAAG,CAClC,IAAMyR,EAAe0B,EAAKnT,GAEpBqK,EACFF,EAAiCsH,GAE/BnH,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAEHmK,EAAOC,GACTjM,EACAmK,EAAerI,EACfA,GAKEmB,EAAoBC,GAFLC,IAAQ6I,EAAM,CAAChK,EAAMD,IAItCiB,EACAhC,EACAqG,GAGJ,GAAKpE,GAQL,IADA,IAAMvU,EAAOuU,EAAkBvU,KACtBwd,EAAI,EAAGC,EAAMzd,EAAKmE,OAAQqZ,EAAIC,IAAOD,EAC1C,GAAgB,IAAZxd,EAAKwd,KACLJ,EAAYI,KACRJ,EAAYI,GAAK,GACjB,OAAO,OAXfvW,QAAQoL,KACJ,8HAcZ,CACH,OAAAqL,GAAAZ,EAAAa,EAAAD,EAAA,SAAAZ,EAAAc,GAAA,CAED,OAAO,CACX,CAEA,SAASrD,GACLhB,EACAD,EACAG,EACAnI,EACAT,EACAsB,EACAG,EACA5P,EACAiW,EACAE,EACAc,EACAR,GAqCA,IAnCA,IACInG,EAIAnC,EAJAmC,+BACAmB,EAGAtD,EAHAsD,iCACAb,EAEAzC,EAFAyC,KACAD,EACAxC,EADAwC,QAGEJ,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACLjR,EACJkR,EAAcC,EAAUC,EACxBkG,EACFpG,EAAcjB,EAAShO,OAAS0U,EAAsB4B,kBAEtDoD,EAAI,EAGJvF,EAAI,EAGJwF,EAAarE,EAAoBnB,GAAGyF,MAAM,GAG1CC,EAAsBC,IAAU3E,EAAqBhB,IASrD4F,EAAerN,EAAW4C,gBAAgBtP,OAEtCga,EAAwB,EAC5BA,GAAyBD,IACvBC,EACJ,CACE,IADF,IAAAC,EAAA,SAAAC,GAMM,IAAMhK,EACFF,EAAgCkK,GAE9B3M,EAAe8K,GAAgB3L,EAAUwN,GAC/C,QAAqBnc,IAAjBwP,EACA,MAAM,IAAInT,MACN,wEAIR,GAAImT,IAAiByM,EAAuB,OAAAnU,EAAAqU,EAAA,EAI5C,IAAM/J,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAKHmK,EAAOC,GACTjM,EACA+M,EAAIjL,EACJA,GAKEmB,EAAoBC,GAFLC,IAAQ6I,EAAM,CAAChK,EAAMD,IAItCiB,EACAhC,EACAqG,GAGJ,IAAKpE,EACD,MAAM,IAAIhW,MACN,yIAKR,IAAM8E,EAAUmY,GACZ3K,EAAUwN,EAEVlM,EACAzP,EACAiW,EACAQ,GAGJ,IAAK9V,EAKC,OAJF4D,QAAQoL,KACJ,oDAAmDgM,EAE/C,KACNrU,EAAAqU,EAAA,EAIN,IAAMnC,EAAsBxZ,EAAiBO,IACzC,WACAI,GAEJ,GACIiQ,IAAS4I,EAAoB5I,MAC7BD,IAAY6I,EAAoB7I,QAEhC,MAAM,IAAI9U,MACN,uLAuBR,IAjBA,IAAMke,EAAetK,EAASuK,UAC1B,SAAA7K,GAAO,OAAIA,IAAYxO,CAAO,GAE5Bib,EACFlL,EACAqJ,EACA5D,EAAsB4B,kBAEpB8D,EAAiB,IAAI1F,EACvBiF,EACAQ,EACAlL,GAGEpT,EAAOuU,EAAkBvU,KAE3Bwe,GAAiB,EACZhB,EAAI,EAAGC,EAAMlJ,EAAkBvU,KAAKmE,OAAQqZ,EAAIC,IAAOD,EAC5D,GAAIxd,EAAKwd,GAAI,CACT,GAA0B,IAAtBe,EAAef,GAAU,GACzBlF,GACSuF,IACLpE,EAAoBnB,GAAK,IAAIna,YACzBqb,GAEJF,EAAqBhB,GAAK,GAC1BuF,KAEJC,EAAarE,EAAoBnB,GAAGyF,MAAM,GAC1CC,EAAsBC,IAClB3E,EAAqBhB,IAGzB+F,EAAI,EACJ,KACJ,CACIE,EAAef,GAAK9L,EACpB8M,GAAiB,CAEzB,CAGAA,IACKR,EAAoBvB,KACrBuB,EAAoBvB,GAAgB,IAGxCuB,EAAoBvB,GAAc9X,KAAK+M,GAElC6H,EAAgBkD,KACjBlD,EAAgBkD,GAAgB,IAGpClD,EAAgBkD,GAAc9X,KAAK+M,IACtC1H,EAAAqU,C,EAvIGrU,EAAI,EAAGqS,EAAYlI,EAAiChQ,OACxD6F,EAAIqS,IACFrS,EAACoU,EAAApU,GAwIPyP,EAAoBnB,GAAKwF,EAAWC,MAAM,GAC1CzE,EAAqBhB,GAAK2F,IAAUD,GAIpCF,EAAarE,EADbnB,EAAI,GACgCyF,MAAM,GAC1CC,EAAsBC,IAAU3E,EAAqBhB,GACzD,CACJ,CAEA,IAAMkE,GAAkB,SAAC3L,EAAYsH,GACjC,IAAQhE,EACJtD,EADIsD,iCAAkCnB,EACtCnC,EADsCmC,+BAEpCqB,EAA2BF,EAAiCgE,GAClE,OAAO9D,GACHA,EAAyBK,8BACvBL,EAAyBK,8BACpBC,wBACL3B,EAA+B0B,8BAC/B1B,EAA+B0B,8BAC1BC,6BACLzS,CACV,EAEA,SAASsY,GACLjB,EACAD,EACAG,EACAnI,EACAT,EACAsB,EACAG,EACA5P,EACAiW,EACAE,EACAc,EACAR,EACAO,EACAV,EACAC,GAEA,IACIjG,EAIAnC,EAJAmC,+BACAmB,EAGAtD,EAHAsD,iCACAb,EAEAzC,EAFAyC,KACAD,EACAxC,EADAwC,QAGEJ,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACLjR,EACJkR,EAAcC,EAAUC,EAE1BtJ,EAAI,EACFqS,EAAYlI,EAAiChQ,OAC7Csa,EAAYzT,KAAK0T,KAAKrC,EAAY,IAElCsC,EAAqB1F,GAAgBD,EAEvCI,GAAc,EAIlB,OAAO,IAAIwF,QAAQ,SAAAC,IACf,SAASC,IAEL,IAAK,IAAI7W,EAAM+C,KAAK+T,IAAI/U,EAAIyU,EAAWpC,GAAYrS,EAAI/B,IAAO+B,EAAG,CAC7D,IAAMqK,EACFF,EAAiCnK,GAE/BsK,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAEHmK,EAAOC,GACTjM,EACAtH,EAAIoJ,EACJA,GAKEmB,EAAoBC,GAFLC,IAAQ6I,EAAM,CAAChK,EAAMD,IAItCiB,EACAhC,EACAqG,GAGJ,IAAKpE,EACD,MAAM,IAAIhW,MACN,yIAKR,IAAMmT,EAAe8K,GAAgB3L,EAAY7G,GAEjD,QAAqB9H,IAAjBwP,EACA,MAAM,IAAInT,MACN,wEAIHob,EAAqBgD,IAAIjL,IAC1BiI,EAAqByB,IAAI1J,EAAc,CAAC,GAG5C,IAAMrO,EAAUmY,GACZ3K,EACA7G,EACAmI,EACAzP,EACAiW,EACAQ,GAGJ,GAAK9V,EAAL,CASA,IAAM6Y,EAAsBxC,EAAYtC,SAAS/T,GACjD,GACIiQ,IAAS4I,EAAoB5I,MAC7BD,IAAY6I,EAAoB7I,QAEhC,MAAM,IAAI9U,MACN,uLAsBR,IAhBA,IAAMke,EAAe/C,EAAYiB,QAAQtX,GAEnCib,EACFlL,EACAqJ,EACA5D,EAAsB4B,kBAEpB8D,EAAiB,IAAI1F,EACvBY,EAAoB,GACpB6E,EACAlL,GAGEpT,EAAOuU,EAAkBvU,KAEzBgf,EAAa,GAEXxB,EAAI,EAAGC,EAAMlJ,EAAkBvU,KAAKmE,OACxCqZ,EAAIC,IACFD,EAEF,GAAIxd,EAAKwd,GAAI,CACT,IAAK,IAAIjgB,EAAIigB,EAAGjgB,EAAIkgB,IAAOlgB,EACnByC,EAAKzC,KACA6b,GAAqC,IAAtBmF,EAAehhB,KAC/B6b,GAAc,GAElBmF,EAAehhB,GAAKmU,EACpBsN,EAAWra,KAAKpH,IAInBgc,EAAgBkD,KACjBlD,EAAgBkD,GAAgB,IAGpClD,EAAgBkD,GAAc9X,KAAK+M,GAEnC,KACJ,CAGJ,IAAMuN,EACFtF,EAAqB1W,IAAIyO,GAC7BuN,EAAmBxC,GAAgBuC,EACnCrF,EAAqByB,IAAI1J,EAAcuN,EA3DvC,MANIhY,QAAQoL,KACJ,oDACIrI,EACA,IA+DhB,CAGA,GAAI2U,EAAoB,CACpB,IAAMO,EAAkBlU,KAAKmU,MAAOnV,EAAIqS,EAAa,KACrDpD,EAAaD,EAAanD,GAAOuJ,2BAA4B,CACzDF,gBAAAA,GAER,CAGIlV,EAAIqS,EACJgD,WAAWP,EAAiB,GAG5BD,EAAQzF,EAEhB,CAEA0F,EACJ,EACJ,CAEA,SAAS3E,GACLtJ,EACAyB,EACAgN,EACA3G,GAEA,IAAQ3F,EACJnC,EADImC,+BAAgCmB,EACpCtD,EADoCsD,iCAGlClB,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACLjR,EAGJmS,EAA2BF,EAAiC,GAE5D5B,EACFU,GACAoB,EAAyBnB,yBACpBC,wBAMT,OAJgBb,EAAkBiN,KAAK,SAAAC,GAAS,OAC5CrD,GAAc5J,EAAKiN,EAAW7G,EAAU,GAIjC,SAwBf,SAA8B5C,EAAMC,EAAM2C,GACtC,IAAM8G,EAAsBzU,KAAK6B,IAC7BkJ,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,IAErD0J,EAAmB1U,KAAK6B,IAC1BkJ,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,IAG3D,OACKyJ,EAAsB9G,GACnB3N,KAAK6B,IAAI4S,EAAsB,GAAK9G,KACvC+G,EAAmB/G,GAChB3N,KAAK6B,IAAI6S,EAAmB,GAAK/G,EAE7C,CAlCQgH,CAAqBpN,EAAKD,EAAkB,GAAIqG,IAChD2G,EAAqBrW,SAAS4H,EAAWyC,OACzCgM,EAAqBrW,SAAS4H,EAAWwC,SAGlC,gBAGJ,SACX,CAkCA,SAASa,GAAgBrD,EAAYlO,GACjC,IAEI3C,EAFE6T,EAAUhD,EAAWiD,iBAa3B,QAJa5R,KALTlC,EADAxC,MAAMC,QAAQoT,EAAWlL,WAClBkL,EAAWlL,UAAU,GAErBkL,EAAWlL,YAIlBuB,EAAAA,GAAI0Y,MAAM,6CAGE,WAAZ/L,EAIA,OAsBR,SAA2B7T,EAAM+Y,GAO7B,IANA,IAAI8G,EAAW,IAAI9a,WAAW/E,GAC1B8f,EAAS,GAETC,EAAqC,EAAnBhH,EAClBiH,EAAiBhV,KAAK0T,KAAwB,EAAlBmB,EAAS1b,OAAc4b,GAE9C/V,EAAI,EAAGA,EAAIgW,EAAgBhW,IAAK,CACrC,IAAIiW,EAAWjW,EAAI+V,EACfG,EAASlV,KAAK+T,IAAIkB,EAAWF,EAAmC,EAAlBF,EAAS1b,QAEvDgc,EAAYnV,KAAKqQ,MAAM4E,EAAW,GAClCG,EAAUpV,KAAK0T,KAAKwB,EAAS,GAE7BG,EAAQR,EAAS9B,MAAMoC,EAAWC,GAClCE,EAAgBpR,GAAS6E,OAAOsM,GAEpCP,EAAOnb,KAAK2b,EAChB,CAEA,OAAOR,CACX,CA3CeS,CAAkBvgB,EAAM2C,EAAQoW,kBAG3C,IAAMzH,EAAY,IAAIvM,WAAW/E,GAE3BiL,EAAM4F,EAAWmD,uBAKvB,YAFI9R,IADAoP,EAAUnQ,KAAK,SAAA0Q,GAAO,OAAgB,IAAZA,GAAiBA,IAAY5G,CAAG,IAQ9D/D,EAAAA,GAAImL,KACA,sEAGGf,QATP,CAUJ,CAgJA,SAASsB,GAAqBL,GAC1B,IAAMC,EAAe,GAMrBA,EAAa,GAAKD,EAClBC,EAAa,GAAK3D,GAAQ4D,EAAEF,GAC5BC,EAAa,GAAK3D,GAAQ6D,EAAEH,GAE5B,IAAMI,EAAQ/D,GAA8B2D,EAAKvH,KAAKqC,GAAK,GAS3D,OAPAmF,EAAa,GAAKG,EAClBH,EAAa,GAAK3D,GAAQ4D,EAAEE,GAC5BH,EAAa,GAAK3D,GAAQ6D,EAAEC,GAE5BH,EAAa,GAAK5D,GAA8B2D,EAAKvH,KAAKqC,IAC1DmF,EAAa,GAAK5D,GAA8B2D,EAAK,IAAMvH,KAAKqC,IAEzDmF,CACX,CAWA,SAASgC,GACLa,EACA9C,EACAC,EACAmG,GAEA,OAAIwD,GAAc5J,EAAKC,EAAa,GAAImG,GAC7BtD,EACA8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC5J,GAAa2D,EAAE2C,GACf8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC5J,GAAa0D,EAAE4C,GACf8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC3J,GAAiBqG,GACjB8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC3J,GAAiBD,GAAa0D,EAAE4C,IAChC8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC3J,GAAiBD,GAAa2D,EAAE2C,IAChC8G,GAAc5J,EAAKC,EAAa,GAAImG,GAGpC3J,GAAiBA,GAAiBqG,IAClC8G,GAAc5J,EAAKC,EAAa,GAAImG,GAIpC3J,GACHA,GAAiBA,GAAiBqG,UALnC,CAQX,CAWA,SAAS8G,GAAcqE,EAAQC,EAAQ9H,GACnC,GAAI6H,EAAOrc,QAAUsc,EAAOtc,OACxB,OAAO,EAGX,IAAK,IAAI6F,EAAI,EAAGA,EAAIwW,EAAOrc,SAAU6F,EACjC,IAAKiM,GAAYuK,EAAOxW,GAAIyW,EAAOzW,GAAI2O,GACnC,OAAO,EAIf,OAAO,CACX,CAEA,SAAS/E,GAAmB/C,EAAY6C,GACpC,IAAMF,EAAkB3C,EAAW4C,gBAUnC,MAAO,CACHC,kBAAAA,EACA1T,KATAxC,MAAMC,QAAQ+V,GACP,MAACtR,GAAS0C,OAAAkO,EAAKU,IAGf,MAACtR,EAAWsR,GAO3B,CAWA,SAAS+J,GAAuBuC,EAAQY,EAAQvc,GAC5C,IAAMwc,EAqCV,SAAoCb,EAAQY,EAAQvc,GAChD,IAAIyc,EAAad,EAAO1F,OAAO,SAACyG,EAAOR,GAAK,OAAKQ,EAAQR,EAAMlc,MAAM,EAAE,GAEvE,GAAIuc,EAAS,GAAKA,EAASvc,EAASyc,EAChC,MAAM,IAAIriB,MAAM,mCAGpB,IAAIuiB,EAAkB,EAClBC,EAAqBL,EAEzB,KAAOK,GAAsBjB,EAAOgB,GAAiB3c,QACjD4c,GAAsBjB,EAAOgB,GAAiB3c,OAC9C2c,IAGJ,IAAIE,EAAgBF,EAChBG,EAAmBF,EAAqB5c,EAE5C,KAAO8c,EAAmBnB,EAAOkB,GAAe7c,QAC5C8c,GAAoBnB,EAAOkB,GAAe7c,OAC1C6c,IAGJ,MAAO,CACHhZ,MAAO,CAAEkZ,WAAYJ,EAAiBJ,OAAQK,GAC9C9Y,IAAK,CAAEiZ,WAAYF,EAAeN,OAAQO,GAElD,CAhEoBE,CAA2BrB,EAAQY,EAAQvc,GAG3D,GAAIwc,EAAQ3Y,MAAMkZ,aAAeP,EAAQ1Y,IAAIiZ,WACzC,OAAO,IAAInc,WACP+a,EAAOa,EAAQ3Y,MAAMkZ,YAAY1iB,OACjCmiB,EAAQ3Y,MAAM0Y,OACdvc,GAOJ,IAHA,IAAIid,EAAS,IAAIrc,WAAWZ,GACxBkd,EAAe,EAGXrX,EAAI2W,EAAQ3Y,MAAMkZ,WACtBlX,GAAK2W,EAAQ1Y,IAAIiZ,WACjBlX,IACF,CACE,IAAIhC,EACAgC,IAAM2W,EAAQ3Y,MAAMkZ,WAAaP,EAAQ3Y,MAAM0Y,OAAS,EACxDzY,EACA+B,IAAM2W,EAAQ1Y,IAAIiZ,WACZP,EAAQ1Y,IAAIyY,OACZZ,EAAO9V,GAAG7F,OAEpBid,EAAOhG,IACH,IAAIrW,WAAW+a,EAAO9V,GAAGxL,OAAQwJ,EAAOC,EAAMD,GAC9CqZ,GAEJA,GAAgBpZ,EAAMD,CAC1B,CAEA,OAAOoZ,CAEf,CA+BA,SAASrG,GAAkBF,EAAyBhK,GAMhD,IALA,IAAImK,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAQ,EAEZmG,EAAAC,EAAAA,EAA4Cze,OAAOka,QAC/CnC,GACHyG,EAAAC,EAAApd,OAAAmd,IAAE,CAFE,IAAAE,EAAA/Y,EAAA8Y,EAAAD,GAAA,GAAO7E,EAAY+E,EAAA,GAAEC,EAAaD,EAAA,GAG7BzR,EAAI0F,OAAOgH,GAEjB,GAAKgF,GAA0C,IAAzBA,EAActd,OAApC,CAEC,IAEsCud,EAFtCC,EAAA5E,EAEyB0E,GAAa,IAAvC,IAAAE,EAAA1E,MAAAyE,EAAAC,EAAA1H,KAAAiD,MAAyC,KAA9B0E,EAAWF,EAAA5gB,MACZ6H,EAAIqC,KAAKqQ,MAAMuG,EAAc/Q,EAAWyC,MAG9C0H,GAFU4G,EAAc/Q,EAAWyC,KAGnC2H,GAAQtS,EACRuS,GAAQnL,EAERoL,GACJ,CAAC,OAAAuC,GAAAiE,EAAAhE,EAAAD,EAAA,SAAAiE,EAAA/D,GAAA,CAXD,CAYJ,CAEA,MAAO,CAAE5C,KAAAA,EAAMC,KAAAA,EAAMC,KAAAA,EAAMC,MAAAA,EAC/B,CAEA,IAAM9L,GAAe,CACjBC,qBAjsDJ,SAA8BC,EAAQoH,GAAoC,IAAlBC,EAAW3Q,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC7DkK,EAAeZ,EAAO,GAAGlM,QAAQ4F,SAAS,UAOhD,OAAOwN,GAmKX,SAA8BlH,EAAQY,EAAcxN,GAChD,IAAMyN,EAAW,GAEjB,GAAID,EAAc,CACd,IACME,EADQd,EAAO,GACKvP,KAAKsQ,UAAU9R,OAEnC+R,EAAYpB,GAAaqB,SAASH,GAClCxK,EAAU9F,GAAoB0Q,kBAAkBF,EAAUG,MAEhE7K,EAAQvH,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MAC5D/K,EAAQE,qBAAuB,aAC/BqK,EAASzL,KAAKkB,EAClB,MACI,IAAK,IAAImE,EAAI,EAAGA,EAAIuF,EAAOpL,OAAQ6F,IAAK,CACpC,IACMqG,EADQd,EAAOvF,GACKhK,KAAKsQ,UAAU9R,OACnC+R,EAAYpB,GAAaqB,SAASH,GAClCxK,EAAU9F,GAAoB0Q,kBAChCF,EAAUG,MAGd7K,EAAQvH,MAAQyB,GAAoB4Q,cAAcJ,EAAUK,MAC5D/K,EAAQE,qBAAuB,aAC/BqK,EAASzL,KAAKkB,EAClB,CAGJ,IAAMgL,EAAalR,GAAWmR,mBAAmBV,GAEjD,OAAO,IAAIhB,GAAuB,CAACyB,GAAalO,EACpD,CAxMyBoO,CACjBxB,EACAY,EACAyG,GAGkCD,EAAkBC,EAC5D,EAyrDI1E,kBAt/CJ,SAegC2P,EAAAC,EAAAC,EAAAC,GAAA,OAAA5J,GAAAmD,MAAC,KAADtV,UAAA,EAw+C5BwQ,iBAAAA,ICtuDJ,IAAMwL,GAAgB,CAClB1a,OAAMA,EACNkC,YAAW,EACXa,cAAaA,EACb2B,cAAa,EACbkB,UAAS,GACTO,cAAaA,GACbhN,kBAAiBA,EACjBoN,UAASA,GACTQ,MAAKA,GACLG,aAAY,IAGVyT,GAAiB,CACnB7S,aCzBiB,CACjBC,qBAgBJ,SACIC,EACA4S,GAGF,IAFExf,EAAOsD,UAAA9B,OAAA8B,QAAA/D,IAAA+D,UAAA/D,GAAA+D,UAAG,IAAEwJ,qBAAqB,GACjC2S,EAAuBnc,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5Bmc,EACA,OAAOC,GAAgB/S,qBACnBC,EACA4S,EACAxf,GAIR,GAAgC,IAA5Byf,EACA,OAAOE,GAAgBhT,qBACnBC,EACA4S,EACAxf,GAIRsE,QAAQoL,KAAK,4DAADzN,OACoDwd,EAAuB,cAE3F,EAxCIlQ,kBAwDJ,SACIC,EACA9B,EACA3N,GAIF,IAHE+V,EAAexS,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,IAAAA,UAAA,GACf0S,EAAS1S,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,KACZmc,EAAuBnc,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5Bmc,EACA,OAAOC,GAAgBnQ,kBACnBC,EACA9B,EACA3N,EACA+V,EACAE,GAIR,GAAgC,IAA5ByJ,EACA,OAAOE,GAAgBpQ,kBACnBC,EACA9B,EACA3N,GAIRuE,QAAQoL,KAAK,yDAADzN,OACiDwd,EAAuB,cAExF,EApFI3L,iBA8FJ,SACIC,EACAC,GAGF,IAFEhU,EAAOsD,UAAA9B,OAAA8B,QAAA/D,IAAA+D,UAAA/D,GAAA+D,UAAG,IAAEwJ,qBAAqB,GACjC2S,EAAuBnc,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5Bmc,EACA,OAAOC,GAAgB5L,iBACnBC,EACAC,EACAhU,GAIRsE,QAAQoL,KAAK,4DAADzN,OACoDwd,EAAuB,cAE3F,ICtFWG,GAAW,WAQlB,OAPAA,GAAWzf,OAAOgD,QAAU,SAAkB0c,GAC1C,IAAK,IAAIvF,EAAGjT,EAAI,EAAGiQ,EAAIhU,UAAU9B,OAAQ6F,EAAIiQ,EAAGjQ,IAE5C,IAAK,IAAImL,KADT8H,EAAIhX,UAAU+D,GACOlH,OAAO2f,UAAUC,eAAeC,KAAK1F,EAAG9H,KAAIqN,EAAErN,GAAK8H,EAAE9H,IAE9E,OAAOqN,C,EAEJD,GAAShH,MAAMqH,KAAM3c,UAChC,EA6KO,SAAS4c,GAAcC,EAAIrkB,EAAMskB,GACpC,GAAIA,GAA6B,IAArB9c,UAAU9B,OAAc,IAAK,IAA4B6e,EAAxBhZ,EAAI,EAAGiZ,EAAIxkB,EAAK0F,OAAY6F,EAAIiZ,EAAGjZ,KACxEgZ,GAAQhZ,KAAKvL,IACRukB,IAAIA,EAAKxlB,MAAMilB,UAAU1E,MAAM4E,KAAKlkB,EAAM,EAAGuL,IAClDgZ,EAAGhZ,GAAKvL,EAAKuL,IAGrB,OAAO8Y,EAAGle,OAAOoe,GAAMxlB,MAAMilB,UAAU1E,MAAM4E,KAAKlkB,GACtD,CA2GkD,mBAApBykB,iBAAiCA,gBCxU/D,OAAe,4BCQTC,GAAe,CACjBjjB,uBAH2B,gBAI3BkjB,WAAY,CACR3V,oBARoB,wBCGpBnO,GAA0B,KAAS,QAA1BE,GAAiB,KAAS,aAEnCC,GAAqB,KAAW,iBAEhCE,GAAe,KAAW,WAE1BE,GAAsDP,GAAO,yBAAnCQ,GAA4BR,GAAO,wBAE7DS,GAAwB,KAAI,oBAE9BE,GAAU,CAAEC,uBAAwB,MAAOC,UAAW,UACtDC,GAAe,CAAEF,uBAAwB,MAAOC,UAAW,aAC3DE,GAAmB,CAAEH,uBAAwB,MAAOC,UAAW,UAE/DG,GAAiB,SAACC,EAAOC,EAAMC,GACzB,IAAA5C,EAA4B0C,EAAK,wBACzC,GAAK1C,EAAL,CACQ,IAAAqC,EAAsCrC,EAAuB,uBAArCsC,EAActC,EAAuB,UACrE,OACKqC,GAA0BM,EAAKN,wBAC5BC,GAAaK,EAAKL,WACrBM,GACGP,GAA0BO,EAAQP,wBAClCC,GAAaM,EAAQN,SAPO,CASxC,EAoBA,SAASuE,GACLX,EACAP,EACA/B,EACA4hB,GAEA,IAAMrf,EAAeR,EAASO,GACxBE,EACFvD,GAAkBwD,sCAAsCH,GAC5D,GACKC,GACAA,EAAahE,MACbgE,EAAahE,KAAKmE,QAClBF,EAJL,CAWA,IAAMG,EAAeJ,EAAahE,KAAKoC,IAAI,SAAAiC,GACvC,OAvCR,SACIA,EACAN,EACAtC,EACAwC,EACAof,GAEA,IAAM/e,EAAOL,EAAUM,iCACnBF,EACAgf,GAMJ,OAJA/e,EAAK7C,sBAAwBA,EAEH,IAAIwC,EAAUO,qBAAqBF,EAGjE,CAuBeG,CACHJ,EACAN,EACAtC,EACAwC,EACAof,EAER,GAEA,OAAO,IAAIvjB,GAAwBsE,E,CACvC,CAEA,+B,CA0XA,OApXW,EAAmC,oCAA1C,SAA2CxC,GAC/B,MAA+BA,EAAd,aAAjBO,OAAY,IAAG,KAAE,EAAEH,EAAYJ,EAAY,QAE7C0hB,EACFC,GAA0BH,WAAW3V,oBAEnC+V,EAAgBrhB,EAAahB,KAC/B,SAAAsiB,GAAM,OAAAA,EAAGtjB,YAAcmjB,CAAjB,GAGV,OAAIE,EACOA,EAAc1lB,YAGrBkE,GAAWA,EAAQ7B,YAAcmjB,EAC1BthB,EAAQlE,iBADnB,C,EAKG,EAAA4lB,oBAAP,WAII,IAAM5e,EAAkC,IAAIC,WAAW,GAwBvD,OAvBAD,EAAgC,GAAK,EAEvB,CACVK,2BAA4B,CACxBC,MAAO,CAACN,EAAgCtG,QACxC6G,GAAI,MAIRC,kBAAmB,CACfF,MAAO,CAAC,uBACRC,GAAI,MAERE,uBAAwB,CACpBH,MAAO,CAACrF,GAAoByF,OAC5BH,GAAI,MAERI,0BAA2B,CACvBL,MAAO,CAAC,SACRC,GAAI,M,EAuBT,EAAuB,wBAA9B,SACItE,EACA4iB,EACAvM,EACArT,GAEQ,IAAA/C,EAAoBD,EAAgB,gBAEtCE,EAAqB3D,EAAQ0D,GAC7BE,EAAeD,EAAmBE,KAAK,SAAAZ,GACzC,OAAAD,GAAeC,EAAON,GAAtB,GAEEmB,EACFH,EAAmBI,OAAO,SAAAd,GACtB,OAAAD,GAAeC,EAAOH,GAAcC,G,IACnC,GACHiB,EAAWL,EAAmBE,KAChC,SAAAZ,GAAS,MAAoB,QAApBA,EAAMgB,SAAN,GAEPC,EAAclE,EAAQgE,EAASN,iBAAiBG,KAClD,SAAAZ,GAAS,MAAoB,WAApBA,EAAMgB,SAAsB,GAEjCE,EAA0BD,EAAYR,gBAAe,sBACrDU,EACJD,EAAqB,yBADSE,EAC9BF,EAAqB,sBAEnBmiB,EACFD,EAA2BjiB,GACzB0Q,EAAmBgF,EAASnU,IAC9B,mBACA2gB,GAGE5hB,EAAUd,EACV1B,GAAa0B,EAAae,0BAC1BC,EACAC,EAAef,EAAkBgB,IAAI,SAAAC,GACvC,OAAO7C,GAAa6C,EAAIJ,oBAC5B,GAEML,EAAe,CACjBU,iBAAaJ,EACbL,eAAgBH,EAChBmiB,WAAY,CACRC,cAAe/jB,GAAoByF,MACnC4R,SAAU,CACN7L,SAAUxH,EACV6f,kBAAiB,EACjBlI,oBAAqBtJ,EAAiB2R,oBACtCC,MAAO,IAEXhkB,UAAMkC,GAEVF,QAAO,EACPG,aAAY,GAShB,OAPIP,EAAaI,UACbJ,EAAaU,YAAcV,EAAaI,QAAQlE,aAGpD8D,EAAaiiB,WAAWzM,SAAS4M,MAC7BtjB,EAAkBujB,oCAAoCriB,GAEnD,CACHA,aAAY,EACZN,SAAQ,EACRE,YAAW,EACXC,sBAAqB,EACrBC,yBAAwB,EACxBC,sBAAqB,E,EAItB,EAAc,eAArB,SACIc,EACAC,EACA2gB,EACA1gB,GAIA,IAAIC,EAAuB,GASrBshB,EAAwC,CAAC,EACzCC,EAA2B,GAE3B7lB,EAAQoC,EAAkBgjB,sBAGhC5gB,OAAOC,KAAKN,GAAWW,QAAQ,SAAAC,GAC3B,IAAMC,EAAkBZ,EAAiBO,IACrC,kBACAI,GAEE+gB,EAAW1hB,EAAiBO,IAAI,WAAYI,GAE1CO,EAAgCN,EAAe,eAA/BK,EAAgBL,EAAe,YAC5BH,EAAsBihB,EAAQ,kBAKzD,GAHAF,EAAsCtgB,GAClCT,GAGCghB,EAAyBhjB,KACtB,SAAAkjB,GAAO,OAAAA,EAAInf,oBAAsB/B,CAAiB,GAExD,CAEE,IAAM6B,EACFtE,EAAkB4jB,gCAAgCF,GAEtDD,EAAyBxf,KAAKK,E,CAGlC,IAAMzB,EAAcb,EAAiBO,IAAI,cAAeI,GAClDG,EAAWf,EAAUY,GACrBI,EAAYX,OAAOC,KAAKS,GAExB/B,EAAwB,CAC1BiC,sBAAuBC,EACvBjC,yBAA0BkC,EAC1BjC,2BAAuBO,IAItBkiB,GACGA,EAAS5S,gBACT4S,EAAS5S,eAAiB,GAC9B7R,GAAWkE,wBAAwBF,MAEnClC,EAAsBE,sBAAwB4B,GAIlD,IAAMO,EAAoB,GAE1BL,EAAUL,QAAQ,SAAAW,GACd,IAAMxD,EAAQmE,GACVX,EACAP,EACA/B,EACA4hB,GAEA9iB,GACAuD,EAAkBa,KAAKpE,EAE/B,GAEAqC,EACIA,EAAqBgC,OAAOd,EACpC,GAEA,IAAMygB,EAA2B,IAAI1kB,GACjC,CAAEgF,yBAA0BjC,GAC5BD,GAGEiD,EAAS,IAAInG,GAAiB0kB,EAA0BxhB,GAExD/E,EAAc2mB,EAAyB3mB,YACzCumB,EAAwB,SACnBxhB,GAAO,CAAEuhB,sCAAqC,KAQvD,OAJAte,EAAOC,QAAU/C,OAAOgD,OAAOF,EAAOC,QAASjI,GAC/CgI,EAAOC,QAAQvH,MAAQA,EACvBsH,EAAOG,qBAAuB,aAEvBH,C,EAMJ,EAAiB,kBAAxB,SACIC,EACA8d,EACAa,EACApN,EACApR,GAGA,GAA2D,SAAvDH,EAAQK,wBAAwBC,mBAChC,MAAM,IAAI5H,MACN,+DAIR,IAMM6H,EAA4B9I,EAAQuI,EAAQ7E,iBAAiBG,KAC/DzD,EAPW,yBAWToG,EAAoBxG,EACtB8I,EAA0BpF,iBAC5BK,OAAO3D,EAZK,sBAeR2I,EAAkB,CAAC,EAEnBC,EACF5F,EAAkB6F,yCAEhBC,EAAwB,GAwE9B,OAtEA1D,OAAOC,KAAKuD,GAAwBlD,QAAQ,SAAAvC,GACxC2F,EAAsB7B,KAAK2B,EAAuBzF,IAClDwF,EAAgBxF,GAAO,EAC3B,GAEAiD,EAAkBV,QAAQ,SAAAqD,G,MACtB,IACI,IAAMge,EAAkCnnB,EACpCmJ,EAAiBzF,iBAUf,EANFyjB,EAAgCtjB,KAC5B,SAAAvD,GACI,MAnCQ,wBAmCRA,EAAYC,wBAAwBC,WAApC,GAKgB6I,UAEtB+d,EACFD,EAAgCtjB,KAC5B,SAAAvD,GACI,MA5Ce,+BA4CfA,EAAYC,wBAAwBC,WAApC,GAIN6mB,EACFD,aAAA,EAAAA,EAA+BE,IAE7B3gB,GAEE,QADJ,EAAA+B,aAAK,EAALA,EAAOY,oBACH,sBAAAH,EACAZ,EACAW,KAEJA,EAAsBrF,KAAK,SAAA0F,GACvB,OAAAA,EAAGC,qCACC,EADJ,GAKR,GAAI7C,EAAW,CACX,IAAM8C,EAAc9C,EAAU+C,mBAC1BP,EACAkd,EACAa,EACApN,GAGJrQ,EAAY8d,yBACRF,EAEJ1d,QAAQC,IAAI,cAAOjD,EAAUF,SAAc,SAC3CkD,QAAQC,IAAIH,GAEZV,EAAgBpC,EAAUF,UAAUY,KAAKoC,E,EAE/C,MAAO4W,GACL1W,QAAQoL,KACJ,oCACA5L,EACAkX,E,CAGZ,GAIOtX,C,EAOG,EAAY,aAA1B,SAA2BpC,GACvBvD,EAAkB6F,yCACdtC,EAAUkD,iBACVlD,EACJvD,EAAkBwD,sCACdD,EAAUF,UACVE,EACJvD,EAAkB0G,wBAAwBnD,EAAUF,UAChDE,EAAUkD,e,EAvXJ,EAAkB,mBAAG2d,GACrB,EAAuB,wBAAG,CAAC,EAC3B,EAAwC,yCAAG,CAAC,EAC5C,EAAqC,sCAAG,CAAC,EAoDhD,EAA+B,gCAAG,SAAAV,GACrC,IAIM9lB,EAAQoC,EAAkBgjB,sBAQhC,OANgC,GAAH,MACtBU,GAAQ,CACX9lB,MAAOA,EACPoH,OATW,CACXC,UAAW,OAYnB,EAoTH,EA1XD,GC/Ee2H,GAAgB/N,EAAAA,GAAU+H,OAAjCiG,MAEFC,GAAiB,gBACjBzE,GAA8B,GAAHnE,OAAMkgB,GAAkBlgB,KAAAA,OAAI4I,IAErD4V,GAAuCD,GAAvCC,WAAYljB,GAA2BijB,GAA3BjjB,uBAEdwN,GAAa,oBAAAA,IAAA/M,EAAA,KAAA+M,EAAA,QAAA9M,EAAA8M,EAAA,OAAA7M,IAAA,qBAAAC,MACf,SACIC,EACA4iB,EACAa,EACApN,GAkBA,IAhBA,IAAA3P,EACI/G,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA1J,EAAc3J,UALdnC,EAAY6F,EAAZ7F,aAAcJ,EAAWiG,EAAXjG,YAAaG,EAAqB8F,EAArB9F,sBAQ7BiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE/BjW,EAAO/L,EAAaiiB,WAAWzM,SAAS4M,MAEtCtb,EAAgBlH,EAAhBkH,YAEFqc,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,EACrB,CAIA,GAA2B,IAAvBD,EAAY5gB,OAAc,CAC1B,IAAM8gB,EAAmB7N,EAASnU,IAC9B,mBACA2gB,GAGAsB,EAAU,GACVC,EAAU,GAEd,GAAIF,EAEAC,EAD0BD,EAAlBpV,QACY,GACpBsV,EAF0BF,EAATnV,KAEA,GAGrB,IAAMsV,EAAcZ,EAAmBZ,EAAmB,CACtDlb,EAAY,GAAKwc,EACjBxc,EAAY,GAAKyc,IAGrBJ,EAAYpgB,KAAKygB,EACrB,CAEA,IAAMzd,EAAQ/F,EAed,OAbA+F,EAAMkc,WAAW7jB,KAAO,CACpB2N,KAAAA,EACA5F,QAAS,CACLsd,YAAY,EACZ3b,OAAQ,CAACqb,EAAY,GAAIA,EAAY,IACrCO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlB5E,YAAa5B,GAGVgG,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,EAAMgf,GAC1C,IAAQrjB,EAAmBqE,EAAnBrE,KAAMoX,EAAa/S,EAAb+S,SACRpV,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aACPyhB,EAAsBxM,EAAtBwM,kBAER,IAAKA,EACD,MAAM,IAAIrlB,MACN,oFAIR,IAAAgnB,EAA+BvlB,EAAK+H,QAA5B2B,EAAM6b,EAAN7b,OAUF8b,EAAanC,EAAmBO,EAVZ2B,EAAVF,WAKJ3b,EAAO,GAEPA,EAAO,IAKbkE,EAAgC,CAClClE,OAAQ,CACJ,CACInM,EAAGioB,EAAW,GACd7c,EAAG6c,EAAW,KAGtBzc,4BAAAA,GACA5G,aAAcA,GAAgB,IAclC,OAVKH,GAAWA,EAAQ7B,YAAcijB,GAAW3V,sBAC7CzL,EAAU,CACN7B,UAAWijB,GAAW3V,oBACtBvN,uBAAAA,GACApC,YAAakC,EAAK2N,OAI1BC,EAA8B5L,QAAUA,EAEjC4L,CACX,IAAC,CAxHc,GA2HnBF,GAAc3J,SAAWyJ,GACzBE,GAAcvG,gBAAkBqG,GAChCE,GAAclJ,qBAAuB8I,GACrCI,GAAc5G,qCAAuC,SAAAkC,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAkEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA3Dsc,EAAgBvc,EAAA,GAAEnF,EAAQmF,EAAA,GAEjC,OAAIuc,IAAqBX,IAIlB/gB,IAAayJ,EACxB,EAEA9M,GAAkB4I,aAAaoE,ICnJvB,IAAerD,GAAwB,KAAU/C,OAAM,cAEzDiD,GAAgB,gBAGhBxB,GAA8B,UAAG+b,GAAsB,YAAAva,IAE7D,2B,CAmLA,OAjKkB,EAAkB,mBAAhC,SACIxJ,EACA4iB,EACAa,EACApN,G,MAEM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA9M,EAAcvG,UALdnC,EAAY,eAAED,EAAqB,wBAQrCiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAC7B5iB,EAAoBD,EAAgB,gBAEtCyJ,EAAmBlN,EAAQ0D,GAAiBG,KAC9C,SAAAZ,GAAS,MAzCH,cAyCGA,EAAM1C,wBAAwBC,WAAyB,GAG9D2M,EAAsBnN,EACxBkN,EAAiBxJ,iBACnBG,KAAK,SAAAZ,GAAS,MAAoB,WAApBA,EAAMgB,SAAsB,GAEtCmJ,EAAoBpN,EAAQ0D,GAAiBG,KAC/C,SAAAZ,GAAS,MAhDF,eAgDEA,EAAM1C,wBAAwBC,WAA0B,GAG/D6M,EAAuBrN,EACzBoN,EAAkB1J,iBACpBG,KAAK,SAAAZ,GAAS,MAAoB,WAApBA,EAAMgB,SAAsB,GAEtCwjB,EAAc,GAEpB,CAACta,EAAqBE,GAAsBvH,QAAQ,SAAA7C,GAEhD,IADQ,IAAAmI,EAAgBnI,EAAK,YACpByJ,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,E,CAEzB,GAEA,IAAMrd,EAAQ/F,EAwBd,OAtBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CACJqb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9Bzf,OAAQqG,EAAiB3C,sBAAsBC,aAC/C4d,MAAOhb,EAAkB7C,sBAAsBC,cAEtD,GACDvE,YAAa5B,GAGVgG,C,EAGJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QAElC4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,oFAIF,IAoBFonB,EACAC,EArBE,EACFhc,EAAY,kBAAWga,KAAwB,CAAC,EAD5Czf,EAAM,SAAEuhB,EAAK,QAEbhc,EAAW3B,EAAO,OAGpB8d,EAAkB,CAACnc,EAAO,GAAIA,EAAO,IACrCoc,EAAmB,CAACpc,EAAO,GAAIA,EAAO,IAEZsB,KAAKqB,KACjCrB,KAAKsB,IAAIuZ,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,GACpD7a,KAAKsB,IAAIuZ,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,GACxD7a,KAAKsB,IAAIuZ,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,IAG/B7a,KAAKqB,KAClCrB,KAAKsB,IAAIwZ,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,GACtD9a,KAAKsB,IAAIwZ,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,GAC1D9a,KAAKsB,IAAIwZ,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,KAM9DH,EAAkBE,EAClBD,EAAiBE,IAEjBH,EAAkBG,EAClBF,EAAiBC,GAGrB,IAAME,EAAqB1C,EACvBO,EACA+B,EAAgB,IAEdK,EAAmB3C,EACrBO,EACA+B,EAAgB,IAEdM,EAAsB5C,EACxBO,EACAgC,EAAe,IAEbM,EAAoB7C,EACtBO,EACAgC,EAAe,IAGnB,MAAO,CACHla,SAAU,CACN9C,OAAQ,CACJrL,EAAGwoB,EAAmB,GACtBpd,EAAGod,EAAmB,IAE1Bld,OAAQ,CACJtL,EAAGyoB,EAAiB,GACpBrd,EAAGqd,EAAiB,KAG5Bra,UAAW,CACP/C,OAAQ,CACJrL,EAAG0oB,EAAoB,GACvBtd,EAAGsd,EAAoB,IAE3Bpd,OAAQ,CACJtL,EAAG2oB,EAAkB,GACrBvd,EAAGud,EAAkB,KAG7Bta,eAAgBzH,EAChB0H,gBAAiB6Z,EACjB3c,4BAA2BA,GAC3B/G,QAASA,EACTG,aAAcA,GAAgB,G,EA/KxB,EAAQ,SAAGoI,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGF,GACvB,EAAoC,qCAAG,SAAArB,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAawG,EACxB,EAmKH,EAnLD,GAqLA7J,GAAkB4I,aAAagB,IC7LvB,IAAWuD,GAAoB,KAAUvG,OAAM,UAEjD6e,GAAmB,QACnBpd,GAA8B,UAAG+b,GAAsB,YAAAqB,IAE7D,2B,CAyGA,OAtFkB,EAAkB,mBAAhC,SACIplB,EACA4iB,EACAa,EACApN,GAeA,I,MAbM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA9I,EAAMvK,UALNnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAC7BujB,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,E,CAGrB,IAAMrd,EAAQ/F,EAoBd,OAlBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CAACqb,EAAY,GAAIA,EAAY,GAAIA,EAAY,IACrDO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9BwC,MAAO9kB,EACDA,EAASuG,sBAAsBC,aAC/B,MAEb,GACDvE,YAAa5B,GAGVgG,C,EAGG,EAAApD,iCAAd,SAA+CF,EAAMgf,GACzC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QAElC4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,4EAIR,IAAM8nB,EAAShD,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9D8E,EAAS6U,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAE9DzB,EAAMob,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAE3Dd,EAAS,CAAErL,EAAG8oB,EAAO,GAAI1d,EAAG0d,EAAO,IACnCxd,EAAS,CAAEtL,EAAGiR,EAAO,GAAI7F,EAAG6F,EAAO,IAOzC,MAAO,CACH5F,OAAM,EACNC,OAAM,EACNsF,OATWtF,EAUXuF,OATW,CAAE7Q,EAAG0K,EAAI,GAAIU,EAAGV,EAAI,IAU/B+F,QARcpE,EAAY,kBAAWga,KAAwB,CAAC,GAAC,MAS/D7a,4BAA2BA,GAC3B/G,QAAO,EACPG,aAAcA,GAAgB,G,EArGxB,EAAQ,SAAGgkB,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGtY,GACvB,EAAoC,qCAAG,SAAA7E,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAaoiB,EACxB,EAyFH,EAzGD,GA2GAzlB,GAAkB4I,aAAagF,IChHvB,IAAWT,GAAoB,KAAUvG,OAAM,UAEjD6e,GAAmB,YACnBpd,GAA8B,UAAG+b,GAAsB,YAAAqB,IAE7D,2B,CA8GA,OA3FkB,EAAkB,mBAAhC,SACIplB,EACA4iB,EACAa,EACApN,GAeA,I,MAbM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACAtJ,EAAU/J,UALVnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAC7BujB,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,E,CAGrB,IAAMrd,EAAQ/F,EAyBd,OAvBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CACJqb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9BwC,MAAO9kB,EACDA,EAASuG,sBAAsBC,aAC/B,MAEb,GACDvE,YAAa5B,GAGVgG,C,EAGG,EAAApD,iCAAd,SAA+CF,EAAMgf,GACzC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QAElC4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,gFAIR,IAAM8nB,EAAShD,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9D4c,EAAOjD,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAE5DuE,EAASoV,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9DwE,EAAOmV,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IASlE,MAAO,CACHd,OARW,CAAErL,EAAG8oB,EAAO,GAAI1d,EAAG0d,EAAO,IASrCxd,OARW,CAAEtL,EAAG+oB,EAAK,GAAI3d,EAAG2d,EAAK,IASjCnY,OARW,CAAE5Q,EAAG0Q,EAAO,GAAItF,EAAGsF,EAAO,IASrCG,OARW,CAAE7Q,EAAG2Q,EAAK,GAAIvF,EAAGuF,EAAK,IASjCF,QAPcpE,EAAY,kBAAWga,KAAwB,CAAC,GAAC,MAQ/D7a,4BAA2BA,GAC3B/G,QAAO,EACPG,aAAcA,GAAgB,G,EA1GxB,EAAQ,SAAGgkB,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGtY,GACvB,EAAoC,qCAAG,SAAA7E,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAaoiB,EACxB,EA8FH,EA9GD,GCPwB,SAAArf,GACpByf,GAEA,IAAKA,EAAmBtd,SAAS,KAC7B,OAAO,EAGL,MAA+Bsd,EAAmBpd,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAMlB/gB,EAASyiB,gBAAkB5D,KAAK7e,SAASyiB,aACpD,CDuGA9lB,GAAkB4I,aAAawE,IEpHvB,IAAQd,GAAiB,KAAU1F,OAAM,OAE3C4F,GAAY,YAElB,2B,CAwGA,OA/FW,EAAkB,mBAAzB,SACInM,EACA4iB,EACAa,EACApN,GAiBA,I,MAfM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACAqP,EAAU1iB,UALVnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAG7BklB,EAAc,GACX1c,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAM2c,EAAWnC,EAAmBZ,EAAmB,CACnDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAGpB0c,EAAY/hB,KAAKgiB,E,CAGrB,IAAMhf,EAAQ/F,EAuBd,OArBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,GAAF,GAAMgd,GAAY,GACxBpB,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9B/Z,KAAMvI,EACAA,EAASuG,sBAAsBC,aAC/B,EAENsF,OAAQ,EACRhD,UAAW,GAElB,GACD7G,YAAa5B,GAGVgG,C,EASJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QAElC4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,gFAIR,IAAMwO,EAASsW,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9DzB,EAAMob,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAE3DA,EAAS,GACfA,EAAO/E,KAAK,CAAEpH,EAAGwP,EAAO,GAAIpE,EAAGoE,EAAO,KACtCrD,EAAO/E,KAAK,CAAEpH,EAAG0K,EAAI,GAAIU,EAAGV,EAAI,KAE1B,MACF2B,EAAY,kBAAWga,KAAwB,CAAC,EAD5C/Z,EAAI,OAAEuD,EAAM,SAIpB,MAAO,CACHvD,KAAI,EACJO,UAJc,EAAIY,KAAKqC,GAAKD,EAK5BA,OAAM,EACN1D,OAAM,EACNX,4BAA6B6Z,KAAK7Z,4BAClC/G,QAAO,EACPG,aAAcA,GAAgB,G,EApG/B,EAAA4G,4BAA8B,GAAG,OAAA+b,GAAsB,YAAA5X,IACvD,EAAQ,SAAGA,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGF,GACvB,EAAoC,qCACvClG,GAkGP,C,CAxGD,GA0GApG,GAAkB4I,aAAamd,IC3GvB,IAAS3a,GAAkB,KAAUxE,OAAM,QAE7C0E,GAAgB,gBAChB4a,GAAU,KAEhB,2B,CA0LA,OAlLW,EAAkB,mBAAzB,SACI7lB,EACA4iB,EACAa,EACApN,GAoBA,I,MAlBM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACAyP,EAAc9iB,UALdnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAM7BklB,EAAwB,GACrB1c,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAM2c,EAAWnC,EAAmBZ,EAAmB,CACnDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAGpB0c,EAAY/hB,KAAKgiB,E,CAGrB,IAAMG,EAAiB,gBAAe,MAAf,KAAmBJ,EAAY,IAChDK,EAAe,gBAAe,MAAf,KAAmBL,EAAY,IAC9CM,EAAiB,gBAAe,MAAf,KAAmBN,EAAY,IAChDO,EAAe,gBAAe,MAAf,KAAmBP,EAAY,IAE9CQ,EAAe,cACrB,SAASA,EAAcH,EAAcD,GAGrC,eAAeI,EAAcA,GAE7B,IAAMC,EAAe,cACrB,SAASA,EAAcF,EAAcD,GACrC,eAAeG,EAAcA,GAE7B,IAAM/U,EAAmBgF,EAASnU,IAC9B,mBACA2gB,GAGJ,IAAKxR,EACD,MAAM,IAAI7T,MAAM,mDAGZ,IAAAwU,EAAkBX,EAAgB,cAGpCgV,EAAmB,gBACrBrU,EAAc,GACdA,EAAc,GACdA,EAAc,IAEZsU,EAA6B,SAC/BD,EACAF,GAGEI,EAA6B,SAC/BF,EACAD,GAGEI,EAA4Bvc,KAAK6B,IAAIwa,GACrCG,EAA4Bxc,KAAK6B,IAAIya,GAEvCG,EAAgB,GAChBzc,KAAK6B,IAAI0a,EAA4B,GAAKX,GAC1Ca,EAAgB,CACZf,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAET1b,KAAK6B,IAAI2a,EAA4B,GAAKZ,GACjDa,EAAgB,CACZf,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAGhBzf,QAAQoL,KAAK,qCAGjB,IAAM1K,EAAQ/F,EAoBd,OAlBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,GAAF,GAAM+d,GAAc,GAC1BnC,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9B/Z,KAAMvI,EACAA,EAASuG,sBAAsBC,aAC/B,GAEb,GACDvE,YAAa5B,GAGVgG,C,EAGJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAUJqE,EAAKC,EAAQC,EAAMC,EAVf7nB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QACpC8nB,EAAW9nB,EAAK2M,iBAAmB,EACjCiX,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,oFAKQ,IAAZupB,GAA8B,KAAZA,GAClBH,EAAStE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9Dge,EAAMrE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC3Dke,EAAOvE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC5Dme,EAAQxE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,MAE7Dge,EAAMrE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC3Die,EAAStE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC9Dke,EAAOvE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC5Dme,EAAQxE,EAAmBO,EAAmB7b,EAAQ2B,OAAO,KAIjE,IAGMA,EAAS,GAqBf,OAxBwBsB,KAAK6B,IAAI6a,EAAI,GAAKC,EAAO,IACzB3c,KAAK6B,IAAI+a,EAAK,GAAKC,EAAM,KAK7Cne,EAAO/E,KAAK,CAAEpH,EAAGmqB,EAAI,GAAI/e,EAAG+e,EAAI,KAChChe,EAAO/E,KAAK,CAAEpH,EAAGoqB,EAAO,GAAIhf,EAAGgf,EAAO,KAGtCje,EAAO/E,KAAK,CAAEpH,EAAGqqB,EAAK,GAAIjf,EAAGif,EAAK,KAClCle,EAAO/E,KAAK,CAAEpH,EAAGsqB,EAAM,GAAIlf,EAAGkf,EAAM,OAGpCne,EAAO/E,KAAK,CAAEpH,EAAGqqB,EAAK,GAAIjf,EAAGif,EAAK,KAClCle,EAAO/E,KAAK,CAAEpH,EAAGsqB,EAAM,GAAIlf,EAAGkf,EAAM,KAGpCne,EAAO/E,KAAK,CAAEpH,EAAGmqB,EAAI,GAAI/e,EAAG+e,EAAI,KAChChe,EAAO/E,KAAK,CAAEpH,EAAGoqB,EAAO,GAAIhf,EAAGgf,EAAO,MAKnC,CACH9d,MAHaD,EAAY,kBAAWga,KAAwB,CAAC,GAAC,KAI9Dla,OAAM,EACNX,4BAA6B6Z,KAAK7Z,4BAClC/G,QAAO,EACPG,aAAcA,GAAgB,G,EAtL/B,EAAA4G,4BAA8B,GAAG,OAAA+b,GAAsB,YAAA9Y,IACvD,EAAQ,SAAGA,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGF,GACvB,EAAoC,qCACvChF,GAoLP,EA1LD,GA4LApG,GAAkB4I,aAAaud,ICrMvB,IAAUtd,GAAmB,KAAUjC,OAAM,SAE/CygB,GAAW,eACXhf,GAA8B,UAAG+b,GAAsB,YAAAiD,IAE7D,2B,CA2GA,OAxFkB,EAAkB,mBAAhC,SACIhnB,EACA4iB,EACAa,EACApN,GAeA,I,MAbM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA4Q,EAAajkB,UALbnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAC7BujB,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,E,CAGrB,IAAMrd,EAAQ/F,EAyBd,OAvBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CACJqb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9B/Z,KAAMvI,EACAA,EAASuG,sBAAsBC,aAC/B,MAEb,GACDvE,YAAa5B,GAGVgG,C,EAGJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C,EAA8BrE,EAAd,YAAhB4J,OAAW,IAAG,GAAC,EAAC,EAAE7B,EAAY/H,EAAI,QAElC4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,gFAIR,IAAM0pB,EAAUlgB,EAAQ2B,OAAOtH,IAAI,SAAA4iB,GAC/B,OAAA3B,EAAmBO,EAAmBoB,EAAtC,GAGInb,EAAoBD,EAAW,KAAzBQ,EAAcR,EAAW,UAEvC,MAAO,CACHF,OAAQ,CACJue,EAAQ,GACRA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,IAEZpe,KAAI,EACJO,UAAS,EACTrB,4BAA2BA,GAC3B/G,QAAO,EACPG,aAAcA,GAAgB,G,EAvGxB,EAAQ,SAAG4lB,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAGxe,GAEvB,EAAoC,qCAAG,SAAAP,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAagkB,EACxB,EA0FH,EA3GD,GA6GArnB,GAAkB4I,aAAa0e,IClH/B,IAAgB3gB,GAAiB9H,EAAAA,GAAU+H,OAAnCC,OAEFC,GAAS,SACTuB,GAA8B,GAAHnE,OAAMkgB,GAAkBlgB,KAAAA,OAAI4C,IAEvDD,GAAM,oBAAAA,IAAA5G,EAAA,KAAA4G,EAAA,QAAA3G,EAAA2G,EAAA,OAAA1G,IAAA,qBAAAC,MAER,SACIC,EACA4iB,EACAa,EACApN,GAeA,IAbA,IAAA3P,EACI/G,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA7P,EAAOxD,UALPnC,EAAY6F,EAAZ7F,aAAcN,EAAQmG,EAARnG,SAAUE,EAAWiG,EAAXjG,YAAaG,EAAqB8F,EAArB9F,sBAQvCiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAhBkH,YACFqc,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,EACrB,CAEA,IAAMrd,EAAQ/F,EAoBd,OAlBA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CAACqb,EAAY,GAAIA,EAAY,IACrCO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,YAAWse,EAAA,cAAAtjB,OACKgf,GAAsB,CAC9Bzf,OAAQ7C,EACFA,EAASuG,sBAAsBC,aAC/B,IAGdvE,YAAa5B,GAGVgG,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,EAAMgf,GAC1C,IAAQrjB,EAA0CqE,EAA1CrE,KAAMgC,EAAoCqC,EAApCrC,QAASG,EAA2BkC,EAA3BlC,aAAciV,EAAa/S,EAAb+S,SACrC+Q,EAAsCnoB,EAA9B4J,YAAAA,OAAW,IAAAue,EAAG,CAAC,EAACA,EAAEpgB,EAAY/H,EAAZ+H,QAElB6b,EAAsBxM,EAAtBwM,kBAER,IAAKA,EACD,MAAM,IAAIrlB,MACN,6EAIR,IAAMyJ,EAAQqb,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC7DzB,EAAMob,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAQjE,MAAO,CACHd,OAPW,CAAErL,EAAGyK,EAAM,GAAIW,EAAGX,EAAM,IAQnCa,OAPW,CAAEtL,EAAG0K,EAAI,GAAIU,EAAGV,EAAI,IAQ/Ba,UALAc,EAAWhF,WAAAA,OAAYgf,KAAwB,CAAC,GAD5Czf,OAOJ4E,4BAAAA,GACA/G,QAAAA,EACAG,aAAcA,GAAgB,GAEtC,IAAC,CAjFO,GAoFZoF,GAAOxD,SAAWyD,GAClBD,GAAOJ,gBAAkBK,GACzBD,GAAO/C,qBAAuB6C,GAC9BE,GAAOT,qCAAuC,SAAAkC,GAC1C,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAkEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA3Dsc,EAAgBvc,EAAA,GAAEnF,EAAQmF,EAAA,GAEjC,OAAIuc,IAAqBX,IAIlB/gB,IAAayD,EACxB,EAEA9G,GAAkB4I,aAAa/B,ICzGvB,IAAUgC,GAAmB,KAAUjC,OAAM,SAE/C8gB,GAAoB,oBACpBrf,GAA8B,UAAG+b,GAAsB,YAAAsD,IAG7D,2B,CAwIA,OAtHW,EAAkB,mBAAzB,SACIrnB,EACA4iB,EACAa,EACApN,GAgBA,I,MAdM,EACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACAiR,EAAkBtkB,UALlBnC,EAAY,eAAEN,EAAQ,WAAEE,EAAW,cAAEG,EAAqB,wBAQ5DiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAC7Blb,EAAgBlH,EAAW,YAE7BujB,EAAc,GAEX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAGpB+a,EAAYpgB,KAAKqgB,E,CAGrB,IAKIsD,GAAgB,EALqB,cACrCvD,EAAYA,EAAY5gB,OAAS,GACjC4gB,EAAY,IAnDO,OA0DnBA,EAAYwD,MAEZD,GAAgB,GAGpB,IAAM5e,EAAS,GAEX4e,GACA5e,EAAO/E,KAAKogB,EAAY,GAAIA,EAAYA,EAAY5gB,OAAS,IAGjE,IAAMwD,EAAQ/F,EAqBd,OAnBA+F,EAAMkc,WAAW7jB,KAAO,CACpBwoB,QAAS,CAAEC,SAAU1D,EAAa2D,QAASJ,GAC3CvgB,QAAS,CACL2B,OAAM,EACN4b,kBAAmB,KACnBpd,QAAS,CACLC,UAAU,IAGlByB,aAAW,KACP,EAAC,kBAAWga,IAAsB,CAC9B/Z,KAAMvI,EACAA,EAASuG,sBAAsBC,aAC/B,MAEb,GACDvE,YAAa5B,GAGVgG,C,EAGJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAEhD,EAAuBrE,EAAKwoB,QAA1BC,EAAQ,WACVH,GAA2B,IADT,SAGhB1E,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,wFAIR,IAAMmL,EAAS+e,EAASrmB,IAAI,SAAAukB,GACxB,OAAAtD,EAAmBO,EAAmB+C,EAAtC,GAGJ,IAAK2B,EAAe,CAEhB,IAAMK,EAAajf,EAAO,GAG1BA,EAAO/E,KAAK,CAACgkB,EAAW,GAAIA,EAAW,I,CAGrC,MACF3oB,EAAK4J,YAAY,WAAW,OAAAga,KAAwB,CAAC,EADjD/Z,EAAI,OAAE+e,EAAQ,WAAEC,EAAY,eAGpC,MAAO,CAEHnf,OAAM,EACNG,KAAI,EACJ+e,SAAQ,EACRxe,UAR2C,YAS3Cye,aAAY,EACZC,KAViD,OAWjD7d,IAXsD,MAYtD8d,OAZ8D,SAc9DhgB,4BAA2BA,GAC3B/G,QAAO,EACPG,aAAcA,GAAgB,G,EApIxB,EAAQ,SAAGimB,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAG7e,GACvB,EAAoC,qCAAG,SAAAP,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAaqkB,EACxB,EAwHH,EAxID,GA0IA1nB,GAAkB4I,aAAa+e,ICjJ/B,IAAe/a,GAAgB/N,EAAAA,GAAU+H,OAAjCiG,MAEFyb,GAAQ,QACRjgB,GAA8B,GAAHnE,OAAMkgB,GAAkBlgB,KAAAA,OAAIokB,IAEvDC,GAAK,oBAAAA,IAAAtoB,EAAA,KAAAsoB,EAAA,QAAAroB,EAAAqoB,EAAA,OAAApoB,IAAA,qBAAAC,MACP,SACIC,EACA4iB,EACAa,EACApN,GAgBA,IAdA,IAAA3P,EACI/G,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA6R,EAAMllB,UALNnC,EAAY6F,EAAZ7F,aAAcJ,EAAWiG,EAAXjG,YAAaG,EAAqB8F,EAArB9F,sBAQ7BiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAhBkH,YAEFqc,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,EACrB,CAEA,IAAMrd,EAAQ/F,EAad,OAXA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQqb,EACRO,kBAAmB,KACnBpd,QAAS,CACLC,UAAU,IAGlB5E,YAAa5B,GAGVgG,CACX,GAAC,CAAA9G,IAAA,mCAAAC,MAED,SAAwCuD,EAAMgf,GAC1C,IAAQrjB,EAAmBqE,EAAnBrE,KAAMoX,EAAa/S,EAAb+S,SACRpV,EAA0BqC,EAA1BrC,QAASG,EAAiBkC,EAAjBlC,aACPyhB,EAAsBxM,EAAtBwM,kBAER,IAAKA,EACD,MAAM,IAAIrlB,MACN,4EAqBR,MAPsC,CAClCmL,OAXe1J,EAAK+H,QAAhB2B,OAEmBtH,IAAI,SAAA4iB,GAC3B,IAAMQ,EAAanC,EAAmBO,EAAmBoB,GACzD,MAAO,CACHznB,EAAGioB,EAAW,GACd7c,EAAG6c,EAAW,GAEtB,GAIIzc,4BAAAA,GACA5G,aAAcA,GAAgB,GAC9BH,QAAAA,EAIR,IAAC,CA1EM,GA6EXinB,GAAMllB,SAAWilB,GACjBC,GAAM9hB,gBAAkB6hB,GACxBC,GAAMzkB,qBAAuB8I,GAC7B2b,GAAMniB,qCAAuC,SAAAkC,GACzC,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGX,IAAkEC,EAAAT,EAA7BO,EAAmBG,MAAM,KAAI,GAA3Dsc,EAAgBvc,EAAA,GAAEnF,EAAQmF,EAAA,GAEjC,OAAIuc,IAAqBX,IAIlB/gB,IAAailB,EACxB,EAEAtoB,GAAkB4I,aAAa2f,ICnGvB,IAAQ5hB,GAAiB,KAAUC,OAAM,OAE3C4hB,GAAyB,4BACzBngB,GAA8B,UAAG+b,GAAsB,YAAAoE,IAE7D,2B,CAyFA,OAtEW,EAAkB,mBAAzB,SACInoB,EACA4iB,EACAa,EACApN,GAeA,IAbM,MACF1W,GAAkBgH,wBACd3G,EACA4iB,EACAvM,EACA+R,EAAsBplB,UALtBnC,EAAY,eAAEJ,EAAW,cAAEG,EAAqB,wBAQlDiiB,EACFhiB,EAAaiiB,WAAWzM,SAASwM,kBAE7Blb,EAAgBlH,EAAW,YAC7BujB,EAAc,GACX/a,EAAI,EAAGA,EAAItB,EAAYvE,OAAQ6F,GAAK,EAAG,CAC5C,IAAMgb,EAAQR,EAAmBZ,EAAmB,CAChDlb,EAAYsB,GACZtB,EAAYsB,EAAI,KAEpB+a,EAAYpgB,KAAKqgB,E,CAGrB,IAAMrd,EAAQ/F,EAcd,OAZA+F,EAAMkc,WAAW7jB,KAAO,CACpB+H,QAAS,CACL2B,OAAQ,CAACqb,EAAY,GAAIA,EAAY,IACrCO,kBAAmB,EACnBpd,QAAS,CACLC,UAAU,IAGlByB,YAAa,CAAC,EACdrG,YAAa5B,GAGVgG,C,EAGJ,EAAApD,iCAAP,SAAwCF,EAAMgf,GAClC,IAAArjB,EAA0CqE,EAAI,KAAxCrC,EAAoCqC,EAAI,QAA/BlC,EAA2BkC,EAAf,aAAE+S,EAAa/S,EAAI,SAC9C0D,EAAY/H,EAAI,QAEhB4jB,EAAsBxM,EAAQ,kBAEtC,IAAKwM,EACD,MAAM,IAAIrlB,MACN,gGAIR,IAAMyJ,EAAQqb,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAC7DzB,EAAMob,EAAmBO,EAAmB7b,EAAQ2B,OAAO,IAKjE,MAAO,CACHd,OAJW,CAAErL,EAAGyK,EAAM,GAAIW,EAAGX,EAAM,IAKnCa,OAJW,CAAEtL,EAAG0K,EAAI,GAAIU,EAAGV,EAAI,IAK/Bc,4BAA2B,GAC3B/G,QAAO,EACPG,aAAcA,GAAgB,G,EArFxB,EAAQ,SAAG+mB,GACX,EAAe,gBAAGA,GAClB,EAAoB,qBAAG7hB,GACvB,EAAoC,qCAAG,SAAA2B,GACjD,IAAKA,EAAmBC,SAAS,KAC7B,OAAO,EAGL,MAA+BD,EAAmBG,MAAM,KAAvDsc,EAAgB,KAAE1hB,EAAQ,KAEjC,OAAI0hB,IAAqBX,IAIlB/gB,IAAamlB,EACxB,EAyEH,EAzFD,GA2FAxoB,GAAkB4I,aAAa6f,ICjGvB,IAAAxpB,GAAe,KAAW,WACZyP,GAA2B,KAAW,aCFpD,IACmBga,GADFlH,GAAc,aACuC,kB,+DCG9E,SAAmCjL,GAoB/B,IAPQ,IAAAoS,EAA2BpS,EAAU,WAAzBqS,EAAerS,EAAU,WAGvCE,EAAc,GACdoS,EAAuB,IAAIC,IAGxBzZ,EAAI,EAAGA,EAAIuZ,EAAW,GAAIvZ,IAAK,CAQpC,IAPA,IAAMuB,EAAY+X,EAAWtL,MACzBhO,EAAIuZ,EAAW,GAAKA,EAAW,IAC9BvZ,EAAI,GAAKuZ,EAAW,GAAKA,EAAW,IAGnC9R,EAAqB,GAElBxN,EAAI,EAAGA,EAAIsH,EAAUnN,OAAQ6F,IAAK,CACvC,IAAM8H,EAAUR,EAAUtH,GACrBwN,EAAmBvO,SAAS6I,IAAwB,IAAZA,GACzC0F,EAAmB7S,KAAKmN,E,CAIhC,IAAMyF,EAAa,CACfC,mBAAkB,EAClBlG,UAAS,EACTxB,KAAMwZ,EAAW,GACjBzZ,QAASyZ,EAAW,IAGU,IAA9B9R,EAAmBrT,SAIvBqT,EAAmBpU,QAAQ,SAAAsO,GACvB6X,EAAqBE,IAAI/X,EAC7B,GAEAyF,EAAYmS,EAAW,GAAK,EAAIvZ,GAAKwH,E,CAQzC,OAJAN,EAAWO,mBAAqBha,MAAMiB,KAAK8qB,GAE3CtS,EAAWE,YAAcA,EAElBF,CACX,E,qBFrDA,SAA8B1H,EAAQmI,EAAWN,EAAUzU,GAMvD,YANuD,IAAAA,IAAAA,EAAY,IAM5D8T,GAaX,SACIlH,EACA6H,EACAzU,GAEA,IAAMyN,EAAWb,EAAOnN,IAAI,SAAAsnB,GAExB,IAAMtF,EAAWhN,EAASnU,IAAI,WAAYymB,EAAMrmB,SAChD,OACO,YAAAqmB,GACAtF,GAAQ,CAEXuF,YAAavF,EAASwF,aAAexF,EAASuF,YAC9CE,eAAgBzF,EAAS0F,gBAAkB1F,EAASyF,eACpDlkB,UAAW+jB,EAAMK,eACjBrkB,OAAQ,CACJC,UAAW,MAEfrH,MAAO,CAAC,GAEhB,GAEMuS,EAAalR,GAAWmR,mBAAmBV,GAEjD,OAAO,IAAIhB,GAAuB,CAACyB,GAAalO,EACpD,CA3CyBqnB,CACjBza,EACA6H,EACAzU,GAEkC+U,EAAW/U,EACrD,E,kBCAA,SACIwP,EACA9B,EACA3N,EACA+V,EACAE,GAEA,YAHA,IAAAF,IAAAA,GAAuB,QACvB,IAAAE,IAAAA,EAAgB,MAETyQ,GACHjX,EACA9B,EACA3N,EACA+V,EACAE,EAER,IEjCe,SAASsR,GACpB7S,EACA1U,EACAmD,GAEA,IAA2BxC,EAAiC+T,EAApDwM,kBAA4BlI,EAAwBtE,EAAxBsE,oBAE5BxW,EADSxC,EAAiBO,IAAI,WAAYI,GAC1C6B,kBAEAyO,EAA6B9N,EAA7B8N,yBAER,MAAO,CACH,CACI+H,oBAAAA,EACAwO,0BAA2B,CACvB,CACIxmB,sBAAuBmC,EAAQ8jB,YAC/BjoB,yBAA0BmE,EAAQgkB,eAClCM,2BAA4B,CACxB,CACIjlB,kBAAAA,EACAklB,qBAAoBtX,EACba,EAAyB,GACvB0W,iCAQrC,CC/Be,SAASC,GACpBlT,EACAmT,EACA7nB,EACA8nB,GAGA,IAA2BnnB,EAAY+T,EAA/BwM,kBACFQ,EAAW1hB,EAAiBO,IAAI,WAAYI,GAC1C6B,EAAwCkf,EAAxClf,kBAAmBD,EAAqBmf,EAArBnf,iBAErB0O,EAA2B,GACjC,GAAIzO,EAAmB,CACnB,IAAMulB,EAASD,EAAmBE,UAC9BzlB,EACAC,GAGEylB,EAAmB,CACrBzlB,kBAAAA,EACAmlB,2BAA4B,IAGhCI,EAAOG,UAAUxnB,QAAQ,SAAAghB,GACrB,IAAQyF,EAAgCzF,EAAhCyF,eAAgBF,EAAgBvF,EAAhBuF,YACxBgB,EAAiBN,2BAA2B1lB,KAAK,CAC7CjB,sBAAuBimB,EACvBjoB,yBAA0BmoB,GAElC,GAEAlW,EAAyBhP,KAAKgmB,EAClC,CAEA,OAAOhX,CACX,CCnCe,SAASkX,GAAsBrC,EAASrd,GACnD,IAAQuQ,EAAwB8M,EAAQpR,SAAhCsE,oBAER,MAAO,CACHoP,UAAW3f,EAAQ,EACnB4f,QAASvC,EAAQwC,MAAQ,cAAJpmB,OAAkBuG,EAAQ,GAC/C8f,eAAgB,qBAAFrmB,OAAuBuG,EAAQ,GAC7C+f,uBAAwB,kBACxBC,8BAA+BzP,EAEvC,CCDM,OACFnc,EAAAA,UAAAA,SADI6rB,GAA+B,mCAAEC,GAAqB,yBAEtDtrB,GAAwB,eAAU,oBAsR1C,SAASurB,GAAmBC,EAAYC,EAAa9oB,GACjD,IAAM+oB,EAAmB1rB,GAAoByF,MAGlBnC,EAAiCmoB,EAAW,kBAAnC9P,EAAwB8P,EAAW,oBAE/DtoB,EAAqBR,EAAiBO,IAC1C,sBACAI,GACH,iBAEKqoB,EC5SK,SAA0BroB,EAASX,GAC9C,IAAMM,EAAsBN,EAAiBO,IACzC,sBACAI,GAEEsoB,EAAqBjpB,EAAiBO,IACxC,qBACAI,GAEEuoB,EAAqBlpB,EAAiBO,IACxC,qBACAI,GAEEqoB,EAAgBhpB,EAAiBO,IAAI,gBAAiBI,GACtDwoB,EAA2BnpB,EAAiBO,IAC9C,2BACAI,GAGJ,MAAO,CACHyoB,SAAU9oB,EAAoB+oB,SAC9BC,UAAWN,EAAcO,UACzBC,YAAaR,EAAcS,YAC3BC,iBAAkB,GAClBC,WAAYT,EAAmBU,WAC/BC,WAAYV,EAAyBW,WACrCC,cAAeb,EAAmBc,cAClCC,UAAWhB,EAAmBiB,UAC9BC,UAAWlB,EAAmBmB,UAC9BC,QAAS,OACTC,gBAAiBrB,EAAmBsB,gBAE5C,CD4Q0BC,CAAiB7pB,EAASX,GAC1CyqB,EE7SK,SAA2BptB,GACtC,MAAO,CACHmF,kBAAmBnF,EAAoByF,MACvC4nB,aAAc,KAEtB,CFwS2BC,CAAkBttB,IAEzC,OACI,UAAAutB,wBAAyB,GACzBC,mBAAoB,GACpBC,0BAA2B,GAC3B7Z,yBAA0B,GAC1B8Z,mCAAoC,IACjC/B,GACAyB,GACH,CAAAloB,iBAAkB/B,EAClBymB,YAAa,gCACbE,eAAgB4B,EAChBiC,aAAc,QACd5B,SAAU,WACVpQ,oBAAmB,EACnBiS,2BAA4B,GAC5BC,kBAAmBrC,EAAWvH,OAAS,GACvC6J,iBAAkBtC,EAAWP,MAAQ,GACrC8C,uBAAwB,GACxBC,cAAe,GACfC,iBAAkBjuB,GAAoBkuB,OACtCC,iBAAkBnuB,GAAoBouB,OACtC7vB,MAAO,MAEf,CGhUQ,IAAA8sB,GAAoC7rB,EAAAA,UAAAA,SAAAA,gC,gGHiM5C,SACI6uB,EACA1rB,EACA8nB,GAEA,IAIM3kB,EAAUylB,GAJG,CACfN,KAAM,wBACNhH,MAAO,yBAIPoK,EAAY,GAAGhX,SACf1U,GAGJ0rB,EAAYhrB,QAAQ,SAACygB,EAAY1Y,GAC7B,IAAMkjB,EAAkBhD,GAAsBiD,QAC1CzK,EACA1Y,EACAzI,GAGJmD,EAAQynB,wBAAwB3oB,KAC5BkmB,GAAsBhH,EAAY1Y,IAGtCtF,EAAQ0nB,mBAAmB5oB,KAAK0pB,GAChCxoB,EAAQ2nB,0BAA0B7oB,KIlO3B,SAAsCnB,EAAU2H,GAC3D,MAAO,CACHojB,kBAAmBpjB,EAAQ,EAC3BqjB,oBAAqBrjB,EAAQ,EAC7BsjB,qBAAsB,aACtBC,eAAgB,oBAExB,CJ4NYC,CAA6B9K,EAAY1Y,IAK7CtF,EAAQ8N,yBAA2B2W,GAC/BzG,EAAWzM,SACXjM,EACAzI,EACA8nB,GAIJ3kB,EAAQ4nB,mCACJxD,GACIpG,EAAWzM,SACX1U,EACAmD,EAEZ,GAEA,IAAMf,EAAkC,IAAIC,WAAW,GACvDD,EAAgC,GAAK,EAErC,IAAMxG,EAAQ,CACV6G,2BAA4B,CACxBC,MAAO,CAACN,EAAgCtG,QACxC6G,GAAI,MAERC,kBAAmB,CACfF,MAAO,CAAC,uBACRC,GAAI,MAERE,uBAAwB,CACpBH,MAAO,CAACrF,GAAoByF,OAC5BH,GAAI,MAERI,0BAA2B,CACvBL,MAAO,CAAC,SACRC,GAAI,OAOZ,OAHAQ,EAAQvH,MAAQA,EAChBuH,EAAQE,qBAAuB,aAExBF,CACX,E,8BAxPA,SACI+oB,EACAlsB,EACA8nB,GAGA,IAAMqE,EAAc,GAEAzD,GAAgC,CAChDwD,cAAa,IAGLxrB,QAAQ,SAAC0rB,EAAYC,GAE7B,GAAID,EAAY,CACZ,IAAM,EAAkB,GACxBA,EAAWE,cAAc5rB,QAAQ,SAAA6rB,GA2B7B,IAAMC,EAAYxsB,EAAiBO,IAC/B,kBACAgsB,EAAarL,mBAIXwG,EAAuB,CACzB,CAAE1mB,sBAHwBwrB,EAAUvrB,YAGXjC,yBAFIwtB,EAAUtrB,iBAKrCurB,EAAuBF,EAAaG,SAE1CH,EAAaI,SAASjsB,QAAQ,SAAColB,EAASrd,GACpC,IAAMmkB,EAAuB9G,EAAQnqB,KAC/BkxB,EAAwB/G,EAAQgH,cAAcrrB,OAC9CsrB,EAAc,GAEpBjH,EAAQgH,cAAcpsB,QAAQ,SAAA4hB,GAC1B,IAAM0K,EAAYP,EAAqBzlB,OAAOsb,GAC9C0K,EAAU,IAAMA,EAAU,GAAGC,QAAQ,GACrCD,EAAU,IAAMA,EAAU,GAAGC,QAAQ,GACrCD,EAAU,IAAMA,EAAU,GAAGC,QAAQ,GACrCF,EAAY9qB,KAAK+qB,EAAU,IAC3BD,EAAY9qB,KAAK+qB,EAAU,IAC3BD,EAAY9qB,KAAK+qB,EAAU,GAC/B,GAEA,EAAgB/qB,KAAK,CACjBylB,qBAAoB,EACpBkF,qBAAoB,EACpBC,sBAAqB,EACrBK,cAAezkB,EAAQ,EACvBskB,YAAW,GAEnB,EACJ,GAEA,IAAMI,EAAWf,EAAW9K,OAAS,kBAAW+K,EAAW,GAErDe,EAAa,CACf9E,KAAM6E,EACNvtB,YAAautB,EACbE,gBAAe,EACfjmB,MAAOglB,EAAWhlB,MAClBsN,SAAU0X,EAAW1X,UAGzByX,EAAYlqB,KAAKmrB,E,CAEzB,GAEA,IAKMjqB,EAAUylB,GALG,CACfN,KAAM4D,EAAc5K,MACpBA,MAAO4K,EAAc5K,OAKrB6K,EAAY,GAAGzX,SACf1U,GAGJmsB,EAAYzrB,QAAQ,SAAColB,EAASrd,GAC1B,IAAM6kB,EAAa,CACfC,gBAAiBzH,EAAQ1e,OAAS,CAAC,IAAK,EAAG,GAC3CukB,gBAAiB7F,EAAQuH,gBACzBvB,oBAAqBrjB,EAAQ,GAGjCtF,EAAQynB,wBAAwB3oB,KAC5BkmB,GAAsBrC,EAASrd,IAGnCtF,EAAQ0nB,mBAAmB5oB,KAAKqrB,GAGhCnqB,EAAQ8N,yBAA2B2W,GAC/B9B,EAAQpR,SACRjM,EACAzI,EACA8nB,GAIJ3kB,EAAQ4nB,mCACJxD,GACIzB,EAAQpR,SACR1U,EACAmD,EAEZ,GAEA,IAAMf,EAAkC,IAAIC,WAAW,GACvDD,EAAgC,GAAK,EAErC,IAAMxG,EAAQ,CACV6G,2BAA4B,CACxBC,MAAO,CAACN,EAAgCtG,QACxC6G,GAAI,MAERC,kBAAmB,CACfF,MAAO,CAAC,uBACRC,GAAI,MAERE,uBAAwB,CACpBH,MAAO,CAACrF,GAAoByF,OAC5BH,GAAI,MAERI,0BAA2B,CACvBL,MAAO,CAAC,SACRC,GAAI,OAOZ,OAHAQ,EAAQvH,MAAQA,EAChBuH,EAAQE,qBAAuB,aAExBF,CACX,IKxKMqqB,GAAkB,CACpB5lB,cAAa,GACbwD,UAAS,GACTQ,MAAK,GACL/G,OAAM,GACNkf,UAAS,GACTI,cAAa,GACbmB,aAAY,GACZta,cAAa,GACbub,MAAK,GACLZ,kBAAiB,GACjBc,sBAAqB,GACrBzoB,kBAAiB,GACjByvB,WAAUA,GACVrL,mBAAkB,IAGhBsL,GAAmB,CACrB/gB,aAAYA,IAGVghB,GAAkB,CACpBC,KAAI,ICvCAC,GAAqBvwB,EAAAA,GAArBuwB,OAAQrhB,GAAalP,EAAAA,GAAbkP,SAyChB,SAASshB,GAAUjzB,GACf,IAAMkzB,EAnBV,SAAclzB,GAAU,IAAP0c,EAAChU,UAAA9B,OAAA,QAAAjC,IAAA+D,UAAA,GAAAA,UAAA,GAAG,EACjB,OAAQgU,GACJ,KAAK,EACD,OAAOjP,KAAK6B,IAAItP,GACpB,KAAK,EACD,OAAOyN,KAAKqB,KAAK9O,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAC5C,KAAK,EACD,OAAOyN,KAAKqB,KAAK9O,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAC1D,QAEI,IADA,IAAImzB,EAAM,EACD1mB,EAAI,EAAGA,EAAIiQ,EAAGjQ,IACnB0mB,GAAOnzB,EAAEyM,GAAKzM,EAAEyM,GAEpB,OAAOgB,KAAKqB,KAAKqkB,GAG7B,CAGgBC,CAAKpzB,GAMjB,OALY,IAARkzB,IACAlzB,EAAE,IAAMkzB,EACRlzB,EAAE,IAAMkzB,EACRlzB,EAAE,IAAMkzB,GAELA,CACX,CAiEC,IC1GKG,GAAa,CACfC,YAAa5O,GACb6O,cAAeZ,IAGba,GAAc,CAChBF,YAAa3O,GACb4O,cAAeV,GACfY,MChBa,CACb3hB,aFmH6B,WAG7B,OAAAzO,EAFA,SAAAyO,IAAc1O,EAAA,KAAA0O,EAAC,EAEf,OAAAxO,IAAA,mBAAAC,MAsCA,SAAwB+E,GAC6B,UAA7CA,EAAQ4N,gBAAgBwd,YAAYjG,OACpCnlB,EAAQ4N,gBAAkB,CAAC5N,EAAQ4N,kBAGvC5N,EAAQ4N,gBAAgBrQ,QAAQ,SAAA0O,GAO5B,IArKWof,EACbC,EAoKQrnB,GArKKonB,EAqKiBpf,EAAQsf,+BApKtCD,EAAOZ,GAAOc,aAAaH,GAAQ9uB,IAAI,SAAA7E,GAAC,OAAIyN,KAAKmU,MAAU,IAAJ5hB,E,IACxDoH,KAAK,KAEHwsB,GAmKCzhB,SAASoC,EAAQwf,eAAiB,CAC9BxnB,MAAAA,EACAynB,iBAAkB,GAClB7Q,OAAQ,KACR8Q,KAAM,KACNlgB,UAAW,KAEnB,GAGAzL,EAAQsO,iCAAiC/Q,QAAQ,SAAAquB,GAC7C,IAAMC,EACFD,EAAgB/c,8BACXC,wBAETjF,SAASgiB,GAAeH,iBAAiB5sB,KAAK8sB,EAClD,GAIA,IAAME,EAAY3mB,KAAK0T,KAAM7Y,EAAQyN,KAAOzN,EAAQwN,QAAW,GAC3Due,EAAa,EA0BjB,OAxBA9uB,OAAOC,KAAK2M,UAAUtM,QAAQ,SAAAsuB,GAC1B,IAAM5f,EAAUpC,SAASgiB,GAEzB5f,EAAQgF,eAAiBhF,EAAQyf,iBAAiBptB,OAClD2N,EAAQ0f,KAAO1f,EAAQgF,eAAiB6a,EACxC7f,EAAQ4O,OAASkR,EAEjBA,EAAa9f,EAAQ4O,OAAS5O,EAAQ0f,KAEtC,IAAMK,EAAgBhsB,EAAQF,UAAUoY,MACpCjM,EAAQ4O,OACRkR,GAGJ9f,EAAQR,UAAYpC,GAAS6E,OAAO8d,GAEpC,IAAMC,EAvJlB,SAAsCjsB,EAASwO,GAC3C,IAAMyd,EAAW,CAAC,EACZC,EACFlsB,EAAQmN,+BAA+Bgf,sBACrCC,EACFpsB,EAAQmN,+BAA+BE,yBAMrCgf,EAAuB7d,EAAyB,GAChD8d,EACF9d,EAAyBA,EAAyBlQ,OAAS,GACzDiuB,EACFF,EAAqBnW,sBAAsBC,qBAAqB5Z,IAC5DqT,QAEF4c,EACFF,EAAoBpW,sBAAsBC,qBAAqB5Z,IAC3DqT,QAGRqc,EAASQ,OAASF,EAIlBN,EAASS,QAAU,CACfR,EAAcS,aAAa,GAC3BT,EAAcS,aAAa,GAC3BT,EAAcU,sBAChBrwB,IAAIqT,QAENqc,EAASxI,WAAa,CAClBzjB,EAAQwN,QACRxN,EAAQyN,KACRe,EAAyBlQ,QAC3B/B,IAAIqT,QAEN,IApFWlY,EAAGoL,EAAG+pB,EACXC,EACAC,EACAC,EAiFAlkB,EAAcsjB,EAAiB9e,wBAAwB/Q,IAAIqT,QAC3Dqd,EAAsBnkB,EAAYoP,MAAM,EAAG,GAC3CgV,EAAmBpkB,EAAYoP,MAAM,EAAG,GAa9C,OAXA+T,EAASkB,YAAc,GAxFZz1B,EA0FLu1B,EA1FQnqB,EA0FaoqB,EA1FVL,EA0F4BZ,EAASkB,YAzFhDL,EAAKp1B,EAAE,GAAKoL,EAAE,GAAKpL,EAAE,GAAKoL,EAAE,GAC5BiqB,EAAKr1B,EAAE,GAAKoL,EAAE,GAAKpL,EAAE,GAAKoL,EAAE,GAC5BkqB,EAAKt1B,EAAE,GAAKoL,EAAE,GAAKpL,EAAE,GAAKoL,EAAE,GAClC+pB,EAAI,GAAKC,EACTD,EAAI,GAAKE,EACTF,EAAI,GAAKG,EAsFTf,EAASmB,UAAY,GAvDzB,SAAkB/Y,EAAGgZ,EAAGR,GACpBA,EAAI,GAAKxY,EAAE,GAAKgZ,EAAE,GAClBR,EAAI,GAAKxY,EAAE,GAAKgZ,EAAE,GAClBR,EAAI,GAAKxY,EAAE,GAAKgZ,EAAE,EACtB,CAoDIC,CAASd,EAAcD,EAAeN,EAASmB,WAC/CzC,GAAUsB,EAASmB,WACnBnB,EAASsB,UAAYN,EAChBluB,OAAOmuB,GACPnuB,OAAOktB,EAASmB,WAEdnB,CACX,CAgG6BuB,CACbxtB,EACAiM,EAAQyf,kBAGZzf,EAAQggB,SAAWA,CACvB,GAEOpiB,QACX,IAAC,CAvG4B,KCjG3B4jB,GAAa,CACfxC,cAAeT,G","sources":["webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/toArray.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/codeMeaningEquals.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/downloadDICOMData.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/helpers/graphicTypeEquals.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Bidirectional.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CircleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/CobbAngle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Angle.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/enums/Events.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone/Segmentation.js","webpack:///../../../node_modules/node_modules/tslib/tslib.es6.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/MeasurementReport.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Bidirectional.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Angle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CobbAngle.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/isValidCornerstoneTrackingIdentifier.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/CircleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/EllipticalROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RectangleROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Length.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/PlanarFreehandROI.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Probe.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/UltrasoundDirectional.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateSegmentation.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateToolState.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/Segmentation/generateLabelMaps2DFrom3D.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getReferencedFrameOfReferenceSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getReferencedSeriesSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getStructureSetModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/RTSS.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getPatientModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getRTSeriesModule.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/RTStruct/utilities/getRTROIObservationsSequence.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/Cornerstone3D/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/Segmentation.js","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/index.ts","webpack:///../../../node_modules/@cornerstonejs/adapters/src/adapters/VTKjs/index.ts"],"sourcesContent":["const toArray = x => (Array.isArray(x) ? x : [x]);\r\n\r\nexport { toArray };\r\n","/**\r\n * Returns a function that checks if a given content item's ConceptNameCodeSequence.CodeMeaning\r\n * matches the provided codeMeaningName.\r\n * @param codeMeaningName - The CodeMeaning to match against.\r\n * @returns A function that takes a content item and returns a boolean indicating whether the\r\n * content item's CodeMeaning matches the provided codeMeaningName.\r\n */\r\nconst codeMeaningEquals = (codeMeaningName: string) => {\r\n    return (contentItem: any) => {\r\n        return (\r\n            contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName\r\n        );\r\n    };\r\n};\r\n\r\nexport { codeMeaningEquals };\r\n","import { data } from \"dcmjs\";\r\nimport { Buffer } from \"buffer\";\r\nconst { datasetToDict } = data;\r\n\r\ninterface DicomDataset {\r\n    _meta?: any;\r\n    // other properties\r\n}\r\n\r\n/**\r\n * Trigger file download from an array buffer\r\n * @param bufferOrDataset - ArrayBuffer or DicomDataset\r\n * @param filename - name of the file to download\r\n */\r\nexport function downloadDICOMData(\r\n    bufferOrDataset: ArrayBuffer | DicomDataset,\r\n    filename: string\r\n) {\r\n    let blob;\r\n    if (bufferOrDataset instanceof ArrayBuffer) {\r\n        blob = new Blob([bufferOrDataset], { type: \"application/dicom\" });\r\n    } else {\r\n        if (!bufferOrDataset._meta) {\r\n            throw new Error(\"Dataset must have a _meta property\");\r\n        }\r\n\r\n        const buffer = Buffer.from(datasetToDict(bufferOrDataset).write());\r\n        blob = new Blob([buffer], { type: \"application/dicom\" });\r\n    }\r\n\r\n    const link = document.createElement(\"a\");\r\n    link.href = window.URL.createObjectURL(blob);\r\n    link.download = filename;\r\n    link.click();\r\n}\r\n","/**\r\n * Checks if a given content item's GraphicType property matches a specified value.\r\n * @param {string} graphicType - The value to compare the content item's GraphicType property to.\r\n * @returns {function} A function that takes a content item and returns a boolean indicating whether its GraphicType property matches the specified value.\r\n */\r\nconst graphicTypeEquals = graphicType => {\r\n    return contentItem => {\r\n        return contentItem && contentItem.GraphicType === graphicType;\r\n    };\r\n};\r\n\r\nexport { graphicTypeEquals };\r\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\r\n\r\nimport { toArray, codeMeaningEquals } from \"../helpers\";\r\n\r\nconst { TID1500, addAccessors } = utilities;\r\n\r\nconst { StructuredReport } = derivations;\r\n\r\nconst { Normalizer } = normalizers;\r\n\r\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\r\n\r\nconst { DicomMetaDictionary } = data;\r\n\r\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\r\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\r\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\r\n\r\nconst codeValueMatch = (group, code, oldCode) => {\r\n    const { ConceptNameCodeSequence } = group;\r\n    if (!ConceptNameCodeSequence) return;\r\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\r\n    return (\r\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\r\n            CodeValue == code.CodeValue) ||\r\n        (oldCode &&\r\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\r\n            CodeValue == oldCode.CodeValue)\r\n    );\r\n};\r\n\r\nfunction getTID300ContentItem(\r\n    tool,\r\n    toolType,\r\n    ReferencedSOPSequence,\r\n    toolClass\r\n) {\r\n    const args = toolClass.getTID300RepresentationArguments(tool);\r\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\r\n\r\n    const TID300Measurement = new toolClass.TID300Representation(args);\r\n\r\n    return TID300Measurement;\r\n}\r\n\r\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\r\n    const toolTypeData = toolData[toolType];\r\n    const toolClass =\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\r\n    if (\r\n        !toolTypeData ||\r\n        !toolTypeData.data ||\r\n        !toolTypeData.data.length ||\r\n        !toolClass\r\n    ) {\r\n        return;\r\n    }\r\n\r\n    // Loop through the array of tool instances\r\n    // for this tool\r\n    const Measurements = toolTypeData.data.map(tool => {\r\n        return getTID300ContentItem(\r\n            tool,\r\n            toolType,\r\n            ReferencedSOPSequence,\r\n            toolClass\r\n        );\r\n    });\r\n\r\n    return new TID1501MeasurementGroup(Measurements);\r\n}\r\n\r\nexport default class MeasurementReport {\r\n    static getSetupMeasurementData(MeasurementGroup) {\r\n        const { ContentSequence } = MeasurementGroup;\r\n\r\n        const contentSequenceArr = toArray(ContentSequence);\r\n        const findingGroup = contentSequenceArr.find(group =>\r\n            codeValueMatch(group, FINDING)\r\n        );\r\n        const findingSiteGroups =\r\n            contentSequenceArr.filter(group =>\r\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\r\n            ) || [];\r\n        const NUMGroup = contentSequenceArr.find(\r\n            group => group.ValueType === \"NUM\"\r\n        );\r\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\r\n            group => group.ValueType === \"SCOORD\"\r\n        );\r\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\r\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\r\n            ReferencedSOPSequence;\r\n\r\n        const defaultState = {\r\n            sopInstanceUid: ReferencedSOPInstanceUID,\r\n            frameIndex: ReferencedFrameNumber || 1,\r\n            complete: true,\r\n            finding: findingGroup\r\n                ? addAccessors(findingGroup.ConceptCodeSequence)\r\n                : undefined,\r\n            findingSites: findingSiteGroups.map(fsg => {\r\n                return addAccessors(fsg.ConceptCodeSequence);\r\n            })\r\n        };\r\n        if (defaultState.finding) {\r\n            defaultState.description = defaultState.finding.CodeMeaning;\r\n        }\r\n        const findingSite =\r\n            defaultState.findingSites && defaultState.findingSites[0];\r\n        if (findingSite) {\r\n            defaultState.location =\r\n                (findingSite[0] && findingSite[0].CodeMeaning) ||\r\n                findingSite.CodeMeaning;\r\n        }\r\n        return {\r\n            defaultState,\r\n            findingGroup,\r\n            findingSiteGroups,\r\n            NUMGroup,\r\n            SCOORDGroup,\r\n            ReferencedSOPSequence,\r\n            ReferencedSOPInstanceUID,\r\n            ReferencedFrameNumber\r\n        };\r\n    }\r\n\r\n    static generateReport(toolState, metadataProvider, options) {\r\n        // ToolState for array of imageIDs to a Report\r\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\r\n\r\n        let allMeasurementGroups = [];\r\n        const firstImageId = Object.keys(toolState)[0];\r\n        if (!firstImageId) {\r\n            throw new Error(\"No measurements provided.\");\r\n        }\r\n\r\n        /* Patient ID\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\r\n         */\r\n        const generalSeriesModule = metadataProvider.get(\r\n            \"generalSeriesModule\",\r\n            firstImageId\r\n        );\r\n\r\n        //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\r\n\r\n        // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\r\n        // which means that if the toolState is for multiple series, the report will have the incorrect\r\n        // SeriesInstanceUIDs\r\n        const { studyInstanceUID, seriesInstanceUID } = generalSeriesModule;\r\n\r\n        // Loop through each image in the toolData\r\n        Object.keys(toolState).forEach(imageId => {\r\n            const sopCommonModule = metadataProvider.get(\r\n                \"sopCommonModule\",\r\n                imageId\r\n            );\r\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\r\n            const toolData = toolState[imageId];\r\n            const toolTypes = Object.keys(toolData);\r\n\r\n            const ReferencedSOPSequence = {\r\n                ReferencedSOPClassUID: sopCommonModule.sopClassUID,\r\n                ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\r\n            };\r\n\r\n            if (\r\n                Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)\r\n            ) {\r\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\r\n            }\r\n\r\n            // Loop through each tool type for the image\r\n            const measurementGroups = [];\r\n\r\n            toolTypes.forEach(toolType => {\r\n                const group = getMeasurementGroup(\r\n                    toolType,\r\n                    toolData,\r\n                    ReferencedSOPSequence\r\n                );\r\n                if (group) {\r\n                    measurementGroups.push(group);\r\n                }\r\n            });\r\n\r\n            allMeasurementGroups =\r\n                allMeasurementGroups.concat(measurementGroups);\r\n        });\r\n\r\n        const MeasurementReport = new TID1500MeasurementReport(\r\n            { TID1501MeasurementGroups: allMeasurementGroups },\r\n            options\r\n        );\r\n\r\n        // TODO: what is the correct metaheader\r\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\r\n        // TODO: move meta creation to happen in derivations.js\r\n        const fileMetaInformationVersionArray = new Uint8Array(2);\r\n        fileMetaInformationVersionArray[1] = 1;\r\n\r\n        const derivationSourceDataset = {\r\n            StudyInstanceUID: studyInstanceUID,\r\n            SeriesInstanceUID: seriesInstanceUID\r\n            //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\r\n            //SOPClassUID: sopClassUID,\r\n        };\r\n\r\n        const _meta = {\r\n            FileMetaInformationVersion: {\r\n                Value: [fileMetaInformationVersionArray.buffer],\r\n                vr: \"OB\"\r\n            },\r\n            //MediaStorageSOPClassUID\r\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\r\n            TransferSyntaxUID: {\r\n                Value: [\"1.2.840.10008.1.2.1\"],\r\n                vr: \"UI\"\r\n            },\r\n            ImplementationClassUID: {\r\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\r\n                vr: \"UI\"\r\n            },\r\n            ImplementationVersionName: {\r\n                Value: [\"dcmjs\"],\r\n                vr: \"SH\"\r\n            }\r\n        };\r\n\r\n        const _vrMap = {\r\n            PixelData: \"OW\"\r\n        };\r\n\r\n        derivationSourceDataset._meta = _meta;\r\n        derivationSourceDataset._vrMap = _vrMap;\r\n\r\n        const report = new StructuredReport([derivationSourceDataset]);\r\n\r\n        const contentItem = MeasurementReport.contentItem(\r\n            derivationSourceDataset\r\n        );\r\n\r\n        // Merge the derived dataset with the content from the Measurement Report\r\n        report.dataset = Object.assign(report.dataset, contentItem);\r\n        report.dataset._meta = _meta;\r\n        report.dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n\r\n        return report;\r\n    }\r\n\r\n    /**\r\n     * Generate Cornerstone tool state from dataset\r\n     * @param {object} dataset dataset\r\n     * @param {object} hooks\r\n     * @param {function} hooks.getToolClass Function to map dataset to a tool class\r\n     * @returns\r\n     */\r\n    static generateToolState(dataset, hooks = {}) {\r\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\r\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\r\n            throw new Error(\r\n                \"This package can currently only interpret DICOM SR TID 1500\"\r\n            );\r\n        }\r\n\r\n        const REPORT = \"Imaging Measurements\";\r\n        const GROUP = \"Measurement Group\";\r\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\r\n\r\n        // Identify the Imaging Measurements\r\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\r\n            codeMeaningEquals(REPORT)\r\n        );\r\n\r\n        // Retrieve the Measurements themselves\r\n        const measurementGroups = toArray(\r\n            imagingMeasurementContent.ContentSequence\r\n        ).filter(codeMeaningEquals(GROUP));\r\n\r\n        // For each of the supported measurement types, compute the measurement data\r\n        const measurementData = {};\r\n\r\n        const cornerstoneToolClasses =\r\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\r\n\r\n        const registeredToolClasses = [];\r\n\r\n        Object.keys(cornerstoneToolClasses).forEach(key => {\r\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\r\n            measurementData[key] = [];\r\n        });\r\n\r\n        measurementGroups.forEach(measurementGroup => {\r\n            const measurementGroupContentSequence = toArray(\r\n                measurementGroup.ContentSequence\r\n            );\r\n\r\n            const TrackingIdentifierGroup =\r\n                measurementGroupContentSequence.find(\r\n                    contentItem =>\r\n                        contentItem.ConceptNameCodeSequence.CodeMeaning ===\r\n                        TRACKING_IDENTIFIER\r\n                );\r\n\r\n            const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\r\n\r\n            const toolClass = hooks.getToolClass\r\n                ? hooks.getToolClass(\r\n                      measurementGroup,\r\n                      dataset,\r\n                      registeredToolClasses\r\n                  )\r\n                : registeredToolClasses.find(tc =>\r\n                      tc.isValidCornerstoneTrackingIdentifier(\r\n                          TrackingIdentifierValue\r\n                      )\r\n                  );\r\n\r\n            if (toolClass) {\r\n                const measurement =\r\n                    toolClass.getMeasurementData(measurementGroup);\r\n\r\n                console.log(`=== ${toolClass.toolType} ===`);\r\n                console.log(measurement);\r\n\r\n                measurementData[toolClass.toolType].push(measurement);\r\n            }\r\n        });\r\n\r\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\r\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\r\n        return measurementData;\r\n    }\r\n\r\n    static registerTool(toolClass) {\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\r\n            toolClass.utilityToolType\r\n        ] = toolClass;\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\r\n            toolClass.toolType\r\n        ] = toolClass;\r\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\r\n            toolClass.utilityToolType;\r\n    }\r\n}\r\n\r\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\r\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\r\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\r\n","export default \"cornerstoneTools@^4.0.0\";\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Length: TID300Length } = utilities.TID300;\r\n\r\nconst LENGTH = \"Length\";\r\n\r\nclass Length {\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, NUMGroup, SCOORDGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            length: NUMGroup.MeasuredValueSequence.NumericValue,\r\n            toolType: Length.toolType,\r\n            handles: {\r\n                start: {},\r\n                end: {},\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            }\r\n        };\r\n\r\n        [\r\n            state.handles.start.x,\r\n            state.handles.start.y,\r\n            state.handles.end.x,\r\n            state.handles.end.y\r\n        ] = SCOORDGroup.GraphicData;\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { handles, finding, findingSites } = tool;\r\n        const point1 = handles.start;\r\n        const point2 = handles.end;\r\n        const distance = tool.length;\r\n\r\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            distance,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nLength.toolType = LENGTH;\r\nLength.utilityToolType = LENGTH;\r\nLength.TID300Representation = TID300Length;\r\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === LENGTH;\r\n};\r\n\r\nMeasurementReport.registerTool(Length);\r\n\r\nexport default Length;\r\n","import { utilities } from \"dcmjs\";\r\n\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Polyline: TID300Polyline } = utilities.TID300;\r\n\r\nclass FreehandRoi {\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, SCOORDGroup, NUMGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            toolType: FreehandRoi.toolType,\r\n            handles: {\r\n                points: [],\r\n                textBox: {\r\n                    active: false,\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            },\r\n            cachedStats: {\r\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\r\n            },\r\n            color: undefined,\r\n            invalidated: true\r\n        };\r\n        const { GraphicData } = SCOORDGroup;\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            state.handles.points.push({\r\n                x: GraphicData[i],\r\n                y: GraphicData[i + 1]\r\n            });\r\n        }\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { handles, finding, findingSites, cachedStats = {} } = tool;\r\n        const { points } = handles;\r\n        const { area = 0, perimeter = 0 } = cachedStats;\r\n\r\n        const trackingIdentifierTextValue =\r\n            \"cornerstoneTools@^4.0.0:FreehandRoi\";\r\n\r\n        return {\r\n            points,\r\n            area,\r\n            perimeter,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nFreehandRoi.toolType = \"FreehandRoi\";\r\nFreehandRoi.utilityToolType = \"FreehandRoi\";\r\nFreehandRoi.TID300Representation = TID300Polyline;\r\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === FreehandRoi.toolType;\r\n};\r\n\r\nMeasurementReport.registerTool(FreehandRoi);\r\n\r\nexport default FreehandRoi;\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\nimport { toArray } from \"../helpers\";\r\n\r\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\r\n\r\nconst BIDIRECTIONAL = \"Bidirectional\";\r\nconst LONG_AXIS = \"Long Axis\";\r\nconst SHORT_AXIS = \"Short Axis\";\r\nconst FINDING = \"121071\";\r\nconst FINDING_SITE = \"G-C0E3\";\r\n\r\nclass Bidirectional {\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { ContentSequence } = MeasurementGroup;\r\n\r\n        const findingGroup = toArray(ContentSequence).find(\r\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING\r\n        );\r\n\r\n        const findingSiteGroups = toArray(ContentSequence).filter(\r\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE\r\n        );\r\n\r\n        const longAxisNUMGroup = toArray(ContentSequence).find(\r\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\r\n        );\r\n\r\n        const longAxisSCOORDGroup = toArray(\r\n            longAxisNUMGroup.ContentSequence\r\n        ).find(group => group.ValueType === \"SCOORD\");\r\n\r\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\r\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\r\n        );\r\n\r\n        const shortAxisSCOORDGroup = toArray(\r\n            shortAxisNUMGroup.ContentSequence\r\n        ).find(group => group.ValueType === \"SCOORD\");\r\n\r\n        const { ReferencedSOPSequence } = longAxisSCOORDGroup.ContentSequence;\r\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\r\n            ReferencedSOPSequence;\r\n\r\n        // Long axis\r\n\r\n        const longestDiameter = String(\r\n            longAxisNUMGroup.MeasuredValueSequence.NumericValue\r\n        );\r\n\r\n        const shortestDiameter = String(\r\n            shortAxisNUMGroup.MeasuredValueSequence.NumericValue\r\n        );\r\n\r\n        const bottomRight = {\r\n            x: Math.max(\r\n                longAxisSCOORDGroup.GraphicData[0],\r\n                longAxisSCOORDGroup.GraphicData[2],\r\n                shortAxisSCOORDGroup.GraphicData[0],\r\n                shortAxisSCOORDGroup.GraphicData[2]\r\n            ),\r\n            y: Math.max(\r\n                longAxisSCOORDGroup.GraphicData[1],\r\n                longAxisSCOORDGroup.GraphicData[3],\r\n                shortAxisSCOORDGroup.GraphicData[1],\r\n                shortAxisSCOORDGroup.GraphicData[3]\r\n            )\r\n        };\r\n\r\n        const state = {\r\n            sopInstanceUid: ReferencedSOPInstanceUID,\r\n            frameIndex: ReferencedFrameNumber || 1,\r\n            toolType: Bidirectional.toolType,\r\n            active: false,\r\n            handles: {\r\n                start: {\r\n                    x: longAxisSCOORDGroup.GraphicData[0],\r\n                    y: longAxisSCOORDGroup.GraphicData[1],\r\n                    drawnIndependently: false,\r\n                    allowedOutsideImage: false,\r\n                    active: false,\r\n                    highlight: false,\r\n                    index: 0\r\n                },\r\n                end: {\r\n                    x: longAxisSCOORDGroup.GraphicData[2],\r\n                    y: longAxisSCOORDGroup.GraphicData[3],\r\n                    drawnIndependently: false,\r\n                    allowedOutsideImage: false,\r\n                    active: false,\r\n                    highlight: false,\r\n                    index: 1\r\n                },\r\n                perpendicularStart: {\r\n                    x: shortAxisSCOORDGroup.GraphicData[0],\r\n                    y: shortAxisSCOORDGroup.GraphicData[1],\r\n                    drawnIndependently: false,\r\n                    allowedOutsideImage: false,\r\n                    active: false,\r\n                    highlight: false,\r\n                    index: 2\r\n                },\r\n                perpendicularEnd: {\r\n                    x: shortAxisSCOORDGroup.GraphicData[2],\r\n                    y: shortAxisSCOORDGroup.GraphicData[3],\r\n                    drawnIndependently: false,\r\n                    allowedOutsideImage: false,\r\n                    active: false,\r\n                    highlight: false,\r\n                    index: 3\r\n                },\r\n                textBox: {\r\n                    highlight: false,\r\n                    hasMoved: true,\r\n                    active: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true,\r\n                    x: bottomRight.x + 10,\r\n                    y: bottomRight.y + 10\r\n                }\r\n            },\r\n            invalidated: false,\r\n            isCreating: false,\r\n            longestDiameter,\r\n            shortestDiameter,\r\n            toolName: \"Bidirectional\",\r\n            visible: true,\r\n            finding: findingGroup\r\n                ? findingGroup.ConceptCodeSequence\r\n                : undefined,\r\n            findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { start, end, perpendicularStart, perpendicularEnd } =\r\n            tool.handles;\r\n        const { shortestDiameter, longestDiameter, finding, findingSites } =\r\n            tool;\r\n\r\n        const trackingIdentifierTextValue =\r\n            \"cornerstoneTools@^4.0.0:Bidirectional\";\r\n\r\n        return {\r\n            longAxis: {\r\n                point1: start,\r\n                point2: end\r\n            },\r\n            shortAxis: {\r\n                point1: perpendicularStart,\r\n                point2: perpendicularEnd\r\n            },\r\n            longAxisLength: longestDiameter,\r\n            shortAxisLength: shortestDiameter,\r\n            trackingIdentifierTextValue,\r\n            finding: finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nBidirectional.toolType = BIDIRECTIONAL;\r\nBidirectional.utilityToolType = BIDIRECTIONAL;\r\nBidirectional.TID300Representation = TID300Bidirectional;\r\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === BIDIRECTIONAL;\r\n};\r\n\r\nMeasurementReport.registerTool(Bidirectional);\r\n\r\nexport default Bidirectional;\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\r\n\r\nconst ELLIPTICALROI = \"EllipticalRoi\";\r\n\r\nclass EllipticalRoi {\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, NUMGroup, SCOORDGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const majorAxis = [\r\n            { x: GraphicData[0], y: GraphicData[1] },\r\n            { x: GraphicData[2], y: GraphicData[3] }\r\n        ];\r\n        const minorAxis = [\r\n            { x: GraphicData[4], y: GraphicData[5] },\r\n            { x: GraphicData[6], y: GraphicData[7] }\r\n        ];\r\n\r\n        // Calculate two opposite corners of box defined by two axes.\r\n\r\n        const minorAxisLength = Math.sqrt(\r\n            Math.pow(minorAxis[0].x - minorAxis[1].x, 2) +\r\n                Math.pow(minorAxis[0].y - minorAxis[1].y, 2)\r\n        );\r\n\r\n        const minorAxisDirection = {\r\n            x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\r\n            y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\r\n        };\r\n\r\n        const halfMinorAxisLength = minorAxisLength / 2;\r\n\r\n        // First end point of major axis + half minor axis vector\r\n        const corner1 = {\r\n            x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\r\n            y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\r\n        };\r\n\r\n        // Second end point of major axis - half of minor axis vector\r\n        const corner2 = {\r\n            x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\r\n            y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\r\n        };\r\n        const state = {\r\n            ...defaultState,\r\n            toolType: EllipticalRoi.toolType,\r\n            active: false,\r\n            cachedStats: {\r\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\r\n            },\r\n            handles: {\r\n                end: {\r\n                    x: corner1.x,\r\n                    y: corner1.y,\r\n                    highlight: false,\r\n                    active: false\r\n                },\r\n                initialRotation: 0,\r\n                start: {\r\n                    x: corner2.x,\r\n                    y: corner2.y,\r\n                    highlight: false,\r\n                    active: false\r\n                },\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            },\r\n            invalidated: true,\r\n            visible: true\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\r\n        const { start, end } = handles;\r\n        const { area } = cachedStats;\r\n\r\n        const halfXLength = Math.abs(start.x - end.x) / 2;\r\n        const halfYLength = Math.abs(start.y - end.y) / 2;\r\n\r\n        const points = [];\r\n\r\n        const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };\r\n\r\n        if (halfXLength > halfYLength) {\r\n            // X-axis major\r\n            // Major axis\r\n            points.push({ x: center.x - halfXLength, y: center.y });\r\n            points.push({ x: center.x + halfXLength, y: center.y });\r\n            // Minor axis\r\n            points.push({ x: center.x, y: center.y - halfYLength });\r\n            points.push({ x: center.x, y: center.y + halfYLength });\r\n        } else {\r\n            // Y-axis major\r\n            // Major axis\r\n            points.push({ x: center.x, y: center.y - halfYLength });\r\n            points.push({ x: center.x, y: center.y + halfYLength });\r\n            // Minor axis\r\n            points.push({ x: center.x - halfXLength, y: center.y });\r\n            points.push({ x: center.x + halfXLength, y: center.y });\r\n        }\r\n\r\n        const trackingIdentifierTextValue =\r\n            \"cornerstoneTools@^4.0.0:EllipticalRoi\";\r\n\r\n        return {\r\n            area,\r\n            points,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nEllipticalRoi.toolType = ELLIPTICALROI;\r\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\r\nEllipticalRoi.TID300Representation = TID300Ellipse;\r\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === ELLIPTICALROI;\r\n};\r\n\r\nMeasurementReport.registerTool(EllipticalRoi);\r\n\r\nexport default EllipticalRoi;\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Circle: TID300Circle } = utilities.TID300;\r\n\r\nconst CIRCLEROI = \"CircleRoi\";\r\n\r\nclass CircleRoi {\r\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, NUMGroup, SCOORDGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const center = { x: GraphicData[0], y: GraphicData[1] };\r\n        const end = { x: GraphicData[2], y: GraphicData[3] };\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            toolType: CircleRoi.toolType,\r\n            active: false,\r\n            cachedStats: {\r\n                area: NUMGroup\r\n                    ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                    : 0,\r\n                // Dummy values to be updated by cornerstone\r\n                radius: 0,\r\n                perimeter: 0\r\n            },\r\n            handles: {\r\n                end: {\r\n                    ...end,\r\n                    highlight: false,\r\n                    active: false\r\n                },\r\n                initialRotation: 0,\r\n                start: {\r\n                    ...center,\r\n                    highlight: false,\r\n                    active: false\r\n                },\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            },\r\n            invalidated: true,\r\n            visible: true\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\r\n     *\r\n     * @param {Object} tool\r\n     * @returns\r\n     */\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\r\n        const { start: center, end } = handles;\r\n        const { area, radius } = cachedStats;\r\n\r\n        const perimeter = 2 * Math.PI * radius;\r\n        const points = [];\r\n\r\n        points.push(center);\r\n        points.push(end);\r\n\r\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\r\n\r\n        return {\r\n            area,\r\n            perimeter,\r\n            radius,\r\n            points,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nCircleRoi.toolType = CIRCLEROI;\r\nCircleRoi.utilityToolType = CIRCLEROI;\r\nCircleRoi.TID300Representation = TID300Circle;\r\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === CIRCLEROI;\r\n};\r\n\r\nMeasurementReport.registerTool(CircleRoi);\r\n\r\nexport default CircleRoi;\r\n","import { utilities } from \"dcmjs\";\r\n\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Point: TID300Point } = utilities.TID300;\r\n\r\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\r\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\r\n\r\nclass ArrowAnnotate {\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, SCOORDGroup, findingGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const text = findingGroup.ConceptCodeSequence.CodeMeaning;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            toolType: ArrowAnnotate.toolType,\r\n            active: false,\r\n            handles: {\r\n                start: {\r\n                    x: GraphicData[0],\r\n                    y: GraphicData[1],\r\n                    highlight: true,\r\n                    active: false\r\n                },\r\n                // Use a generic offset if the stored data doesn't have the endpoint, otherwise\r\n                // use the actual endpoint.\r\n                end: {\r\n                    x:\r\n                        GraphicData.length == 4\r\n                            ? GraphicData[2]\r\n                            : GraphicData[0] + 20,\r\n                    y:\r\n                        GraphicData.length == 4\r\n                            ? GraphicData[3]\r\n                            : GraphicData[1] + 20,\r\n                    highlight: true,\r\n                    active: false\r\n                },\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            },\r\n            invalidated: true,\r\n            text,\r\n            visible: true\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const points = [tool.handles.start, tool.handles.end];\r\n\r\n        let { finding, findingSites } = tool;\r\n\r\n        const TID300RepresentationArguments = {\r\n            points,\r\n            trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\r\n            findingSites: findingSites || []\r\n        };\r\n\r\n        // If freetext finding isn't present, add it from the tool text.\r\n        if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\r\n            finding = {\r\n                CodeValue: CORNERSTONEFREETEXT,\r\n                CodingSchemeDesignator: \"CST4\",\r\n                CodeMeaning: tool.text\r\n            };\r\n        }\r\n\r\n        TID300RepresentationArguments.finding = finding;\r\n\r\n        return TID300RepresentationArguments;\r\n    }\r\n}\r\n\r\nArrowAnnotate.toolType = ARROW_ANNOTATE;\r\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\r\nArrowAnnotate.TID300Representation = TID300Point;\r\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === ARROW_ANNOTATE;\r\n};\r\n\r\nMeasurementReport.registerTool(ArrowAnnotate);\r\n\r\nexport default ArrowAnnotate;\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\r\n\r\nconst COBB_ANGLE = \"CobbAngle\";\r\n\r\nclass CobbAngle {\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, NUMGroup, SCOORDGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\r\n            toolType: CobbAngle.toolType,\r\n            handles: {\r\n                start: {},\r\n                end: {},\r\n                start2: {\r\n                    highlight: true,\r\n                    drawnIndependently: true\r\n                },\r\n                end2: {\r\n                    highlight: true,\r\n                    drawnIndependently: true\r\n                },\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            }\r\n        };\r\n\r\n        [\r\n            state.handles.start.x,\r\n            state.handles.start.y,\r\n            state.handles.end.x,\r\n            state.handles.end.y,\r\n            state.handles.start2.x,\r\n            state.handles.start2.y,\r\n            state.handles.end2.x,\r\n            state.handles.end2.y\r\n        ] = SCOORDGroup.GraphicData;\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { handles, finding, findingSites } = tool;\r\n        const point1 = handles.start;\r\n        const point2 = handles.end;\r\n        const point3 = handles.start2;\r\n        const point4 = handles.end2;\r\n        const rAngle = tool.rAngle;\r\n\r\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            point3,\r\n            point4,\r\n            rAngle,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nCobbAngle.toolType = COBB_ANGLE;\r\nCobbAngle.utilityToolType = COBB_ANGLE;\r\nCobbAngle.TID300Representation = TID300CobbAngle;\r\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === COBB_ANGLE;\r\n};\r\n\r\nMeasurementReport.registerTool(CobbAngle);\r\n\r\nexport default CobbAngle;\r\n","import { utilities } from \"dcmjs\";\r\n\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Angle: TID300Angle } = utilities.TID300;\r\n\r\nconst ANGLE = \"Angle\";\r\n\r\nclass Angle {\r\n    /**\r\n     * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\r\n     */\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, NUMGroup, SCOORDGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\r\n            toolType: Angle.toolType,\r\n            handles: {\r\n                start: {},\r\n                middle: {},\r\n                end: {},\r\n                textBox: {\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                }\r\n            }\r\n        };\r\n\r\n        [\r\n            state.handles.start.x,\r\n            state.handles.start.y,\r\n            state.handles.middle.x,\r\n            state.handles.middle.y,\r\n            state.handles.middle.x,\r\n            state.handles.middle.y,\r\n            state.handles.end.x,\r\n            state.handles.end.y\r\n        ] = SCOORDGroup.GraphicData;\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { handles, finding, findingSites } = tool;\r\n        const point1 = handles.start;\r\n        const point2 = handles.middle;\r\n        const point3 = handles.middle;\r\n        const point4 = handles.end;\r\n        const rAngle = tool.rAngle;\r\n\r\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            point3,\r\n            point4,\r\n            rAngle,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nAngle.toolType = ANGLE;\r\nAngle.utilityToolType = ANGLE;\r\nAngle.TID300Representation = TID300Angle;\r\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === ANGLE;\r\n};\r\n\r\nMeasurementReport.registerTool(Angle);\r\n\r\nexport default Angle;\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\r\n\r\nconst { Polyline: TID300Polyline } = utilities.TID300;\r\n\r\nclass RectangleRoi {\r\n    static getMeasurementData(MeasurementGroup) {\r\n        const { defaultState, SCOORDGroup, NUMGroup } =\r\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\r\n\r\n        const state = {\r\n            ...defaultState,\r\n            toolType: RectangleRoi.toolType,\r\n            handles: {\r\n                start: {},\r\n                end: {},\r\n                textBox: {\r\n                    active: false,\r\n                    hasMoved: false,\r\n                    movesIndependently: false,\r\n                    drawnIndependently: true,\r\n                    allowedOutsideImage: true,\r\n                    hasBoundingBox: true\r\n                },\r\n                initialRotation: 0\r\n            },\r\n            cachedStats: {\r\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\r\n            },\r\n            color: undefined,\r\n            invalidated: true\r\n        };\r\n        const intermediate = {};\r\n\r\n        [\r\n            state.handles.start.x,\r\n            state.handles.start.y,\r\n            intermediate.x,\r\n            intermediate.y,\r\n            state.handles.end.x,\r\n            state.handles.end.y\r\n        ] = SCOORDGroup.GraphicData;\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool) {\r\n        const { finding, findingSites, cachedStats = {}, handles } = tool;\r\n        const { start, end } = handles;\r\n        const points = [\r\n            start,\r\n            { x: start.x, y: end.y },\r\n            end,\r\n            { x: end.x, y: start.y }\r\n        ];\r\n        const { area, perimeter } = cachedStats;\r\n\r\n        const trackingIdentifierTextValue =\r\n            \"cornerstoneTools@^4.0.0:RectangleRoi\";\r\n\r\n        return {\r\n            points,\r\n            area,\r\n            perimeter,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nRectangleRoi.toolType = \"RectangleRoi\";\r\nRectangleRoi.utilityToolType = \"RectangleRoi\";\r\nRectangleRoi.TID300Representation = TID300Polyline;\r\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === RectangleRoi.toolType;\r\n};\r\n\r\nMeasurementReport.registerTool(RectangleRoi);\r\n\r\nexport default RectangleRoi;\r\n","import { log, utilities, normalizers, derivations } from \"dcmjs\";\r\nimport ndarray from \"ndarray\";\r\n\r\nconst {\r\n    rotateDirectionCosinesInPlane,\r\n    flipImageOrientationPatient: flipIOP,\r\n    flipMatrix2D,\r\n    rotateMatrix902D\r\n} = utilities.orientation;\r\n\r\nconst { datasetToBlob, BitArray, DicomMessage, DicomMetaDictionary } =\r\n    utilities;\r\n\r\nconst { Normalizer } = normalizers;\r\nconst { Segmentation: SegmentationDerivation } = derivations;\r\n\r\nconst Segmentation = {\r\n    generateSegmentation,\r\n    generateToolState\r\n};\r\n\r\nexport default Segmentation;\r\n\r\n/**\r\n *\r\n * @typedef {Object} BrushData\r\n * @property {Object} toolState - The cornerstoneTools global toolState.\r\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\r\n *                                 seriesInstanceUid.\r\n */\r\n\r\n/**\r\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\r\n * imageIds, images and the cornerstoneTools brushData.\r\n *\r\n * @param  {object[]} images    An array of the cornerstone image objects.\r\n * @param  {BrushData} brushData and object containing the brushData.\r\n * @returns {type}           description\r\n */\r\nfunction generateSegmentation(\r\n    images,\r\n    brushData,\r\n    options = { includeSliceSpacing: true }\r\n) {\r\n    const { toolState, segments } = brushData;\r\n\r\n    // Calculate the dimensions of the data cube.\r\n    const image0 = images[0];\r\n\r\n    const dims = {\r\n        x: image0.columns,\r\n        y: image0.rows,\r\n        z: images.length\r\n    };\r\n\r\n    dims.xy = dims.x * dims.y;\r\n\r\n    const numSegments = _getSegCount(seg, segments);\r\n\r\n    if (!numSegments) {\r\n        throw new Error(\"No segments to export!\");\r\n    }\r\n\r\n    const isMultiframe = image0.imageId.includes(\"?frame\");\r\n    const seg = _createSegFromImages(images, isMultiframe, options);\r\n\r\n    const { referencedFramesPerSegment, segmentIndicies } =\r\n        _getNumberOfFramesPerSegment(toolState, images, segments);\r\n\r\n    let NumberOfFrames = 0;\r\n\r\n    for (let i = 0; i < referencedFramesPerSegment.length; i++) {\r\n        NumberOfFrames += referencedFramesPerSegment[i].length;\r\n    }\r\n\r\n    seg.setNumberOfFrames(NumberOfFrames);\r\n\r\n    for (let i = 0; i < segmentIndicies.length; i++) {\r\n        const segmentIndex = segmentIndicies[i];\r\n        const referencedFrameIndicies = referencedFramesPerSegment[i];\r\n\r\n        // Frame numbers start from 1.\r\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\r\n            return element + 1;\r\n        });\r\n\r\n        const segment = segments[segmentIndex];\r\n\r\n        seg.addSegment(\r\n            segment,\r\n            _extractCornerstoneToolsPixelData(\r\n                segmentIndex,\r\n                referencedFrameIndicies,\r\n                toolState,\r\n                images,\r\n                dims\r\n            ),\r\n            referencedFrameNumbers\r\n        );\r\n    }\r\n\r\n    seg.bitPackPixelData();\r\n\r\n    const segBlob = datasetToBlob(seg.dataset);\r\n\r\n    return segBlob;\r\n}\r\n\r\nfunction _extractCornerstoneToolsPixelData(\r\n    segmentIndex,\r\n    referencedFrames,\r\n    toolState,\r\n    images,\r\n    dims\r\n) {\r\n    const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\r\n\r\n    let pixelDataIndex = 0;\r\n\r\n    for (let i = 0; i < referencedFrames.length; i++) {\r\n        const frame = referencedFrames[i];\r\n\r\n        const imageId = images[frame].imageId;\r\n        const imageIdSpecificToolState = toolState[imageId];\r\n\r\n        const brushPixelData =\r\n            imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\r\n\r\n        for (let p = 0; p < brushPixelData.length; p++) {\r\n            pixelData[pixelDataIndex] = brushPixelData[p];\r\n            pixelDataIndex++;\r\n        }\r\n    }\r\n\r\n    return pixelData;\r\n}\r\n\r\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\r\n    const segmentIndicies = [];\r\n    const referencedFramesPerSegment = [];\r\n\r\n    for (let i = 0; i < segments.length; i++) {\r\n        if (segments[i]) {\r\n            segmentIndicies.push(i);\r\n            referencedFramesPerSegment.push([]);\r\n        }\r\n    }\r\n\r\n    for (let z = 0; z < images.length; z++) {\r\n        const imageId = images[z].imageId;\r\n        const imageIdSpecificToolState = toolState[imageId];\r\n\r\n        for (let i = 0; i < segmentIndicies.length; i++) {\r\n            const segIdx = segmentIndicies[i];\r\n\r\n            if (\r\n                imageIdSpecificToolState &&\r\n                imageIdSpecificToolState.brush &&\r\n                imageIdSpecificToolState.brush.data &&\r\n                imageIdSpecificToolState.brush.data[segIdx] &&\r\n                imageIdSpecificToolState.brush.data[segIdx].pixelData\r\n            ) {\r\n                referencedFramesPerSegment[i].push(z);\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        referencedFramesPerSegment,\r\n        segmentIndicies\r\n    };\r\n}\r\n\r\nfunction _getSegCount(seg, segments) {\r\n    let numSegments = 0;\r\n\r\n    for (let i = 0; i < segments.length; i++) {\r\n        if (segments[i]) {\r\n            numSegments++;\r\n        }\r\n    }\r\n\r\n    return numSegments;\r\n}\r\n\r\n/**\r\n * _createSegFromImages - description\r\n *\r\n * @param  {Object[]} images    An array of the cornerstone image objects.\r\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\r\n * @returns {Object}              The Seg derived dataSet.\r\n */\r\nfunction _createSegFromImages(images, isMultiframe, options) {\r\n    const datasets = [];\r\n\r\n    if (isMultiframe) {\r\n        const image = images[0];\r\n        const arrayBuffer = image.data.byteArray.buffer;\r\n\r\n        const dicomData = DicomMessage.readFile(arrayBuffer);\r\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n\r\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n\r\n        datasets.push(dataset);\r\n    } else {\r\n        for (let i = 0; i < images.length; i++) {\r\n            const image = images[i];\r\n            const arrayBuffer = image.data.byteArray.buffer;\r\n            const dicomData = DicomMessage.readFile(arrayBuffer);\r\n            const dataset = DicomMetaDictionary.naturalizeDataset(\r\n                dicomData.dict\r\n            );\r\n\r\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n            datasets.push(dataset);\r\n        }\r\n    }\r\n\r\n    const multiframe = Normalizer.normalizeToDataset(datasets);\r\n\r\n    return new SegmentationDerivation([multiframe], options);\r\n}\r\n\r\n/**\r\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\r\n * derive cornerstoneTools toolState and brush metadata.\r\n *\r\n * @param  {string[]} imageIds    An array of the imageIds.\r\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\r\n * @param {*} metadataProvider\r\n * @returns {Object}  The toolState and an object from which the\r\n *                    segment metadata can be derived.\r\n */\r\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\r\n    const dicomData = DicomMessage.readFile(arrayBuffer);\r\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\r\n\r\n    const imagePlaneModule = metadataProvider.get(\r\n        \"imagePlaneModule\",\r\n        imageIds[0]\r\n    );\r\n\r\n    if (!imagePlaneModule) {\r\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\r\n    }\r\n\r\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\r\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\r\n        : [\r\n              imagePlaneModule.rowCosines.x,\r\n              imagePlaneModule.rowCosines.y,\r\n              imagePlaneModule.rowCosines.z,\r\n              imagePlaneModule.columnCosines.x,\r\n              imagePlaneModule.columnCosines.y,\r\n              imagePlaneModule.columnCosines.z\r\n          ];\r\n\r\n    // Get IOP from ref series, compute supported orientations:\r\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\r\n\r\n    const SharedFunctionalGroupsSequence =\r\n        multiframe.SharedFunctionalGroupsSequence;\r\n\r\n    const sharedImageOrientationPatient =\r\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n                  .ImageOrientationPatient\r\n            : undefined;\r\n\r\n    const sliceLength = multiframe.Columns * multiframe.Rows;\r\n    const segMetadata = getSegmentMetadata(multiframe);\r\n    const pixelData = unpackPixelData(multiframe);\r\n\r\n    const PerFrameFunctionalGroupsSequence =\r\n        multiframe.PerFrameFunctionalGroupsSequence;\r\n\r\n    const toolState = {};\r\n\r\n    let inPlane = true;\r\n\r\n    for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\r\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\r\n\r\n        const ImageOrientationPatientI =\r\n            sharedImageOrientationPatient ||\r\n            PerFrameFunctionalGroups.PlaneOrientationSequence\r\n                .ImageOrientationPatient;\r\n\r\n        const pixelDataI2D = ndarray(\r\n            new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength),\r\n            [multiframe.Rows, multiframe.Columns]\r\n        );\r\n\r\n        const alignedPixelDataI = alignPixelDataWithSourceData(\r\n            pixelDataI2D,\r\n            ImageOrientationPatientI,\r\n            validOrientations\r\n        );\r\n\r\n        if (!alignedPixelDataI) {\r\n            console.warn(\r\n                \"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \"\r\n            );\r\n            inPlane = false;\r\n            break;\r\n        }\r\n\r\n        const segmentIndex =\r\n            PerFrameFunctionalGroups.SegmentIdentificationSequence\r\n                .ReferencedSegmentNumber - 1;\r\n\r\n        let SourceImageSequence;\r\n        if (\r\n            SharedFunctionalGroupsSequence.DerivationImageSequence &&\r\n            SharedFunctionalGroupsSequence.DerivationImageSequence\r\n                .SourceImageSequence\r\n        ) {\r\n            SourceImageSequence =\r\n                SharedFunctionalGroupsSequence.DerivationImageSequence\r\n                    .SourceImageSequence[i];\r\n        } else {\r\n            SourceImageSequence =\r\n                PerFrameFunctionalGroups.DerivationImageSequence\r\n                    .SourceImageSequence;\r\n        }\r\n\r\n        const imageId = getImageIdOfSourceImage(\r\n            SourceImageSequence,\r\n            imageIds,\r\n            metadataProvider\r\n        );\r\n\r\n        addImageIdSpecificBrushToolState(\r\n            toolState,\r\n            imageId,\r\n            segmentIndex,\r\n            alignedPixelDataI\r\n        );\r\n    }\r\n\r\n    if (!inPlane) {\r\n        return;\r\n    }\r\n\r\n    return { toolState, segMetadata };\r\n}\r\n\r\n/**\r\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\r\n *\r\n * @param  {Object} multiframe The multiframe dataset.\r\n * @return {Uint8Array}      The unpacked pixelData.\r\n */\r\nfunction unpackPixelData(multiframe) {\r\n    const segType = multiframe.SegmentationType;\r\n\r\n    if (segType === \"BINARY\") {\r\n        return BitArray.unpack(multiframe.PixelData);\r\n    }\r\n\r\n    const pixelData = new Uint8Array(multiframe.PixelData);\r\n\r\n    const max = multiframe.MaximumFractionalValue;\r\n    const onlyMaxAndZero =\r\n        pixelData.find(element => element !== 0 && element !== max) ===\r\n        undefined;\r\n\r\n    if (!onlyMaxAndZero) {\r\n        log.warn(\r\n            \"This is a fractional segmentation, which is not currently supported.\"\r\n        );\r\n        return;\r\n    }\r\n\r\n    log.warn(\r\n        \"This segmentation object is actually binary... processing as such.\"\r\n    );\r\n\r\n    return pixelData;\r\n}\r\n\r\n/**\r\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\r\n * formatted toolState object.\r\n *\r\n * @param  {Object} toolState    The toolState object to modify\r\n * @param  {String} imageId      The imageId of the toolState to add the data.\r\n * @param  {Number} segmentIndex The index of the segment data being added.\r\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\r\n */\r\nfunction addImageIdSpecificBrushToolState(\r\n    toolState,\r\n    imageId,\r\n    segmentIndex,\r\n    pixelData2D\r\n) {\r\n    if (!toolState[imageId]) {\r\n        toolState[imageId] = {};\r\n        toolState[imageId].brush = {};\r\n        toolState[imageId].brush.data = [];\r\n    } else if (!toolState[imageId].brush) {\r\n        toolState[imageId].brush = {};\r\n        toolState[imageId].brush.data = [];\r\n    } else if (!toolState[imageId].brush.data) {\r\n        toolState[imageId].brush.data = [];\r\n    }\r\n\r\n    toolState[imageId].brush.data[segmentIndex] = {};\r\n\r\n    const brushDataI = toolState[imageId].brush.data[segmentIndex];\r\n\r\n    brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\r\n\r\n    const cToolsPixelData = brushDataI.pixelData;\r\n\r\n    for (let p = 0; p < cToolsPixelData.length; p++) {\r\n        if (pixelData2D.data[p]) {\r\n            cToolsPixelData[p] = 1;\r\n        } else {\r\n            cToolsPixelData[p] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\r\n *\r\n * @param  {Object} SourceImageSequence Sequence describing the source image.\r\n * @param  {String[]} imageIds          A list of imageIds.\r\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\r\n *                                      metadata from imageIds.\r\n * @return {String}                     The corresponding imageId.\r\n */\r\nfunction getImageIdOfSourceImage(\r\n    SourceImageSequence,\r\n    imageIds,\r\n    metadataProvider\r\n) {\r\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\r\n        SourceImageSequence;\r\n\r\n    return ReferencedFrameNumber\r\n        ? getImageIdOfReferencedFrame(\r\n              ReferencedSOPInstanceUID,\r\n              ReferencedFrameNumber,\r\n              imageIds,\r\n              metadataProvider\r\n          )\r\n        : getImageIdOfReferencedSingleFramedSOPInstance(\r\n              ReferencedSOPInstanceUID,\r\n              imageIds,\r\n              metadataProvider\r\n          );\r\n}\r\n\r\n/**\r\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\r\n * corresponding to the specified sopInstanceUid for single-frame images.\r\n *\r\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\r\n * @param  {String[]} imageIds         The list of imageIds.\r\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\r\n *                                 from the cornerstone imageIds.\r\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\r\n */\r\nfunction getImageIdOfReferencedSingleFramedSOPInstance(\r\n    sopInstanceUid,\r\n    imageIds,\r\n    metadataProvider\r\n) {\r\n    return imageIds.find(imageId => {\r\n        const sopCommonModule = metadataProvider.get(\r\n            \"sopCommonModule\",\r\n            imageId\r\n        );\r\n        if (!sopCommonModule) {\r\n            return;\r\n        }\r\n\r\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\r\n    });\r\n}\r\n\r\n/**\r\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\r\n * specified sopInstanceUid and frameNumber for multi-frame images.\r\n *\r\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\r\n * @param  {Number} frameNumber      The frame number.\r\n * @param  {String} imageIds         The list of imageIds.\r\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\r\n *                                   from the cornerstone imageIds.\r\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\r\n */\r\nfunction getImageIdOfReferencedFrame(\r\n    sopInstanceUid,\r\n    frameNumber,\r\n    imageIds,\r\n    metadataProvider\r\n) {\r\n    const imageId = imageIds.find(imageId => {\r\n        const sopCommonModule = metadataProvider.get(\r\n            \"sopCommonModule\",\r\n            imageId\r\n        );\r\n        if (!sopCommonModule) {\r\n            return;\r\n        }\r\n\r\n        const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\r\n\r\n        return (\r\n            //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\r\n            sopCommonModule.sopInstanceUID === sopInstanceUid &&\r\n            imageIdFrameNumber === frameNumber - 1\r\n        );\r\n    });\r\n\r\n    return imageId;\r\n}\r\n\r\n/**\r\n * getValidOrientations - returns an array of valid orientations.\r\n *\r\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\r\n * @return  An array of valid orientations.\r\n */\r\nfunction getValidOrientations(iop) {\r\n    const orientations = [];\r\n\r\n    // [0,  1,  2]: 0,   0hf,   0vf\r\n    // [3,  4,  5]: 90,  90hf,  90vf\r\n    // [6, 7]:      180, 270\r\n\r\n    orientations[0] = iop;\r\n    orientations[1] = flipIOP.h(iop);\r\n    orientations[2] = flipIOP.v(iop);\r\n\r\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\r\n\r\n    orientations[3] = iop90;\r\n    orientations[4] = flipIOP.h(iop90);\r\n    orientations[5] = flipIOP.v(iop90);\r\n\r\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\r\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\r\n\r\n    return orientations;\r\n}\r\n\r\n/**\r\n * alignPixelDataWithSourceData -\r\n *\r\n * @param pixelData2D - The data to align.\r\n * @param iop - The orientation of the image slice.\r\n * @param orientations - An array of valid imageOrientationPatient values.\r\n * @return The aligned pixelData.\r\n */\r\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\r\n    if (compareIOP(iop, orientations[0])) {\r\n        //Same orientation.\r\n        return pixelData2D;\r\n    } else if (compareIOP(iop, orientations[1])) {\r\n        //Flipped vertically.\r\n        return flipMatrix2D.v(pixelData2D);\r\n    } else if (compareIOP(iop, orientations[2])) {\r\n        //Flipped horizontally.\r\n        return flipMatrix2D.h(pixelData2D);\r\n    } else if (compareIOP(iop, orientations[3])) {\r\n        //Rotated 90 degrees.\r\n        return rotateMatrix902D(pixelData2D);\r\n    } else if (compareIOP(iop, orientations[4])) {\r\n        //Rotated 90 degrees and fliped horizontally.\r\n        return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\r\n    } else if (compareIOP(iop, orientations[5])) {\r\n        //Rotated 90 degrees and fliped vertically.\r\n        return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\r\n    } else if (compareIOP(iop, orientations[6])) {\r\n        //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\r\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\r\n    } else if (compareIOP(iop, orientations[7])) {\r\n        //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\r\n        return rotateMatrix902D(\r\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\r\n        );\r\n    }\r\n}\r\n\r\nconst dx = 1e-5;\r\n\r\n/**\r\n * compareIOP - Returns true if iop1 and iop2 are equal\r\n * within a tollerance, dx.\r\n *\r\n * @param  iop1 - An ImageOrientationPatient array.\r\n * @param  iop2 - An ImageOrientationPatient array.\r\n * @return True if iop1 and iop2 are equal.\r\n */\r\nfunction compareIOP(iop1, iop2) {\r\n    return (\r\n        Math.abs(iop1[0] - iop2[0]) < dx &&\r\n        Math.abs(iop1[1] - iop2[1]) < dx &&\r\n        Math.abs(iop1[2] - iop2[2]) < dx &&\r\n        Math.abs(iop1[3] - iop2[3]) < dx &&\r\n        Math.abs(iop1[4] - iop2[4]) < dx &&\r\n        Math.abs(iop1[5] - iop2[5]) < dx\r\n    );\r\n}\r\n\r\nfunction getSegmentMetadata(multiframe) {\r\n    const data = [];\r\n\r\n    const segmentSequence = multiframe.SegmentSequence;\r\n\r\n    if (Array.isArray(segmentSequence)) {\r\n        for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\r\n            data.push(segmentSequence[segIdx]);\r\n        }\r\n    } else {\r\n        // Only one segment, will be stored as an object.\r\n        data.push(segmentSequence);\r\n    }\r\n\r\n    return {\r\n        seriesInstanceUid:\r\n            multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\r\n        data\r\n    };\r\n}\r\n","/**\r\n * Cornerstone adapters events\r\n */\r\nenum Events {\r\n    /**\r\n     * Cornerstone segmentation load progress event\r\n     */\r\n    SEGMENTATION_LOAD_PROGRESS = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\"\r\n}\r\n\r\nexport default Events;\r\n","import {\r\n    log,\r\n    data as dcmjsData,\r\n    utilities,\r\n    normalizers,\r\n    derivations\r\n} from \"dcmjs\";\r\nimport ndarray from \"ndarray\";\r\nimport cloneDeep from \"lodash.clonedeep\";\r\n\r\nimport { Events } from \"../enums\";\r\n\r\nconst {\r\n    rotateDirectionCosinesInPlane,\r\n    flipImageOrientationPatient: flipIOP,\r\n    flipMatrix2D,\r\n    rotateMatrix902D,\r\n    nearlyEqual\r\n} = utilities.orientation;\r\n\r\nconst { BitArray, DicomMessage, DicomMetaDictionary } = dcmjsData;\r\n\r\nconst { Normalizer } = normalizers;\r\nconst { Segmentation: SegmentationDerivation } = derivations;\r\n\r\nconst { encode, decode } = utilities.compression;\r\n\r\n/**\r\n *\r\n * @typedef {Object} BrushData\r\n * @property {Object} toolState - The cornerstoneTools global toolState.\r\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\r\n *                                 seriesInstanceUid.\r\n */\r\nconst generateSegmentationDefaultOptions = {\r\n    includeSliceSpacing: true,\r\n    rleEncode: false\r\n};\r\n\r\n/**\r\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\r\n * imageIds, images and the cornerstoneTools brushData.\r\n *\r\n * @param  {object[]} images An array of cornerstone images that contain the source\r\n *                           data under `image.data.byteArray.buffer`.\r\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\r\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\r\n * @returns {Blob}\r\n */\r\nfunction generateSegmentation(images, inputLabelmaps3D, userOptions = {}) {\r\n    const isMultiframe = images[0].imageId.includes(\"?frame\");\r\n    const segmentation = _createSegFromImages(\r\n        images,\r\n        isMultiframe,\r\n        userOptions\r\n    );\r\n\r\n    return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\r\n}\r\n\r\n/**\r\n * Fills a given segmentation object with data from the input labelmaps3D\r\n *\r\n * @param segmentation - The segmentation object to be filled.\r\n * @param inputLabelmaps3D - An array of 3D labelmaps, or a single 3D labelmap.\r\n * @param userOptions - Optional configuration settings. Will override the default options.\r\n *\r\n * @returns {object} The filled segmentation object.\r\n */\r\nfunction fillSegmentation(segmentation, inputLabelmaps3D, userOptions = {}) {\r\n    const options = Object.assign(\r\n        {},\r\n        generateSegmentationDefaultOptions,\r\n        userOptions\r\n    );\r\n\r\n    // Use another variable so we don't redefine labelmaps3D.\r\n    const labelmaps3D = Array.isArray(inputLabelmaps3D)\r\n        ? inputLabelmaps3D\r\n        : [inputLabelmaps3D];\r\n\r\n    let numberOfFrames = 0;\r\n    const referencedFramesPerLabelmap = [];\r\n\r\n    for (\r\n        let labelmapIndex = 0;\r\n        labelmapIndex < labelmaps3D.length;\r\n        labelmapIndex++\r\n    ) {\r\n        const labelmap3D = labelmaps3D[labelmapIndex];\r\n        const { labelmaps2D, metadata } = labelmap3D;\r\n\r\n        const referencedFramesPerSegment = [];\r\n\r\n        for (let i = 1; i < metadata.length; i++) {\r\n            if (metadata[i]) {\r\n                referencedFramesPerSegment[i] = [];\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < labelmaps2D.length; i++) {\r\n            const labelmap2D = labelmaps2D[i];\r\n\r\n            if (labelmaps2D[i]) {\r\n                const { segmentsOnLabelmap } = labelmap2D;\r\n\r\n                segmentsOnLabelmap.forEach(segmentIndex => {\r\n                    if (segmentIndex !== 0) {\r\n                        referencedFramesPerSegment[segmentIndex].push(i);\r\n                        numberOfFrames++;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\r\n    }\r\n\r\n    segmentation.setNumberOfFrames(numberOfFrames);\r\n\r\n    for (\r\n        let labelmapIndex = 0;\r\n        labelmapIndex < labelmaps3D.length;\r\n        labelmapIndex++\r\n    ) {\r\n        const referencedFramesPerSegment =\r\n            referencedFramesPerLabelmap[labelmapIndex];\r\n\r\n        const labelmap3D = labelmaps3D[labelmapIndex];\r\n        const { metadata } = labelmap3D;\r\n\r\n        for (\r\n            let segmentIndex = 1;\r\n            segmentIndex < referencedFramesPerSegment.length;\r\n            segmentIndex++\r\n        ) {\r\n            const referencedFrameIndicies =\r\n                referencedFramesPerSegment[segmentIndex];\r\n\r\n            if (referencedFrameIndicies) {\r\n                // Frame numbers start from 1.\r\n                const referencedFrameNumbers = referencedFrameIndicies.map(\r\n                    element => {\r\n                        return element + 1;\r\n                    }\r\n                );\r\n                const segmentMetadata = metadata[segmentIndex];\r\n                const labelmaps = _getLabelmapsFromReferencedFrameIndicies(\r\n                    labelmap3D,\r\n                    referencedFrameIndicies\r\n                );\r\n\r\n                segmentation.addSegmentFromLabelmap(\r\n                    segmentMetadata,\r\n                    labelmaps,\r\n                    segmentIndex,\r\n                    referencedFrameNumbers\r\n                );\r\n            }\r\n        }\r\n    }\r\n    if (options.rleEncode) {\r\n        const rleEncodedFrames = encode(\r\n            segmentation.dataset.PixelData,\r\n            numberOfFrames,\r\n            segmentation.dataset.Rows,\r\n            segmentation.dataset.Columns\r\n        );\r\n\r\n        // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\r\n        // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\r\n        // added to the standard.\r\n        segmentation.assignToDataset({\r\n            BitsAllocated: \"8\",\r\n            BitsStored: \"8\",\r\n            HighBit: \"7\",\r\n            SegmentationType: \"FRACTIONAL\",\r\n            SegmentationFractionalType: \"PROBABILITY\",\r\n            MaximumFractionalValue: \"255\"\r\n        });\r\n\r\n        segmentation.dataset._meta.TransferSyntaxUID = {\r\n            Value: [\"1.2.840.10008.1.2.5\"],\r\n            vr: \"UI\"\r\n        };\r\n        segmentation.dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n        segmentation.dataset._vrMap.PixelData = \"OB\";\r\n        segmentation.dataset.PixelData = rleEncodedFrames;\r\n    } else {\r\n        // If no rleEncoding, at least bitpack the data.\r\n        segmentation.bitPackPixelData();\r\n    }\r\n\r\n    return segmentation;\r\n}\r\n\r\nfunction _getLabelmapsFromReferencedFrameIndicies(\r\n    labelmap3D,\r\n    referencedFrameIndicies\r\n) {\r\n    const { labelmaps2D } = labelmap3D;\r\n\r\n    const labelmaps = [];\r\n\r\n    for (let i = 0; i < referencedFrameIndicies.length; i++) {\r\n        const frame = referencedFrameIndicies[i];\r\n\r\n        labelmaps.push(labelmaps2D[frame].pixelData);\r\n    }\r\n\r\n    return labelmaps;\r\n}\r\n\r\n/**\r\n * _createSegFromImages - description\r\n *\r\n * @param  {Object[]} images    An array of the cornerstone image objects.\r\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\r\n * @returns {Object}              The Seg derived dataSet.\r\n */\r\nfunction _createSegFromImages(images, isMultiframe, options) {\r\n    const datasets = [];\r\n\r\n    if (isMultiframe) {\r\n        const image = images[0];\r\n        const arrayBuffer = image.data.byteArray.buffer;\r\n\r\n        const dicomData = DicomMessage.readFile(arrayBuffer);\r\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n\r\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n        dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n        datasets.push(dataset);\r\n    } else {\r\n        for (let i = 0; i < images.length; i++) {\r\n            const image = images[i];\r\n            const arrayBuffer = image.data.byteArray.buffer;\r\n            const dicomData = DicomMessage.readFile(arrayBuffer);\r\n            const dataset = DicomMetaDictionary.naturalizeDataset(\r\n                dicomData.dict\r\n            );\r\n\r\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n            dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n            datasets.push(dataset);\r\n        }\r\n    }\r\n\r\n    const multiframe = Normalizer.normalizeToDataset(datasets);\r\n\r\n    return new SegmentationDerivation([multiframe], options);\r\n}\r\n\r\n/**\r\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\r\n * derive cornerstoneTools toolState and brush metadata.\r\n *\r\n * @param  {string[]} imageIds - An array of the imageIds.\r\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\r\n * @param  {*} metadataProvider.\r\n * @param  {obj} options - Options object.\r\n *\r\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\r\n * @return {Object} an object from which the segment metadata can be derived\r\n * @return {[][][]} 2D list containing the track of segments per frame\r\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\r\n *                  (available only for the overlapping case).\r\n */\r\nasync function generateToolState(\r\n    imageIds,\r\n    arrayBuffer,\r\n    metadataProvider,\r\n    options\r\n) {\r\n    const {\r\n        skipOverlapping = false,\r\n        tolerance = 1e-3,\r\n        TypedArrayConstructor = Uint8Array,\r\n        maxBytesPerChunk = 199000000,\r\n        eventTarget,\r\n        triggerEvent\r\n    } = options;\r\n    const dicomData = DicomMessage.readFile(arrayBuffer);\r\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\r\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\r\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\r\n\r\n    const imagePlaneModule = metadataProvider.get(\r\n        \"imagePlaneModule\",\r\n        imageIds[0]\r\n    );\r\n\r\n    const generalSeriesModule = metadataProvider.get(\r\n        \"generalSeriesModule\",\r\n        imageIds[0]\r\n    );\r\n\r\n    const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\r\n\r\n    if (!imagePlaneModule) {\r\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\r\n    }\r\n\r\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\r\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\r\n        : [\r\n              imagePlaneModule.rowCosines.x,\r\n              imagePlaneModule.rowCosines.y,\r\n              imagePlaneModule.rowCosines.z,\r\n              imagePlaneModule.columnCosines.x,\r\n              imagePlaneModule.columnCosines.y,\r\n              imagePlaneModule.columnCosines.z\r\n          ];\r\n\r\n    // Get IOP from ref series, compute supported orientations:\r\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\r\n\r\n    const sliceLength = multiframe.Columns * multiframe.Rows;\r\n    const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\r\n\r\n    const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\r\n\r\n    let pixelData;\r\n    let pixelDataChunks;\r\n\r\n    if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\r\n        const rleEncodedFrames = Array.isArray(multiframe.PixelData)\r\n            ? multiframe.PixelData\r\n            : [multiframe.PixelData];\r\n\r\n        pixelData = decode(\r\n            rleEncodedFrames,\r\n            multiframe.Rows,\r\n            multiframe.Columns\r\n        );\r\n\r\n        if (multiframe.BitsStored === 1) {\r\n            console.warn(\"No implementation for rle + bitbacking.\");\r\n\r\n            return;\r\n        }\r\n\r\n        // Todo: need to test this with rle data\r\n        pixelDataChunks = [pixelData];\r\n    } else {\r\n        pixelDataChunks = unpackPixelData(multiframe, { maxBytesPerChunk });\r\n\r\n        if (!pixelDataChunks) {\r\n            throw new Error(\"Fractional segmentations are not yet supported\");\r\n        }\r\n    }\r\n\r\n    const orientation = checkOrientation(\r\n        multiframe,\r\n        validOrientations,\r\n        [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length],\r\n        tolerance\r\n    );\r\n\r\n    // Pre-compute the sop UID to imageId index map so that in the for loop\r\n    // we don't have to call metadataProvider.get() for each imageId over\r\n    // and over again.\r\n    const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\r\n        const { sopInstanceUID } = metadataProvider.get(\r\n            \"generalImageModule\",\r\n            imageId\r\n        );\r\n        acc[sopInstanceUID] = imageId;\r\n        return acc;\r\n    }, {});\r\n\r\n    let overlapping = false;\r\n    if (!skipOverlapping) {\r\n        overlapping = checkSEGsOverlapping(\r\n            pixelDataChunks,\r\n            multiframe,\r\n            imageIds,\r\n            validOrientations,\r\n            metadataProvider,\r\n            tolerance,\r\n            TypedArrayConstructor,\r\n            sopUIDImageIdIndexMap\r\n        );\r\n    }\r\n\r\n    let insertFunction;\r\n\r\n    switch (orientation) {\r\n        case \"Planar\":\r\n            if (overlapping) {\r\n                insertFunction = insertOverlappingPixelDataPlanar;\r\n            } else {\r\n                insertFunction = insertPixelDataPlanar;\r\n            }\r\n            break;\r\n        case \"Perpendicular\":\r\n            //insertFunction = insertPixelDataPerpendicular;\r\n            throw new Error(\r\n                \"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\"\r\n            );\r\n        case \"Oblique\":\r\n            throw new Error(\r\n                \"Segmentations oblique to the acquisition plane of the source data are not yet supported.\"\r\n            );\r\n    }\r\n\r\n    /* if SEGs are overlapping:\r\n    1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\r\n    2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\r\n    3) insertFunction will return the number of LabelMaps\r\n    4) generateToolState return is an array*/\r\n\r\n    const segmentsOnFrameArray = [];\r\n    segmentsOnFrameArray[0] = [];\r\n    const segmentsOnFrame = [];\r\n\r\n    const arrayBufferLength =\r\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\r\n    const labelmapBufferArray = [];\r\n    labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\r\n\r\n    // Pre-compute the indices and metadata so that we don't have to call\r\n    // a function for each imageId in the for loop.\r\n    const imageIdMaps = imageIds.reduce(\r\n        (acc, curr, index) => {\r\n            acc.indices[curr] = index;\r\n            acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\r\n            return acc;\r\n        },\r\n        { indices: {}, metadata: {} }\r\n    );\r\n\r\n    // This is the centroid calculation for each segment Index, the data structure\r\n    // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\r\n    // later on we will use this data structure to calculate the centroid of the\r\n    // segment in the labelmapBuffer\r\n    const segmentsPixelIndices = new Map();\r\n\r\n    const overlappingSegments = await insertFunction(\r\n        segmentsOnFrame,\r\n        segmentsOnFrameArray,\r\n        labelmapBufferArray,\r\n        pixelDataChunks,\r\n        multiframe,\r\n        imageIds,\r\n        validOrientations,\r\n        metadataProvider,\r\n        tolerance,\r\n        TypedArrayConstructor,\r\n        segmentsPixelIndices,\r\n        sopUIDImageIdIndexMap,\r\n        imageIdMaps,\r\n        eventTarget,\r\n        triggerEvent\r\n    );\r\n\r\n    // calculate the centroid of each segment\r\n    const centroidXYZ = new Map();\r\n\r\n    segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\r\n        const { xAcc, yAcc, zAcc, count } = calculateCentroid(\r\n            imageIdIndexBufferIndex,\r\n            multiframe\r\n        );\r\n\r\n        centroidXYZ.set(segmentIndex, {\r\n            x: Math.floor(xAcc / count),\r\n            y: Math.floor(yAcc / count),\r\n            z: Math.floor(zAcc / count)\r\n        });\r\n    });\r\n\r\n    return {\r\n        labelmapBufferArray,\r\n        segMetadata,\r\n        segmentsOnFrame,\r\n        segmentsOnFrameArray,\r\n        centroids: centroidXYZ,\r\n        overlappingSegments\r\n    };\r\n}\r\n\r\n// function insertPixelDataPerpendicular(\r\n//     segmentsOnFrame,\r\n//     labelmapBuffer,\r\n//     pixelData,\r\n//     multiframe,\r\n//     imageIds,\r\n//     validOrientations,\r\n//     metadataProvider\r\n// ) {\r\n//     const {\r\n//         SharedFunctionalGroupsSequence,\r\n//         PerFrameFunctionalGroupsSequence,\r\n//         Rows,\r\n//         Columns\r\n//     } = multiframe;\r\n\r\n//     const firstImagePlaneModule = metadataProvider.get(\r\n//         \"imagePlaneModule\",\r\n//         imageIds[0]\r\n//     );\r\n\r\n//     const lastImagePlaneModule = metadataProvider.get(\r\n//         \"imagePlaneModule\",\r\n//         imageIds[imageIds.length - 1]\r\n//     );\r\n\r\n//     console.log(firstImagePlaneModule);\r\n//     console.log(lastImagePlaneModule);\r\n\r\n//     const corners = [\r\n//         ...getCorners(firstImagePlaneModule),\r\n//         ...getCorners(lastImagePlaneModule)\r\n//     ];\r\n\r\n//     console.log(`corners:`);\r\n//     console.log(corners);\r\n\r\n//     const indexToWorld = mat4.create();\r\n\r\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\r\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\r\n//         ? [...firstImagePlaneModule.rowCosines]\r\n//         : [\r\n//               firstImagePlaneModule.rowCosines.x,\r\n//               firstImagePlaneModule.rowCosines.y,\r\n//               firstImagePlaneModule.rowCosines.z\r\n//           ];\r\n\r\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\r\n//         ? [...firstImagePlaneModule.columnCosines]\r\n//         : [\r\n//               firstImagePlaneModule.columnCosines.x,\r\n//               firstImagePlaneModule.columnCosines.y,\r\n//               firstImagePlaneModule.columnCosines.z\r\n//           ];\r\n\r\n//     const { pixelSpacing } = firstImagePlaneModule;\r\n\r\n//     mat4.set(\r\n//         indexToWorld,\r\n//         // Column 1\r\n//         0,\r\n//         0,\r\n//         0,\r\n//         ippFirstFrame[0],\r\n//         // Column 2\r\n//         0,\r\n//         0,\r\n//         0,\r\n//         ippFirstFrame[1],\r\n//         // Column 3\r\n//         0,\r\n//         0,\r\n//         0,\r\n//         ippFirstFrame[2],\r\n//         // Column 4\r\n//         0,\r\n//         0,\r\n//         0,\r\n//         1\r\n//     );\r\n\r\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\r\n//     // TODO -> Equation C.7.6.2.1-1\r\n\r\n//     // | cx*di rx* Xx 0 |  |x|\r\n//     // | cy*di ry Xy 0 |  |y|\r\n//     // | cz*di rz Xz 0 |  |z|\r\n//     // | tx ty tz 1 |  |1|\r\n\r\n//     // const [\r\n//     //     0, 0 , 0 , 0,\r\n//     //     0, 0 , 0 , 0,\r\n//     //     0, 0 , 0 , 0,\r\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\r\n//     // ]\r\n\r\n//     // Each frame:\r\n\r\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\r\n\r\n//     // Find how i,j,k orient with respect to source volume.\r\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\r\n//     //   through each voxel.\r\n\r\n//     // [1,0,0,0,1,0]\r\n\r\n//     // const [\r\n\r\n//     // ]\r\n\r\n//     // Invert transformation matrix to get worldToIndex\r\n\r\n//     // Apply world to index on each point to fill up the matrix.\r\n\r\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n//     //           .ImageOrientationPatient\r\n//     //     : undefined;\r\n//     // const sliceLength = Columns * Rows;\r\n// }\r\n\r\n// function getCorners(imagePlaneModule) {\r\n//     // console.log(imagePlaneModule);\r\n\r\n//     const {\r\n//         rows,\r\n//         columns,\r\n//         rowCosines,\r\n//         columnCosines,\r\n//         imagePositionPatient: ipp,\r\n//         rowPixelSpacing,\r\n//         columnPixelSpacing\r\n//     } = imagePlaneModule;\r\n\r\n//     const rowLength = columns * columnPixelSpacing;\r\n//     const columnLength = rows * rowPixelSpacing;\r\n\r\n//     const entireRowVector = [\r\n//         rowLength * columnCosines[0],\r\n//         rowLength * columnCosines[1],\r\n//         rowLength * columnCosines[2]\r\n//     ];\r\n\r\n//     const entireColumnVector = [\r\n//         columnLength * rowCosines[0],\r\n//         columnLength * rowCosines[1],\r\n//         columnLength * rowCosines[2]\r\n//     ];\r\n\r\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\r\n//     const topRight = [\r\n//         topLeft[0] + entireRowVector[0],\r\n//         topLeft[1] + entireRowVector[1],\r\n//         topLeft[2] + entireRowVector[2]\r\n//     ];\r\n//     const bottomLeft = [\r\n//         topLeft[0] + entireColumnVector[0],\r\n//         topLeft[1] + entireColumnVector[1],\r\n//         topLeft[2] + entireColumnVector[2]\r\n//     ];\r\n\r\n//     const bottomRight = [\r\n//         bottomLeft[0] + entireRowVector[0],\r\n//         bottomLeft[1] + entireRowVector[1],\r\n//         bottomLeft[2] + entireRowVector[2]\r\n//     ];\r\n\r\n//     return [topLeft, topRight, bottomLeft, bottomRight];\r\n// }\r\n\r\n/**\r\n * Find the reference frame of the segmentation frame in the source data.\r\n *\r\n * @param  {Object}      multiframe        dicom metadata\r\n * @param  {Int}         frameSegment      frame dicom index\r\n * @param  {String[]}    imageIds          A list of imageIds.\r\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\r\n * @param  {Float}       tolerance         The tolerance parameter\r\n *\r\n * @returns {String}     Returns the imageId\r\n */\r\nfunction findReferenceSourceImageId(\r\n    multiframe,\r\n    frameSegment,\r\n    imageIds,\r\n    metadataProvider,\r\n    tolerance,\r\n    sopUIDImageIdIndexMap\r\n) {\r\n    let imageId = undefined;\r\n\r\n    if (!multiframe) {\r\n        return imageId;\r\n    }\r\n\r\n    const {\r\n        FrameOfReferenceUID,\r\n        PerFrameFunctionalGroupsSequence,\r\n        SourceImageSequence,\r\n        ReferencedSeriesSequence\r\n    } = multiframe;\r\n\r\n    if (\r\n        !PerFrameFunctionalGroupsSequence ||\r\n        PerFrameFunctionalGroupsSequence.length === 0\r\n    ) {\r\n        return imageId;\r\n    }\r\n\r\n    const PerFrameFunctionalGroup =\r\n        PerFrameFunctionalGroupsSequence[frameSegment];\r\n\r\n    if (!PerFrameFunctionalGroup) {\r\n        return imageId;\r\n    }\r\n\r\n    let frameSourceImageSequence = undefined;\r\n    if (PerFrameFunctionalGroup.DerivationImageSequence) {\r\n        let DerivationImageSequence =\r\n            PerFrameFunctionalGroup.DerivationImageSequence;\r\n        if (Array.isArray(DerivationImageSequence)) {\r\n            if (DerivationImageSequence.length !== 0) {\r\n                DerivationImageSequence = DerivationImageSequence[0];\r\n            } else {\r\n                DerivationImageSequence = undefined;\r\n            }\r\n        }\r\n\r\n        if (DerivationImageSequence) {\r\n            frameSourceImageSequence =\r\n                DerivationImageSequence.SourceImageSequence;\r\n            if (Array.isArray(frameSourceImageSequence)) {\r\n                if (frameSourceImageSequence.length !== 0) {\r\n                    frameSourceImageSequence = frameSourceImageSequence[0];\r\n                } else {\r\n                    frameSourceImageSequence = undefined;\r\n                }\r\n            }\r\n        }\r\n    } else if (SourceImageSequence && SourceImageSequence.length !== 0) {\r\n        console.warn(\r\n            \"DerivationImageSequence not present, using SourceImageSequence assuming SEG has the same geometry as the source image.\"\r\n        );\r\n        frameSourceImageSequence = SourceImageSequence[frameSegment];\r\n    }\r\n\r\n    if (frameSourceImageSequence) {\r\n        imageId = getImageIdOfSourceImageBySourceImageSequence(\r\n            frameSourceImageSequence,\r\n            sopUIDImageIdIndexMap\r\n        );\r\n    }\r\n\r\n    if (imageId === undefined && ReferencedSeriesSequence) {\r\n        const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence)\r\n            ? ReferencedSeriesSequence[0]\r\n            : ReferencedSeriesSequence;\r\n        const ReferencedSeriesInstanceUID =\r\n            referencedSeriesSequence.SeriesInstanceUID;\r\n\r\n        imageId = getImageIdOfSourceImagebyGeometry(\r\n            ReferencedSeriesInstanceUID,\r\n            FrameOfReferenceUID,\r\n            PerFrameFunctionalGroup,\r\n            imageIds,\r\n            metadataProvider,\r\n            tolerance\r\n        );\r\n    }\r\n\r\n    return imageId;\r\n}\r\n\r\n/**\r\n * Checks if there is any overlapping segmentations.\r\n *  @returns {boolean} Returns a flag if segmentations overlapping\r\n */\r\n\r\nfunction checkSEGsOverlapping(\r\n    pixelData,\r\n    multiframe,\r\n    imageIds,\r\n    validOrientations,\r\n    metadataProvider,\r\n    tolerance,\r\n    TypedArrayConstructor,\r\n    sopUIDImageIdIndexMap\r\n) {\r\n    const {\r\n        SharedFunctionalGroupsSequence,\r\n        PerFrameFunctionalGroupsSequence,\r\n        SegmentSequence,\r\n        Rows,\r\n        Columns\r\n    } = multiframe;\r\n\r\n    let numberOfSegs = SegmentSequence.length;\r\n    if (numberOfSegs < 2) {\r\n        return false;\r\n    }\r\n\r\n    const sharedImageOrientationPatient =\r\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n                  .ImageOrientationPatient\r\n            : undefined;\r\n    const sliceLength = Columns * Rows;\r\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\r\n\r\n    /** sort groupsLen to have all the segments for each frame in an array\r\n     * frame 2 : 1, 2\r\n     * frame 4 : 1, 3\r\n     * frame 5 : 4\r\n     */\r\n\r\n    let frameSegmentsMapping = new Map();\r\n    for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\r\n        const segmentIndex = getSegmentIndex(multiframe, frameSegment);\r\n        if (segmentIndex === undefined) {\r\n            console.warn(\r\n                \"Could not retrieve the segment index for frame segment \" +\r\n                    frameSegment +\r\n                    \", skipping this frame.\"\r\n            );\r\n            continue;\r\n        }\r\n\r\n        const imageId = findReferenceSourceImageId(\r\n            multiframe,\r\n            frameSegment,\r\n            imageIds,\r\n            metadataProvider,\r\n            tolerance,\r\n            sopUIDImageIdIndexMap\r\n        );\r\n\r\n        if (!imageId) {\r\n            console.warn(\r\n                \"Image not present in stack, can't import frame : \" +\r\n                    frameSegment +\r\n                    \".\"\r\n            );\r\n            continue;\r\n        }\r\n\r\n        const imageIdIndex = imageIds.findIndex(element => element === imageId);\r\n\r\n        if (frameSegmentsMapping.has(imageIdIndex)) {\r\n            let segmentArray = frameSegmentsMapping.get(imageIdIndex);\r\n            if (!segmentArray.includes(frameSegment)) {\r\n                segmentArray.push(frameSegment);\r\n                frameSegmentsMapping.set(imageIdIndex, segmentArray);\r\n            }\r\n        } else {\r\n            frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\r\n        }\r\n    }\r\n\r\n    for (let [, role] of frameSegmentsMapping.entries()) {\r\n        let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\r\n\r\n        for (let i = 0; i < role.length; ++i) {\r\n            const frameSegment = role[i];\r\n\r\n            const PerFrameFunctionalGroups =\r\n                PerFrameFunctionalGroupsSequence[frameSegment];\r\n\r\n            const ImageOrientationPatientI =\r\n                sharedImageOrientationPatient ||\r\n                PerFrameFunctionalGroups.PlaneOrientationSequence\r\n                    .ImageOrientationPatient;\r\n\r\n            const view = readFromUnpackedChunks(\r\n                pixelData,\r\n                frameSegment * sliceLength,\r\n                sliceLength\r\n            );\r\n\r\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\r\n\r\n            const alignedPixelDataI = alignPixelDataWithSourceData(\r\n                pixelDataI2D,\r\n                ImageOrientationPatientI,\r\n                validOrientations,\r\n                tolerance\r\n            );\r\n\r\n            if (!alignedPixelDataI) {\r\n                console.warn(\r\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\"\r\n                );\r\n                continue;\r\n            }\r\n\r\n            const data = alignedPixelDataI.data;\r\n            for (let j = 0, len = data.length; j < len; ++j) {\r\n                if (data[j] !== 0) {\r\n                    temp2DArray[j]++;\r\n                    if (temp2DArray[j] > 1) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction insertOverlappingPixelDataPlanar(\r\n    segmentsOnFrame,\r\n    segmentsOnFrameArray,\r\n    labelmapBufferArray,\r\n    pixelData,\r\n    multiframe,\r\n    imageIds,\r\n    validOrientations,\r\n    metadataProvider,\r\n    tolerance,\r\n    TypedArrayConstructor,\r\n    segmentsPixelIndices,\r\n    sopUIDImageIdIndexMap\r\n) {\r\n    const {\r\n        SharedFunctionalGroupsSequence,\r\n        PerFrameFunctionalGroupsSequence,\r\n        Rows,\r\n        Columns\r\n    } = multiframe;\r\n\r\n    const sharedImageOrientationPatient =\r\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n                  .ImageOrientationPatient\r\n            : undefined;\r\n    const sliceLength = Columns * Rows;\r\n    const arrayBufferLength =\r\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\r\n    // indicate the number of labelMaps\r\n    let M = 1;\r\n\r\n    // indicate the current labelMap array index;\r\n    let m = 0;\r\n\r\n    // temp array for checking overlaps\r\n    let tempBuffer = labelmapBufferArray[m].slice(0);\r\n\r\n    // temp list for checking overlaps\r\n    let tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\r\n\r\n    /** split overlapping SEGs algorithm for each segment:\r\n     *  A) copy the labelmapBuffer in the array with index 0\r\n     *  B) add the segment pixel per pixel on the copied buffer from (A)\r\n     *  C) if no overlap, copy the results back on the orignal array from (A)\r\n     *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\r\n     */\r\n\r\n    let numberOfSegs = multiframe.SegmentSequence.length;\r\n    for (\r\n        let segmentIndexToProcess = 1;\r\n        segmentIndexToProcess <= numberOfSegs;\r\n        ++segmentIndexToProcess\r\n    ) {\r\n        for (\r\n            let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length;\r\n            i < groupsLen;\r\n            ++i\r\n        ) {\r\n            const PerFrameFunctionalGroups =\r\n                PerFrameFunctionalGroupsSequence[i];\r\n\r\n            const segmentIndex = getSegmentIndex(multiframe, i);\r\n            if (segmentIndex === undefined) {\r\n                throw new Error(\r\n                    \"Could not retrieve the segment index. Aborting segmentation loading.\"\r\n                );\r\n            }\r\n\r\n            if (segmentIndex !== segmentIndexToProcess) {\r\n                continue;\r\n            }\r\n\r\n            const ImageOrientationPatientI =\r\n                sharedImageOrientationPatient ||\r\n                PerFrameFunctionalGroups.PlaneOrientationSequence\r\n                    .ImageOrientationPatient;\r\n\r\n            // Since we moved to the chunks approach, we need to read the data\r\n            // and handle scenarios where the portion of data is in one chunk\r\n            // and the other portion is in another chunk\r\n            const view = readFromUnpackedChunks(\r\n                pixelData,\r\n                i * sliceLength,\r\n                sliceLength\r\n            );\r\n\r\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\r\n\r\n            const alignedPixelDataI = alignPixelDataWithSourceData(\r\n                pixelDataI2D,\r\n                ImageOrientationPatientI,\r\n                validOrientations,\r\n                tolerance\r\n            );\r\n\r\n            if (!alignedPixelDataI) {\r\n                throw new Error(\r\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\r\n                        \"This is not yet supported. Aborting segmentation loading.\"\r\n                );\r\n            }\r\n\r\n            const imageId = findReferenceSourceImageId(\r\n                multiframe,\r\n                i,\r\n                imageIds,\r\n                metadataProvider,\r\n                tolerance,\r\n                sopUIDImageIdIndexMap\r\n            );\r\n\r\n            if (!imageId) {\r\n                console.warn(\r\n                    \"Image not present in stack, can't import frame : \" +\r\n                        i +\r\n                        \".\"\r\n                );\r\n                continue;\r\n            }\r\n\r\n            const sourceImageMetadata = metadataProvider.get(\r\n                \"instance\",\r\n                imageId\r\n            );\r\n            if (\r\n                Rows !== sourceImageMetadata.Rows ||\r\n                Columns !== sourceImageMetadata.Columns\r\n            ) {\r\n                throw new Error(\r\n                    \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\r\n                        \"respect to the source image reference frame. This is not yet supported. \" +\r\n                        \"Aborting segmentation loading. \"\r\n                );\r\n            }\r\n\r\n            const imageIdIndex = imageIds.findIndex(\r\n                element => element === imageId\r\n            );\r\n            const byteOffset =\r\n                sliceLength *\r\n                imageIdIndex *\r\n                TypedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const labelmap2DView = new TypedArrayConstructor(\r\n                tempBuffer,\r\n                byteOffset,\r\n                sliceLength\r\n            );\r\n\r\n            const data = alignedPixelDataI.data;\r\n\r\n            let segmentOnFrame = false;\r\n            for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\r\n                if (data[j]) {\r\n                    if (labelmap2DView[j] !== 0) {\r\n                        m++;\r\n                        if (m >= M) {\r\n                            labelmapBufferArray[m] = new ArrayBuffer(\r\n                                arrayBufferLength\r\n                            );\r\n                            segmentsOnFrameArray[m] = [];\r\n                            M++;\r\n                        }\r\n                        tempBuffer = labelmapBufferArray[m].slice(0);\r\n                        tempSegmentsOnFrame = cloneDeep(\r\n                            segmentsOnFrameArray[m]\r\n                        );\r\n\r\n                        i = 0;\r\n                        break;\r\n                    } else {\r\n                        labelmap2DView[j] = segmentIndex;\r\n                        segmentOnFrame = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (segmentOnFrame) {\r\n                if (!tempSegmentsOnFrame[imageIdIndex]) {\r\n                    tempSegmentsOnFrame[imageIdIndex] = [];\r\n                }\r\n\r\n                tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\r\n\r\n                if (!segmentsOnFrame[imageIdIndex]) {\r\n                    segmentsOnFrame[imageIdIndex] = [];\r\n                }\r\n\r\n                segmentsOnFrame[imageIdIndex].push(segmentIndex);\r\n            }\r\n        }\r\n\r\n        labelmapBufferArray[m] = tempBuffer.slice(0);\r\n        segmentsOnFrameArray[m] = cloneDeep(tempSegmentsOnFrame);\r\n\r\n        // reset temp variables/buffers for new segment\r\n        m = 0;\r\n        tempBuffer = labelmapBufferArray[m].slice(0);\r\n        tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\r\n    }\r\n}\r\n\r\nconst getSegmentIndex = (multiframe, frame) => {\r\n    const { PerFrameFunctionalGroupsSequence, SharedFunctionalGroupsSequence } =\r\n        multiframe;\r\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\r\n    return PerFrameFunctionalGroups &&\r\n        PerFrameFunctionalGroups.SegmentIdentificationSequence\r\n        ? PerFrameFunctionalGroups.SegmentIdentificationSequence\r\n              .ReferencedSegmentNumber\r\n        : SharedFunctionalGroupsSequence.SegmentIdentificationSequence\r\n        ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence\r\n              .ReferencedSegmentNumber\r\n        : undefined;\r\n};\r\n\r\nfunction insertPixelDataPlanar(\r\n    segmentsOnFrame,\r\n    segmentsOnFrameArray,\r\n    labelmapBufferArray,\r\n    pixelData,\r\n    multiframe,\r\n    imageIds,\r\n    validOrientations,\r\n    metadataProvider,\r\n    tolerance,\r\n    TypedArrayConstructor,\r\n    segmentsPixelIndices,\r\n    sopUIDImageIdIndexMap,\r\n    imageIdMaps,\r\n    eventTarget,\r\n    triggerEvent\r\n) {\r\n    const {\r\n        SharedFunctionalGroupsSequence,\r\n        PerFrameFunctionalGroupsSequence,\r\n        Rows,\r\n        Columns\r\n    } = multiframe;\r\n\r\n    const sharedImageOrientationPatient =\r\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n                  .ImageOrientationPatient\r\n            : undefined;\r\n    const sliceLength = Columns * Rows;\r\n\r\n    let i = 0;\r\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\r\n    const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\r\n\r\n    const shouldTriggerEvent = triggerEvent && eventTarget;\r\n\r\n    let overlapping = false;\r\n    // Below, we chunk the processing of the frames to avoid blocking the main thread\r\n    // if the segmentation is large. We also use a promise to allow the caller to\r\n    // wait for the processing to finish.\r\n    return new Promise(resolve => {\r\n        function processInChunks() {\r\n            // process one chunk\r\n            for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\r\n                const PerFrameFunctionalGroups =\r\n                    PerFrameFunctionalGroupsSequence[i];\r\n\r\n                const ImageOrientationPatientI =\r\n                    sharedImageOrientationPatient ||\r\n                    PerFrameFunctionalGroups.PlaneOrientationSequence\r\n                        .ImageOrientationPatient;\r\n\r\n                const view = readFromUnpackedChunks(\r\n                    pixelData,\r\n                    i * sliceLength,\r\n                    sliceLength\r\n                );\r\n\r\n                const pixelDataI2D = ndarray(view, [Rows, Columns]);\r\n\r\n                const alignedPixelDataI = alignPixelDataWithSourceData(\r\n                    pixelDataI2D,\r\n                    ImageOrientationPatientI,\r\n                    validOrientations,\r\n                    tolerance\r\n                );\r\n\r\n                if (!alignedPixelDataI) {\r\n                    throw new Error(\r\n                        \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\r\n                            \"This is not yet supported. Aborting segmentation loading.\"\r\n                    );\r\n                }\r\n\r\n                const segmentIndex = getSegmentIndex(multiframe, i);\r\n\r\n                if (segmentIndex === undefined) {\r\n                    throw new Error(\r\n                        \"Could not retrieve the segment index. Aborting segmentation loading.\"\r\n                    );\r\n                }\r\n\r\n                if (!segmentsPixelIndices.has(segmentIndex)) {\r\n                    segmentsPixelIndices.set(segmentIndex, {});\r\n                }\r\n\r\n                const imageId = findReferenceSourceImageId(\r\n                    multiframe,\r\n                    i,\r\n                    imageIds,\r\n                    metadataProvider,\r\n                    tolerance,\r\n                    sopUIDImageIdIndexMap\r\n                );\r\n\r\n                if (!imageId) {\r\n                    console.warn(\r\n                        \"Image not present in stack, can't import frame : \" +\r\n                            i +\r\n                            \".\"\r\n                    );\r\n                    continue;\r\n                }\r\n\r\n                const sourceImageMetadata = imageIdMaps.metadata[imageId];\r\n                if (\r\n                    Rows !== sourceImageMetadata.Rows ||\r\n                    Columns !== sourceImageMetadata.Columns\r\n                ) {\r\n                    throw new Error(\r\n                        \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\r\n                            \"respect to the source image reference frame. This is not yet supported. \" +\r\n                            \"Aborting segmentation loading. \"\r\n                    );\r\n                }\r\n\r\n                const imageIdIndex = imageIdMaps.indices[imageId];\r\n\r\n                const byteOffset =\r\n                    sliceLength *\r\n                    imageIdIndex *\r\n                    TypedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n                const labelmap2DView = new TypedArrayConstructor(\r\n                    labelmapBufferArray[0],\r\n                    byteOffset,\r\n                    sliceLength\r\n                );\r\n\r\n                const data = alignedPixelDataI.data;\r\n\r\n                const indexCache = [];\r\n                for (\r\n                    let j = 0, len = alignedPixelDataI.data.length;\r\n                    j < len;\r\n                    ++j\r\n                ) {\r\n                    if (data[j]) {\r\n                        for (let x = j; x < len; ++x) {\r\n                            if (data[x]) {\r\n                                if (!overlapping && labelmap2DView[x] !== 0) {\r\n                                    overlapping = true;\r\n                                }\r\n                                labelmap2DView[x] = segmentIndex;\r\n                                indexCache.push(x);\r\n                            }\r\n                        }\r\n\r\n                        if (!segmentsOnFrame[imageIdIndex]) {\r\n                            segmentsOnFrame[imageIdIndex] = [];\r\n                        }\r\n\r\n                        segmentsOnFrame[imageIdIndex].push(segmentIndex);\r\n\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                const segmentIndexObject =\r\n                    segmentsPixelIndices.get(segmentIndex);\r\n                segmentIndexObject[imageIdIndex] = indexCache;\r\n                segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\r\n            }\r\n\r\n            // trigger an event after each chunk\r\n            if (shouldTriggerEvent) {\r\n                const percentComplete = Math.round((i / groupsLen) * 100);\r\n                triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\r\n                    percentComplete\r\n                });\r\n            }\r\n\r\n            // schedule next chunk\r\n            if (i < groupsLen) {\r\n                setTimeout(processInChunks, 0);\r\n            } else {\r\n                // resolve the Promise when all chunks have been processed\r\n                resolve(overlapping);\r\n            }\r\n        }\r\n\r\n        processInChunks();\r\n    });\r\n}\r\n\r\nfunction checkOrientation(\r\n    multiframe,\r\n    validOrientations,\r\n    sourceDataDimensions,\r\n    tolerance\r\n) {\r\n    const { SharedFunctionalGroupsSequence, PerFrameFunctionalGroupsSequence } =\r\n        multiframe;\r\n\r\n    const sharedImageOrientationPatient =\r\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\r\n                  .ImageOrientationPatient\r\n            : undefined;\r\n\r\n    // Check if in plane.\r\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\r\n\r\n    const iop =\r\n        sharedImageOrientationPatient ||\r\n        PerFrameFunctionalGroups.PlaneOrientationSequence\r\n            .ImageOrientationPatient;\r\n\r\n    const inPlane = validOrientations.some(operation =>\r\n        compareArrays(iop, operation, tolerance)\r\n    );\r\n\r\n    if (inPlane) {\r\n        return \"Planar\";\r\n    }\r\n\r\n    if (\r\n        checkIfPerpendicular(iop, validOrientations[0], tolerance) &&\r\n        sourceDataDimensions.includes(multiframe.Rows) &&\r\n        sourceDataDimensions.includes(multiframe.Columns)\r\n    ) {\r\n        // Perpendicular and fits on same grid.\r\n        return \"Perpendicular\";\r\n    }\r\n\r\n    return \"Oblique\";\r\n}\r\n\r\n/**\r\n * checkIfPerpendicular - Returns true if iop1 and iop2 are perpendicular\r\n * within a tolerance.\r\n *\r\n * @param  {Number[6]} iop1 An ImageOrientationPatient array.\r\n * @param  {Number[6]} iop2 An ImageOrientationPatient array.\r\n * @param  {Number} tolerance.\r\n * @return {Boolean} True if iop1 and iop2 are equal.\r\n */\r\nfunction checkIfPerpendicular(iop1, iop2, tolerance) {\r\n    const absDotColumnCosines = Math.abs(\r\n        iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]\r\n    );\r\n    const absDotRowCosines = Math.abs(\r\n        iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]\r\n    );\r\n\r\n    return (\r\n        (absDotColumnCosines < tolerance ||\r\n            Math.abs(absDotColumnCosines - 1) < tolerance) &&\r\n        (absDotRowCosines < tolerance ||\r\n            Math.abs(absDotRowCosines - 1) < tolerance)\r\n    );\r\n}\r\n\r\n/**\r\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\r\n *\r\n * @param  {Object} multiframe The multiframe dataset.\r\n * @param  {Object} options    Options for the unpacking.\r\n * @return {Uint8Array}      The unpacked pixelData.\r\n */\r\nfunction unpackPixelData(multiframe, options) {\r\n    const segType = multiframe.SegmentationType;\r\n\r\n    let data;\r\n    if (Array.isArray(multiframe.PixelData)) {\r\n        data = multiframe.PixelData[0];\r\n    } else {\r\n        data = multiframe.PixelData;\r\n    }\r\n\r\n    if (data === undefined) {\r\n        log.error(\"This segmentation pixeldata is undefined.\");\r\n    }\r\n\r\n    if (segType === \"BINARY\") {\r\n        // For extreme big data, we can't unpack the data at once and we need to\r\n        // chunk it and unpack each chunk separately.\r\n        // MAX 2GB is the limit right now to allocate a buffer\r\n        return getUnpackedChunks(data, options.maxBytesPerChunk);\r\n    }\r\n\r\n    const pixelData = new Uint8Array(data);\r\n\r\n    const max = multiframe.MaximumFractionalValue;\r\n    const onlyMaxAndZero =\r\n        pixelData.find(element => element !== 0 && element !== max) ===\r\n        undefined;\r\n\r\n    if (!onlyMaxAndZero) {\r\n        // This is a fractional segmentation, which is not currently supported.\r\n        return;\r\n    }\r\n\r\n    log.warn(\r\n        \"This segmentation object is actually binary... processing as such.\"\r\n    );\r\n\r\n    return pixelData;\r\n}\r\n\r\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\r\n    var bitArray = new Uint8Array(data);\r\n    var chunks = [];\r\n\r\n    var maxBitsPerChunk = maxBytesPerChunk * 8;\r\n    var numberOfChunks = Math.ceil((bitArray.length * 8) / maxBitsPerChunk);\r\n\r\n    for (var i = 0; i < numberOfChunks; i++) {\r\n        var startBit = i * maxBitsPerChunk;\r\n        var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\r\n\r\n        var startByte = Math.floor(startBit / 8);\r\n        var endByte = Math.ceil(endBit / 8);\r\n\r\n        var chunk = bitArray.slice(startByte, endByte);\r\n        var unpackedChunk = BitArray.unpack(chunk);\r\n\r\n        chunks.push(unpackedChunk);\r\n    }\r\n\r\n    return chunks;\r\n}\r\n\r\n/**\r\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\r\n *\r\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\r\n * @param  {String[]} imageIds             A list of imageIds.\r\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\r\n * @return {String}                        The corresponding imageId.\r\n */\r\nfunction getImageIdOfSourceImageBySourceImageSequence(\r\n    SourceImageSequence,\r\n    sopUIDImageIdIndexMap\r\n) {\r\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\r\n        SourceImageSequence;\r\n\r\n    return ReferencedFrameNumber\r\n        ? getImageIdOfReferencedFrame(\r\n              ReferencedSOPInstanceUID,\r\n              ReferencedFrameNumber,\r\n              sopUIDImageIdIndexMap\r\n          )\r\n        : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\r\n}\r\n\r\n/**\r\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\r\n *\r\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\r\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\r\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\r\n * @param  {String[]}  imageIds                       A list of imageIds.\r\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\r\n * @param  {Float}     tolerance                      The tolerance parameter\r\n *\r\n * @return {String}                                   The corresponding imageId.\r\n */\r\nfunction getImageIdOfSourceImagebyGeometry(\r\n    ReferencedSeriesInstanceUID,\r\n    FrameOfReferenceUID,\r\n    PerFrameFunctionalGroup,\r\n    imageIds,\r\n    metadataProvider,\r\n    tolerance\r\n) {\r\n    if (\r\n        ReferencedSeriesInstanceUID === undefined ||\r\n        PerFrameFunctionalGroup.PlanePositionSequence === undefined ||\r\n        PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined ||\r\n        PerFrameFunctionalGroup.PlanePositionSequence[0]\r\n            .ImagePositionPatient === undefined\r\n    ) {\r\n        return undefined;\r\n    }\r\n\r\n    for (\r\n        let imageIdsIndexc = 0;\r\n        imageIdsIndexc < imageIds.length;\r\n        ++imageIdsIndexc\r\n    ) {\r\n        const sourceImageMetadata = metadataProvider.get(\r\n            \"instance\",\r\n            imageIds[imageIdsIndexc]\r\n        );\r\n\r\n        if (\r\n            sourceImageMetadata === undefined ||\r\n            sourceImageMetadata.ImagePositionPatient === undefined ||\r\n            sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID ||\r\n            sourceImageMetadata.SeriesInstanceUID !==\r\n                ReferencedSeriesInstanceUID\r\n        ) {\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            compareArrays(\r\n                PerFrameFunctionalGroup.PlanePositionSequence[0]\r\n                    .ImagePositionPatient,\r\n                sourceImageMetadata.ImagePositionPatient,\r\n                tolerance\r\n            )\r\n        ) {\r\n            return imageIds[imageIdsIndexc];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\r\n * specified sopInstanceUid and frameNumber for multi-frame images.\r\n *\r\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\r\n * @param  {Number} frameNumber      The frame number.\r\n * @param  {String} imageIds         The list of imageIds.\r\n * @param  {Object} sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\r\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\r\n */\r\nfunction getImageIdOfReferencedFrame(\r\n    sopInstanceUid,\r\n    frameNumber,\r\n    sopUIDImageIdIndexMap\r\n) {\r\n    const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\r\n\r\n    if (!imageId) {\r\n        return;\r\n    }\r\n\r\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\r\n\r\n    return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\r\n}\r\n\r\n/**\r\n * getValidOrientations - returns an array of valid orientations.\r\n *\r\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\r\n * @return {Number[8][6]} An array of valid orientations.\r\n */\r\nfunction getValidOrientations(iop) {\r\n    const orientations = [];\r\n\r\n    // [0,  1,  2]: 0,   0hf,   0vf\r\n    // [3,  4,  5]: 90,  90hf,  90vf\r\n    // [6, 7]:      180, 270\r\n\r\n    orientations[0] = iop;\r\n    orientations[1] = flipIOP.h(iop);\r\n    orientations[2] = flipIOP.v(iop);\r\n\r\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\r\n\r\n    orientations[3] = iop90;\r\n    orientations[4] = flipIOP.h(iop90);\r\n    orientations[5] = flipIOP.v(iop90);\r\n\r\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\r\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\r\n\r\n    return orientations;\r\n}\r\n\r\n/**\r\n * alignPixelDataWithSourceData -\r\n *\r\n * @param {Ndarray} pixelData2D - The data to align.\r\n * @param {Number[6]} iop - The orientation of the image slice.\r\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\r\n * @param {Number} tolerance.\r\n * @return {Ndarray} The aligned pixelData.\r\n */\r\nfunction alignPixelDataWithSourceData(\r\n    pixelData2D,\r\n    iop,\r\n    orientations,\r\n    tolerance\r\n) {\r\n    if (compareArrays(iop, orientations[0], tolerance)) {\r\n        return pixelData2D;\r\n    } else if (compareArrays(iop, orientations[1], tolerance)) {\r\n        // Flipped vertically.\r\n\r\n        // Undo Flip\r\n        return flipMatrix2D.v(pixelData2D);\r\n    } else if (compareArrays(iop, orientations[2], tolerance)) {\r\n        // Flipped horizontally.\r\n\r\n        // Unfo flip\r\n        return flipMatrix2D.h(pixelData2D);\r\n    } else if (compareArrays(iop, orientations[3], tolerance)) {\r\n        //Rotated 90 degrees\r\n\r\n        // Rotate back\r\n        return rotateMatrix902D(pixelData2D);\r\n    } else if (compareArrays(iop, orientations[4], tolerance)) {\r\n        //Rotated 90 degrees and fliped horizontally.\r\n\r\n        // Undo flip and rotate back.\r\n        return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\r\n    } else if (compareArrays(iop, orientations[5], tolerance)) {\r\n        // Rotated 90 degrees and fliped vertically\r\n\r\n        // Unfo flip and rotate back.\r\n        return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\r\n    } else if (compareArrays(iop, orientations[6], tolerance)) {\r\n        // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\r\n\r\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\r\n    } else if (compareArrays(iop, orientations[7], tolerance)) {\r\n        // Rotated 270 degrees\r\n\r\n        // Rotate back.\r\n        return rotateMatrix902D(\r\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * compareArrays - Returns true if array1 and array2 are equal\r\n * within a tolerance.\r\n *\r\n * @param  {Number[]} array1 - An array.\r\n * @param  {Number[]} array2 - An array.\r\n * @param {Number} tolerance.\r\n * @return {Boolean} True if array1 and array2 are equal.\r\n */\r\nfunction compareArrays(array1, array2, tolerance) {\r\n    if (array1.length != array2.length) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < array1.length; ++i) {\r\n        if (!nearlyEqual(array1[i], array2[i], tolerance)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\r\n    const segmentSequence = multiframe.SegmentSequence;\r\n    let data = [];\r\n\r\n    if (Array.isArray(segmentSequence)) {\r\n        data = [undefined, ...segmentSequence];\r\n    } else {\r\n        // Only one segment, will be stored as an object.\r\n        data = [undefined, segmentSequence];\r\n    }\r\n\r\n    return {\r\n        seriesInstanceUid,\r\n        data\r\n    };\r\n}\r\n\r\n/**\r\n * Reads a range of bytes from an array of ArrayBuffer chunks and\r\n * aggregate them into a new Uint8Array.\r\n *\r\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\r\n * @param {number} offset - The offset of the first byte to read.\r\n * @param {number} length - The number of bytes to read.\r\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\r\n */\r\nfunction readFromUnpackedChunks(chunks, offset, length) {\r\n    const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\r\n\r\n    // If all the data is in one chunk, we can just slice that chunk\r\n    if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\r\n        return new Uint8Array(\r\n            chunks[mapping.start.chunkIndex].buffer,\r\n            mapping.start.offset,\r\n            length\r\n        );\r\n    } else {\r\n        // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\r\n        let result = new Uint8Array(length);\r\n        let resultOffset = 0;\r\n\r\n        for (\r\n            let i = mapping.start.chunkIndex;\r\n            i <= mapping.end.chunkIndex;\r\n            i++\r\n        ) {\r\n            let start =\r\n                i === mapping.start.chunkIndex ? mapping.start.offset : 0;\r\n            let end =\r\n                i === mapping.end.chunkIndex\r\n                    ? mapping.end.offset\r\n                    : chunks[i].length;\r\n\r\n            result.set(\r\n                new Uint8Array(chunks[i].buffer, start, end - start),\r\n                resultOffset\r\n            );\r\n            resultOffset += end - start;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\r\n    var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\r\n\r\n    if (offset < 0 || offset + length > totalBytes) {\r\n        throw new Error(\"Offset and length out of bounds\");\r\n    }\r\n\r\n    var startChunkIndex = 0;\r\n    var startOffsetInChunk = offset;\r\n\r\n    while (startOffsetInChunk >= chunks[startChunkIndex].length) {\r\n        startOffsetInChunk -= chunks[startChunkIndex].length;\r\n        startChunkIndex++;\r\n    }\r\n\r\n    var endChunkIndex = startChunkIndex;\r\n    var endOffsetInChunk = startOffsetInChunk + length;\r\n\r\n    while (endOffsetInChunk > chunks[endChunkIndex].length) {\r\n        endOffsetInChunk -= chunks[endChunkIndex].length;\r\n        endChunkIndex++;\r\n    }\r\n\r\n    return {\r\n        start: { chunkIndex: startChunkIndex, offset: startOffsetInChunk },\r\n        end: { chunkIndex: endChunkIndex, offset: endOffsetInChunk }\r\n    };\r\n}\r\n\r\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe) {\r\n    let xAcc = 0;\r\n    let yAcc = 0;\r\n    let zAcc = 0;\r\n    let count = 0;\r\n\r\n    for (const [imageIdIndex, bufferIndices] of Object.entries(\r\n        imageIdIndexBufferIndex\r\n    )) {\r\n        const z = Number(imageIdIndex);\r\n\r\n        if (!bufferIndices || bufferIndices.length === 0) {\r\n            continue;\r\n        }\r\n\r\n        for (const bufferIndex of bufferIndices) {\r\n            const y = Math.floor(bufferIndex / multiframe.Rows);\r\n            const x = bufferIndex % multiframe.Rows;\r\n\r\n            xAcc += x;\r\n            yAcc += y;\r\n            zAcc += z;\r\n\r\n            count++;\r\n        }\r\n    }\r\n\r\n    return { xAcc, yAcc, zAcc, count };\r\n}\r\n\r\nconst Segmentation = {\r\n    generateSegmentation,\r\n    generateToolState,\r\n    fillSegmentation\r\n};\r\n\r\nexport default Segmentation;\r\nexport { fillSegmentation, generateSegmentation, generateToolState };\r\n","import MeasurementReport from \"./MeasurementReport\";\r\nimport Length from \"./Length\";\r\nimport FreehandRoi from \"./FreehandRoi\";\r\nimport Bidirectional from \"./Bidirectional\";\r\nimport EllipticalRoi from \"./EllipticalRoi\";\r\nimport CircleRoi from \"./CircleRoi\";\r\nimport ArrowAnnotate from \"./ArrowAnnotate\";\r\nimport CobbAngle from \"./CobbAngle\";\r\nimport Angle from \"./Angle\";\r\nimport RectangleRoi from \"./RectangleRoi\";\r\n\r\n// Segmentation\r\nimport Segmentation from \"./Segmentation\";\r\n\r\nconst CornerstoneSR = {\r\n    Length,\r\n    FreehandRoi,\r\n    Bidirectional,\r\n    EllipticalRoi,\r\n    CircleRoi,\r\n    ArrowAnnotate,\r\n    MeasurementReport,\r\n    CobbAngle,\r\n    Angle,\r\n    RectangleRoi\r\n};\r\n\r\nconst CornerstoneSEG = {\r\n    Segmentation\r\n};\r\n\r\nexport { CornerstoneSR, CornerstoneSEG };\r\n","import Segmentation_3X from \"./Segmentation_3X\";\r\nimport Segmentation_4X from \"./Segmentation_4X\";\r\n\r\nconst Segmentation = {\r\n    generateSegmentation,\r\n    generateToolState,\r\n    fillSegmentation\r\n};\r\n\r\nexport default Segmentation;\r\n\r\n/**\r\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\r\n *\r\n * @param  {object[]} images    An array of the cornerstone image objects.\r\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\r\n *                                                  For 3.X: the BrushData.\r\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\r\n * @returns {Object}\r\n */\r\nfunction generateSegmentation(\r\n    images,\r\n    labelmaps3DorBrushData,\r\n    options = { includeSliceSpacing: true },\r\n    cornerstoneToolsVersion = 4\r\n) {\r\n    if (cornerstoneToolsVersion === 4) {\r\n        return Segmentation_4X.generateSegmentation(\r\n            images,\r\n            labelmaps3DorBrushData,\r\n            options\r\n        );\r\n    }\r\n\r\n    if (cornerstoneToolsVersion === 3) {\r\n        return Segmentation_3X.generateSegmentation(\r\n            images,\r\n            labelmaps3DorBrushData,\r\n            options\r\n        );\r\n    }\r\n\r\n    console.warn(\r\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\r\n    );\r\n}\r\n\r\n/**\r\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\r\n * derive cornerstoneTools toolState and brush metadata.\r\n *\r\n * @param  {string[]} imageIds    An array of the imageIds.\r\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\r\n * @param {*} metadataProvider\r\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\r\n * @param  {number} tolerance - default value 1.e-3.\r\n * @param  {number} cornerstoneToolsVersion - default value 4.\r\n *\r\n * @returns {Object}  The toolState and an object from which the\r\n *                    segment metadata can be derived.\r\n */\r\nfunction generateToolState(\r\n    imageIds,\r\n    arrayBuffer,\r\n    metadataProvider,\r\n    skipOverlapping = false,\r\n    tolerance = 1e-3,\r\n    cornerstoneToolsVersion = 4\r\n) {\r\n    if (cornerstoneToolsVersion === 4) {\r\n        return Segmentation_4X.generateToolState(\r\n            imageIds,\r\n            arrayBuffer,\r\n            metadataProvider,\r\n            skipOverlapping,\r\n            tolerance\r\n        );\r\n    }\r\n\r\n    if (cornerstoneToolsVersion === 3) {\r\n        return Segmentation_3X.generateToolState(\r\n            imageIds,\r\n            arrayBuffer,\r\n            metadataProvider\r\n        );\r\n    }\r\n\r\n    console.warn(\r\n        `No generateToolState adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\r\n    );\r\n}\r\n\r\n/**\r\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\r\n *\r\n * @param  {object[]} segmentation An empty segmentation derived dataset.\r\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\r\n * @param  {Object} userOptions Options object to override default options.\r\n * @returns {Blob}           description\r\n */\r\nfunction fillSegmentation(\r\n    segmentation,\r\n    inputLabelmaps3D,\r\n    options = { includeSliceSpacing: true },\r\n    cornerstoneToolsVersion = 4\r\n) {\r\n    if (cornerstoneToolsVersion === 4) {\r\n        return Segmentation_4X.fillSegmentation(\r\n            segmentation,\r\n            inputLabelmaps3D,\r\n            options\r\n        );\r\n    }\r\n\r\n    console.warn(\r\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\r\n    );\r\n}\r\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","export default \"Cornerstone3DTools@^0.1.0\";\r\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\r\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\r\n// here this is fine for most labels, but may be problematic at some point.\r\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\r\n\r\n// Cornerstone specified coding scheme for storing findings\r\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\r\n\r\nconst CodingScheme = {\r\n    CodingSchemeDesignator,\r\n    codeValues: {\r\n        CORNERSTONEFREETEXT\r\n    }\r\n};\r\n\r\nexport default CodingScheme;\r\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\r\n\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport { toArray, codeMeaningEquals } from \"../helpers\";\r\nimport Cornerstone3DCodingScheme from \"./CodingScheme\";\r\n\r\nconst { TID1500, addAccessors } = utilities;\r\n\r\nconst { StructuredReport } = derivations;\r\n\r\nconst { Normalizer } = normalizers;\r\n\r\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\r\n\r\nconst { DicomMetaDictionary } = data;\r\n\r\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\r\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\r\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\r\n\r\nconst codeValueMatch = (group, code, oldCode?) => {\r\n    const { ConceptNameCodeSequence } = group;\r\n    if (!ConceptNameCodeSequence) return;\r\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\r\n    return (\r\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\r\n            CodeValue == code.CodeValue) ||\r\n        (oldCode &&\r\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\r\n            CodeValue == oldCode.CodeValue)\r\n    );\r\n};\r\n\r\nfunction getTID300ContentItem(\r\n    tool,\r\n    toolType,\r\n    ReferencedSOPSequence,\r\n    toolClass,\r\n    worldToImageCoords\r\n) {\r\n    const args = toolClass.getTID300RepresentationArguments(\r\n        tool,\r\n        worldToImageCoords\r\n    );\r\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\r\n\r\n    const TID300Measurement = new toolClass.TID300Representation(args);\r\n\r\n    return TID300Measurement;\r\n}\r\n\r\nfunction getMeasurementGroup(\r\n    toolType,\r\n    toolData,\r\n    ReferencedSOPSequence,\r\n    worldToImageCoords\r\n) {\r\n    const toolTypeData = toolData[toolType];\r\n    const toolClass =\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\r\n    if (\r\n        !toolTypeData ||\r\n        !toolTypeData.data ||\r\n        !toolTypeData.data.length ||\r\n        !toolClass\r\n    ) {\r\n        return;\r\n    }\r\n\r\n    // Loop through the array of tool instances\r\n    // for this tool\r\n    const Measurements = toolTypeData.data.map(tool => {\r\n        return getTID300ContentItem(\r\n            tool,\r\n            toolType,\r\n            ReferencedSOPSequence,\r\n            toolClass,\r\n            worldToImageCoords\r\n        );\r\n    });\r\n\r\n    return new TID1501MeasurementGroup(Measurements);\r\n}\r\n\r\nexport default class MeasurementReport {\r\n    public static CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\r\n    public static MEASUREMENT_BY_TOOLTYPE = {};\r\n    public static CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\r\n    public static CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\r\n\r\n    static getCornerstoneLabelFromDefaultState(defaultState) {\r\n        const { findingSites = [], finding } = defaultState;\r\n\r\n        const cornersoneFreeTextCodingValue =\r\n            Cornerstone3DCodingScheme.codeValues.CORNERSTONEFREETEXT;\r\n\r\n        const freeTextLabel = findingSites.find(\r\n            fs => fs.CodeValue === cornersoneFreeTextCodingValue\r\n        );\r\n\r\n        if (freeTextLabel) {\r\n            return freeTextLabel.CodeMeaning;\r\n        }\r\n\r\n        if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\r\n            return finding.CodeMeaning;\r\n        }\r\n    }\r\n\r\n    static generateDatasetMeta() {\r\n        // TODO: what is the correct metaheader\r\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\r\n        // TODO: move meta creation to happen in derivations.js\r\n        const fileMetaInformationVersionArray = new Uint8Array(2);\r\n        fileMetaInformationVersionArray[1] = 1;\r\n\r\n        const _meta = {\r\n            FileMetaInformationVersion: {\r\n                Value: [fileMetaInformationVersionArray.buffer],\r\n                vr: \"OB\"\r\n            },\r\n            //MediaStorageSOPClassUID\r\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\r\n            TransferSyntaxUID: {\r\n                Value: [\"1.2.840.10008.1.2.1\"],\r\n                vr: \"UI\"\r\n            },\r\n            ImplementationClassUID: {\r\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\r\n                vr: \"UI\"\r\n            },\r\n            ImplementationVersionName: {\r\n                Value: [\"dcmjs\"],\r\n                vr: \"SH\"\r\n            }\r\n        };\r\n\r\n        return _meta;\r\n    }\r\n\r\n    static generateDerivationSourceDataset = instance => {\r\n        const _vrMap = {\r\n            PixelData: \"OW\"\r\n        };\r\n\r\n        const _meta = MeasurementReport.generateDatasetMeta();\r\n\r\n        const derivationSourceDataset = {\r\n            ...instance,\r\n            _meta: _meta,\r\n            _vrMap: _vrMap\r\n        };\r\n\r\n        return derivationSourceDataset;\r\n    };\r\n\r\n    static getSetupMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        metadata,\r\n        toolType\r\n    ) {\r\n        const { ContentSequence } = MeasurementGroup;\r\n\r\n        const contentSequenceArr = toArray(ContentSequence);\r\n        const findingGroup = contentSequenceArr.find(group =>\r\n            codeValueMatch(group, FINDING)\r\n        );\r\n        const findingSiteGroups =\r\n            contentSequenceArr.filter(group =>\r\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\r\n            ) || [];\r\n        const NUMGroup = contentSequenceArr.find(\r\n            group => group.ValueType === \"NUM\"\r\n        );\r\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\r\n            group => group.ValueType === \"SCOORD\"\r\n        );\r\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\r\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\r\n            ReferencedSOPSequence;\r\n\r\n        const referencedImageId =\r\n            sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\r\n        const imagePlaneModule = metadata.get(\r\n            \"imagePlaneModule\",\r\n            referencedImageId\r\n        );\r\n\r\n        const finding = findingGroup\r\n            ? addAccessors(findingGroup.ConceptCodeSequence)\r\n            : undefined;\r\n        const findingSites = findingSiteGroups.map(fsg => {\r\n            return addAccessors(fsg.ConceptCodeSequence);\r\n        });\r\n\r\n        const defaultState = {\r\n            description: undefined,\r\n            sopInstanceUid: ReferencedSOPInstanceUID,\r\n            annotation: {\r\n                annotationUID: DicomMetaDictionary.uid(),\r\n                metadata: {\r\n                    toolName: toolType,\r\n                    referencedImageId,\r\n                    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\r\n                    label: \"\"\r\n                },\r\n                data: undefined\r\n            },\r\n            finding,\r\n            findingSites\r\n        };\r\n        if (defaultState.finding) {\r\n            defaultState.description = defaultState.finding.CodeMeaning;\r\n        }\r\n\r\n        defaultState.annotation.metadata.label =\r\n            MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\r\n\r\n        return {\r\n            defaultState,\r\n            NUMGroup,\r\n            SCOORDGroup,\r\n            ReferencedSOPSequence,\r\n            ReferencedSOPInstanceUID,\r\n            ReferencedFrameNumber\r\n        };\r\n    }\r\n\r\n    static generateReport(\r\n        toolState,\r\n        metadataProvider,\r\n        worldToImageCoords,\r\n        options\r\n    ) {\r\n        // ToolState for array of imageIDs to a Report\r\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\r\n        let allMeasurementGroups = [];\r\n\r\n        /* Patient ID\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\r\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\r\n        */\r\n\r\n        const sopInstanceUIDsToSeriesInstanceUIDMap = {};\r\n        const derivationSourceDatasets = [];\r\n\r\n        const _meta = MeasurementReport.generateDatasetMeta();\r\n\r\n        // Loop through each image in the toolData\r\n        Object.keys(toolState).forEach(imageId => {\r\n            const sopCommonModule = metadataProvider.get(\r\n                \"sopCommonModule\",\r\n                imageId\r\n            );\r\n            const instance = metadataProvider.get(\"instance\", imageId);\r\n\r\n            const { sopInstanceUID, sopClassUID } = sopCommonModule;\r\n            const { SeriesInstanceUID: seriesInstanceUID } = instance;\r\n\r\n            sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] =\r\n                seriesInstanceUID;\r\n\r\n            if (\r\n                !derivationSourceDatasets.find(\r\n                    dsd => dsd.SeriesInstanceUID === seriesInstanceUID\r\n                )\r\n            ) {\r\n                // Entry not present for series, create one.\r\n                const derivationSourceDataset =\r\n                    MeasurementReport.generateDerivationSourceDataset(instance);\r\n\r\n                derivationSourceDatasets.push(derivationSourceDataset);\r\n            }\r\n\r\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\r\n            const toolData = toolState[imageId];\r\n            const toolTypes = Object.keys(toolData);\r\n\r\n            const ReferencedSOPSequence = {\r\n                ReferencedSOPClassUID: sopClassUID,\r\n                ReferencedSOPInstanceUID: sopInstanceUID,\r\n                ReferencedFrameNumber: undefined\r\n            };\r\n\r\n            if (\r\n                (instance &&\r\n                    instance.NumberOfFrames &&\r\n                    instance.NumberOfFrames > 1) ||\r\n                Normalizer.isMultiframeSOPClassUID(sopClassUID)\r\n            ) {\r\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\r\n            }\r\n\r\n            // Loop through each tool type for the image\r\n            const measurementGroups = [];\r\n\r\n            toolTypes.forEach(toolType => {\r\n                const group = getMeasurementGroup(\r\n                    toolType,\r\n                    toolData,\r\n                    ReferencedSOPSequence,\r\n                    worldToImageCoords\r\n                );\r\n                if (group) {\r\n                    measurementGroups.push(group);\r\n                }\r\n            });\r\n\r\n            allMeasurementGroups =\r\n                allMeasurementGroups.concat(measurementGroups);\r\n        });\r\n\r\n        const tid1500MeasurementReport = new TID1500MeasurementReport(\r\n            { TID1501MeasurementGroups: allMeasurementGroups },\r\n            options\r\n        );\r\n\r\n        const report = new StructuredReport(derivationSourceDatasets, options);\r\n\r\n        const contentItem = tid1500MeasurementReport.contentItem(\r\n            derivationSourceDatasets,\r\n            { ...options, sopInstanceUIDsToSeriesInstanceUIDMap }\r\n        );\r\n\r\n        // Merge the derived dataset with the content from the Measurement Report\r\n        report.dataset = Object.assign(report.dataset, contentItem);\r\n        report.dataset._meta = _meta;\r\n        report.SpecificCharacterSet = \"ISO_IR 192\";\r\n\r\n        return report;\r\n    }\r\n\r\n    /**\r\n     * Generate Cornerstone tool state from dataset\r\n     */\r\n    static generateToolState(\r\n        dataset,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata,\r\n        hooks\r\n    ) {\r\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\r\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\r\n            throw new Error(\r\n                \"This package can currently only interpret DICOM SR TID 1500\"\r\n            );\r\n        }\r\n\r\n        const REPORT = \"Imaging Measurements\";\r\n        const GROUP = \"Measurement Group\";\r\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\r\n        const TRACKING_UNIQUE_IDENTIFIER = \"Tracking Unique Identifier\";\r\n\r\n        // Identify the Imaging Measurements\r\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\r\n            codeMeaningEquals(REPORT)\r\n        );\r\n\r\n        // Retrieve the Measurements themselves\r\n        const measurementGroups = toArray(\r\n            imagingMeasurementContent.ContentSequence\r\n        ).filter(codeMeaningEquals(GROUP));\r\n\r\n        // For each of the supported measurement types, compute the measurement data\r\n        const measurementData = {};\r\n\r\n        const cornerstoneToolClasses =\r\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\r\n\r\n        const registeredToolClasses = [];\r\n\r\n        Object.keys(cornerstoneToolClasses).forEach(key => {\r\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\r\n            measurementData[key] = [];\r\n        });\r\n\r\n        measurementGroups.forEach(measurementGroup => {\r\n            try {\r\n                const measurementGroupContentSequence = toArray(\r\n                    measurementGroup.ContentSequence\r\n                );\r\n\r\n                const TrackingIdentifierGroup =\r\n                    measurementGroupContentSequence.find(\r\n                        contentItem =>\r\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\r\n                            TRACKING_IDENTIFIER\r\n                    );\r\n\r\n                const TrackingIdentifierValue =\r\n                    TrackingIdentifierGroup.TextValue;\r\n\r\n                const TrackingUniqueIdentifierGroup =\r\n                    measurementGroupContentSequence.find(\r\n                        contentItem =>\r\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\r\n                            TRACKING_UNIQUE_IDENTIFIER\r\n                    );\r\n\r\n                const TrackingUniqueIdentifierValue =\r\n                    TrackingUniqueIdentifierGroup?.UID;\r\n\r\n                const toolClass =\r\n                    hooks?.getToolClass?.(\r\n                        measurementGroup,\r\n                        dataset,\r\n                        registeredToolClasses\r\n                    ) ||\r\n                    registeredToolClasses.find(tc =>\r\n                        tc.isValidCornerstoneTrackingIdentifier(\r\n                            TrackingIdentifierValue\r\n                        )\r\n                    );\r\n\r\n                if (toolClass) {\r\n                    const measurement = toolClass.getMeasurementData(\r\n                        measurementGroup,\r\n                        sopInstanceUIDToImageIdMap,\r\n                        imageToWorldCoords,\r\n                        metadata\r\n                    );\r\n\r\n                    measurement.TrackingUniqueIdentifier =\r\n                        TrackingUniqueIdentifierValue;\r\n\r\n                    console.log(`=== ${toolClass.toolType} ===`);\r\n                    console.log(measurement);\r\n\r\n                    measurementData[toolClass.toolType].push(measurement);\r\n                }\r\n            } catch (e) {\r\n                console.warn(\r\n                    \"Unable to generate tool state for\",\r\n                    measurementGroup,\r\n                    e\r\n                );\r\n            }\r\n        });\r\n\r\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\r\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\r\n        return measurementData;\r\n    }\r\n\r\n    /**\r\n     * Register a new tool type.\r\n     * @param toolClass to perform I/O to DICOM for this tool\r\n     */\r\n    public static registerTool(toolClass) {\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\r\n            toolClass.utilityToolType\r\n        ] = toolClass;\r\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\r\n            toolClass.toolType\r\n        ] = toolClass;\r\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\r\n            toolClass.utilityToolType;\r\n    }\r\n}\r\n","import MeasurementReport from \"./MeasurementReport\";\r\nimport { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport CodingScheme from \"./CodingScheme\";\r\n\r\nconst { Point: TID300Point } = utilities.TID300;\r\n\r\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ARROW_ANNOTATE}`;\r\n\r\nconst { codeValues, CodingSchemeDesignator } = CodingScheme;\r\n\r\nclass ArrowAnnotate {\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                ArrowAnnotate.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const text = defaultState.annotation.metadata.label;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        // Since the arrowAnnotate measurement is just a point, to generate the tool state\r\n        // we derive the second point based on the image size relative to the first point.\r\n        if (worldCoords.length === 1) {\r\n            const imagePixelModule = metadata.get(\r\n                \"imagePixelModule\",\r\n                referencedImageId\r\n            );\r\n\r\n            let xOffset = 10;\r\n            let yOffset = 10;\r\n\r\n            if (imagePixelModule) {\r\n                const { columns, rows } = imagePixelModule;\r\n                xOffset = columns / 10;\r\n                yOffset = rows / 10;\r\n            }\r\n\r\n            const secondPoint = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[0] + xOffset,\r\n                GraphicData[1] + yOffset\r\n            ]);\r\n\r\n            worldCoords.push(secondPoint);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            text,\r\n            handles: {\r\n                arrowFirst: true,\r\n                points: [worldCoords[0], worldCoords[1]],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, metadata } = tool;\r\n        let { finding, findingSites } = tool;\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const { points, arrowFirst } = data.handles;\r\n\r\n        let point;\r\n\r\n        if (arrowFirst) {\r\n            point = points[0];\r\n        } else {\r\n            point = points[1];\r\n        }\r\n\r\n        const pointImage = worldToImageCoords(referencedImageId, point);\r\n\r\n        const TID300RepresentationArguments = {\r\n            points: [\r\n                {\r\n                    x: pointImage[0],\r\n                    y: pointImage[1]\r\n                }\r\n            ],\r\n            trackingIdentifierTextValue,\r\n            findingSites: findingSites || []\r\n        };\r\n\r\n        // If freetext finding isn't present, add it from the tool text.\r\n        if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\r\n            finding = {\r\n                CodeValue: codeValues.CORNERSTONEFREETEXT,\r\n                CodingSchemeDesignator,\r\n                CodeMeaning: data.text\r\n            };\r\n        }\r\n\r\n        TID300RepresentationArguments.finding = finding;\r\n\r\n        return TID300RepresentationArguments;\r\n    }\r\n}\r\n\r\nArrowAnnotate.toolType = ARROW_ANNOTATE;\r\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\r\nArrowAnnotate.TID300Representation = TID300Point;\r\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === ARROW_ANNOTATE;\r\n};\r\n\r\nMeasurementReport.registerTool(ArrowAnnotate);\r\n\r\nexport default ArrowAnnotate;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport { toArray } from \"../helpers\";\r\n\r\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\r\n\r\nconst BIDIRECTIONAL = \"Bidirectional\";\r\nconst LONG_AXIS = \"Long Axis\";\r\nconst SHORT_AXIS = \"Short Axis\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${BIDIRECTIONAL}`;\r\n\r\nclass Bidirectional {\r\n    public static toolType = BIDIRECTIONAL;\r\n    public static utilityToolType = BIDIRECTIONAL;\r\n    public static TID300Representation = TID300Bidirectional;\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === BIDIRECTIONAL;\r\n    };\r\n\r\n    public static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                Bidirectional.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n        const { ContentSequence } = MeasurementGroup;\r\n\r\n        const longAxisNUMGroup = toArray(ContentSequence).find(\r\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\r\n        );\r\n\r\n        const longAxisSCOORDGroup = toArray(\r\n            longAxisNUMGroup.ContentSequence\r\n        ).find(group => group.ValueType === \"SCOORD\");\r\n\r\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\r\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\r\n        );\r\n\r\n        const shortAxisSCOORDGroup = toArray(\r\n            shortAxisNUMGroup.ContentSequence\r\n        ).find(group => group.ValueType === \"SCOORD\");\r\n\r\n        const worldCoords = [];\r\n\r\n        [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\r\n            const { GraphicData } = group;\r\n            for (let i = 0; i < GraphicData.length; i += 2) {\r\n                const point = imageToWorldCoords(referencedImageId, [\r\n                    GraphicData[i],\r\n                    GraphicData[i + 1]\r\n                ]);\r\n                worldCoords.push(point);\r\n            }\r\n        });\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [\r\n                    worldCoords[0],\r\n                    worldCoords[1],\r\n                    worldCoords[2],\r\n                    worldCoords[3]\r\n                ],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\r\n                    width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const { length, width } =\r\n            cachedStats[`imageId:${referencedImageId}`] || {};\r\n        const { points } = handles;\r\n\r\n        // Find the length and width point pairs by comparing the distances of the points at 0,1 to points at 2,3\r\n        const firstPointPairs = [points[0], points[1]];\r\n        const secondPointPairs = [points[2], points[3]];\r\n\r\n        const firstPointPairsDistance = Math.sqrt(\r\n            Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) +\r\n                Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) +\r\n                Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2)\r\n        );\r\n\r\n        const secondPointPairsDistance = Math.sqrt(\r\n            Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) +\r\n                Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) +\r\n                Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2)\r\n        );\r\n\r\n        let shortAxisPoints;\r\n        let longAxisPoints;\r\n        if (firstPointPairsDistance > secondPointPairsDistance) {\r\n            shortAxisPoints = firstPointPairs;\r\n            longAxisPoints = secondPointPairs;\r\n        } else {\r\n            shortAxisPoints = secondPointPairs;\r\n            longAxisPoints = firstPointPairs;\r\n        }\r\n\r\n        const longAxisStartImage = worldToImageCoords(\r\n            referencedImageId,\r\n            shortAxisPoints[0]\r\n        );\r\n        const longAxisEndImage = worldToImageCoords(\r\n            referencedImageId,\r\n            shortAxisPoints[1]\r\n        );\r\n        const shortAxisStartImage = worldToImageCoords(\r\n            referencedImageId,\r\n            longAxisPoints[0]\r\n        );\r\n        const shortAxisEndImage = worldToImageCoords(\r\n            referencedImageId,\r\n            longAxisPoints[1]\r\n        );\r\n\r\n        return {\r\n            longAxis: {\r\n                point1: {\r\n                    x: longAxisStartImage[0],\r\n                    y: longAxisStartImage[1]\r\n                },\r\n                point2: {\r\n                    x: longAxisEndImage[0],\r\n                    y: longAxisEndImage[1]\r\n                }\r\n            },\r\n            shortAxis: {\r\n                point1: {\r\n                    x: shortAxisStartImage[0],\r\n                    y: shortAxisStartImage[1]\r\n                },\r\n                point2: {\r\n                    x: shortAxisEndImage[0],\r\n                    y: shortAxisEndImage[1]\r\n                }\r\n            },\r\n            longAxisLength: length,\r\n            shortAxisLength: width,\r\n            trackingIdentifierTextValue,\r\n            finding: finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(Bidirectional);\r\n\r\nexport default Bidirectional;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\r\n\r\nconst MEASUREMENT_TYPE = \"Angle\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\r\n\r\nclass Angle {\r\n    public static toolType = MEASUREMENT_TYPE;\r\n    public static utilityToolType = MEASUREMENT_TYPE;\r\n    public static TID300Representation = TID300CobbAngle;\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === MEASUREMENT_TYPE;\r\n    };\r\n\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    public static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                Angle.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [worldCoords[0], worldCoords[1], worldCoords[3]],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    angle: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : null\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"Angle.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\r\n        const middle = worldToImageCoords(referencedImageId, handles.points[1]);\r\n\r\n        const end = worldToImageCoords(referencedImageId, handles.points[2]);\r\n\r\n        const point1 = { x: start1[0], y: start1[1] };\r\n        const point2 = { x: middle[0], y: middle[1] };\r\n        const point3 = point2;\r\n        const point4 = { x: end[0], y: end[1] };\r\n\r\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\r\n\r\n        // Represented as a cobb angle\r\n        return {\r\n            point1,\r\n            point2,\r\n            point3,\r\n            point4,\r\n            rAngle: angle,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(Angle);\r\n\r\nexport default Angle;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\r\n\r\nconst MEASUREMENT_TYPE = \"CobbAngle\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\r\n\r\nclass CobbAngle {\r\n    public static toolType = MEASUREMENT_TYPE;\r\n    public static utilityToolType = MEASUREMENT_TYPE;\r\n    public static TID300Representation = TID300CobbAngle;\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === MEASUREMENT_TYPE;\r\n    };\r\n\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    public static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                CobbAngle.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [\r\n                    worldCoords[0],\r\n                    worldCoords[1],\r\n                    worldCoords[2],\r\n                    worldCoords[3]\r\n                ],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    angle: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : null\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\r\n        const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\r\n\r\n        const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\r\n        const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\r\n\r\n        const point1 = { x: start1[0], y: start1[1] };\r\n        const point2 = { x: end1[0], y: end1[1] };\r\n        const point3 = { x: start2[0], y: start2[1] };\r\n        const point4 = { x: end2[0], y: end2[1] };\r\n\r\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            point3,\r\n            point4,\r\n            rAngle: angle,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(CobbAngle);\r\n\r\nexport default CobbAngle;\r\n","import CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\n\r\nexport default function isValidCornerstoneTrackingIdentifier(\r\n    trackingIdentifier: string\r\n): boolean {\r\n    if (!trackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone3DTag, toolType] = trackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n        return false;\r\n    }\r\n\r\n    // The following is needed since the new cornerstone3D has changed\r\n    // case names such as EllipticalRoi to EllipticalROI\r\n    return toolType.toLowerCase() === this.toolType.toLowerCase();\r\n}\r\n","import { utilities } from \"dcmjs\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\r\n\r\nconst { Circle: TID300Circle } = utilities.TID300;\r\n\r\nconst CIRCLEROI = \"CircleROI\";\r\n\r\nclass CircleROI {\r\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${CIRCLEROI}`;\r\n    static toolType = CIRCLEROI;\r\n    static utilityToolType = CIRCLEROI;\r\n    static TID300Representation = TID300Circle;\r\n    static isValidCornerstoneTrackingIdentifier =\r\n        isValidCornerstoneTrackingIdentifier;\r\n\r\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                CircleROI.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        // GraphicData is ordered as [centerX, centerY, endX, endY]\r\n        const pointsWorld = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const worldPos = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n\r\n            pointsWorld.push(worldPos);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [...pointsWorld],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    area: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : 0,\r\n                    // Dummy values to be updated by cornerstone\r\n                    radius: 0,\r\n                    perimeter: 0\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\r\n     *\r\n     * @param {Object} tool\r\n     * @returns\r\n     */\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const center = worldToImageCoords(referencedImageId, handles.points[0]);\r\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\r\n\r\n        const points = [];\r\n        points.push({ x: center[0], y: center[1] });\r\n        points.push({ x: end[0], y: end[1] });\r\n\r\n        const { area, radius } =\r\n            cachedStats[`imageId:${referencedImageId}`] || {};\r\n        const perimeter = 2 * Math.PI * radius;\r\n\r\n        return {\r\n            area,\r\n            perimeter,\r\n            radius,\r\n            points,\r\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(CircleROI);\r\n\r\nexport default CircleROI;\r\n","import { vec3 } from \"gl-matrix\";\r\nimport { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\r\n\r\ntype Point3 = [number, number, number];\r\n\r\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\r\n\r\nconst ELLIPTICALROI = \"EllipticalROI\";\r\nconst EPSILON = 1e-4;\r\n\r\nclass EllipticalROI {\r\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ELLIPTICALROI}`;\r\n    static toolType = ELLIPTICALROI;\r\n    static utilityToolType = ELLIPTICALROI;\r\n    static TID300Representation = TID300Ellipse;\r\n    static isValidCornerstoneTrackingIdentifier =\r\n        isValidCornerstoneTrackingIdentifier;\r\n\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                EllipticalROI.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\r\n        // But Cornerstone3D points are ordered as top, bottom, left, right for the\r\n        // ellipse so we need to identify if the majorAxis is horizontal or vertical\r\n        // in the image plane and then choose the correct points to use for the ellipse.\r\n        const pointsWorld: Point3[] = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const worldPos = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n\r\n            pointsWorld.push(worldPos);\r\n        }\r\n\r\n        const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\r\n        const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\r\n        const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\r\n        const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\r\n\r\n        const majorAxisVec = vec3.create();\r\n        vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\r\n\r\n        // normalize majorAxisVec to avoid scaling issues\r\n        vec3.normalize(majorAxisVec, majorAxisVec);\r\n\r\n        const minorAxisVec = vec3.create();\r\n        vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\r\n        vec3.normalize(minorAxisVec, minorAxisVec);\r\n\r\n        const imagePlaneModule = metadata.get(\r\n            \"imagePlaneModule\",\r\n            referencedImageId\r\n        );\r\n\r\n        if (!imagePlaneModule) {\r\n            throw new Error(\"imageId does not have imagePlaneModule metadata\");\r\n        }\r\n\r\n        const { columnCosines } = imagePlaneModule;\r\n\r\n        // find which axis is parallel to the columnCosines\r\n        const columnCosinesVec = vec3.fromValues(\r\n            columnCosines[0],\r\n            columnCosines[1],\r\n            columnCosines[2]\r\n        );\r\n        const projectedMajorAxisOnColVec = vec3.dot(\r\n            columnCosinesVec,\r\n            majorAxisVec\r\n        );\r\n\r\n        const projectedMinorAxisOnColVec = vec3.dot(\r\n            columnCosinesVec,\r\n            minorAxisVec\r\n        );\r\n\r\n        const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\r\n        const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\r\n\r\n        let ellipsePoints = [];\r\n        if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\r\n            ellipsePoints = [\r\n                pointsWorld[0],\r\n                pointsWorld[1],\r\n                pointsWorld[2],\r\n                pointsWorld[3]\r\n            ];\r\n        } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\r\n            ellipsePoints = [\r\n                pointsWorld[2],\r\n                pointsWorld[3],\r\n                pointsWorld[0],\r\n                pointsWorld[1]\r\n            ];\r\n        } else {\r\n            console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [...ellipsePoints],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    area: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : 0\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n        const rotation = data.initialRotation || 0;\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n        let top, bottom, left, right;\r\n        // this way when it's restored we can assume the initial rotation is 0.\r\n        if (rotation == 90 || rotation == 270) {\r\n            bottom = worldToImageCoords(referencedImageId, handles.points[2]);\r\n            top = worldToImageCoords(referencedImageId, handles.points[3]);\r\n            left = worldToImageCoords(referencedImageId, handles.points[0]);\r\n            right = worldToImageCoords(referencedImageId, handles.points[1]);\r\n        } else {\r\n            top = worldToImageCoords(referencedImageId, handles.points[0]);\r\n            bottom = worldToImageCoords(referencedImageId, handles.points[1]);\r\n            left = worldToImageCoords(referencedImageId, handles.points[2]);\r\n            right = worldToImageCoords(referencedImageId, handles.points[3]);\r\n        }\r\n\r\n        // find the major axis and minor axis\r\n        const topBottomLength = Math.abs(top[1] - bottom[1]);\r\n        const leftRightLength = Math.abs(left[0] - right[0]);\r\n\r\n        const points = [];\r\n        if (topBottomLength > leftRightLength) {\r\n            // major axis is bottom to top\r\n            points.push({ x: top[0], y: top[1] });\r\n            points.push({ x: bottom[0], y: bottom[1] });\r\n\r\n            // minor axis is left to right\r\n            points.push({ x: left[0], y: left[1] });\r\n            points.push({ x: right[0], y: right[1] });\r\n        } else {\r\n            // major axis is left to right\r\n            points.push({ x: left[0], y: left[1] });\r\n            points.push({ x: right[0], y: right[1] });\r\n\r\n            // minor axis is bottom to top\r\n            points.push({ x: top[0], y: top[1] });\r\n            points.push({ x: bottom[0], y: bottom[1] });\r\n        }\r\n\r\n        const { area } = cachedStats[`imageId:${referencedImageId}`] || {};\r\n\r\n        return {\r\n            area,\r\n            points,\r\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(EllipticalROI);\r\n\r\nexport default EllipticalROI;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { Polyline: TID300Polyline } = utilities.TID300;\r\n\r\nconst TOOLTYPE = \"RectangleROI\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${TOOLTYPE}`;\r\n\r\nclass RectangleROI {\r\n    public static toolType = TOOLTYPE;\r\n    public static utilityToolType = TOOLTYPE;\r\n    public static TID300Representation = TID300Polyline;\r\n\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === TOOLTYPE;\r\n    };\r\n\r\n    public static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                RectangleROI.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [\r\n                    worldCoords[0],\r\n                    worldCoords[1],\r\n                    worldCoords[3],\r\n                    worldCoords[2]\r\n                ],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    area: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : null\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const corners = handles.points.map(point =>\r\n            worldToImageCoords(referencedImageId, point)\r\n        );\r\n\r\n        const { area, perimeter } = cachedStats;\r\n\r\n        return {\r\n            points: [\r\n                corners[0],\r\n                corners[1],\r\n                corners[3],\r\n                corners[2],\r\n                corners[0]\r\n            ],\r\n            area,\r\n            perimeter,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(RectangleROI);\r\n\r\nexport default RectangleROI;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { Length: TID300Length } = utilities.TID300;\r\n\r\nconst LENGTH = \"Length\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${LENGTH}`;\r\n\r\nclass Length {\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                Length.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [worldCoords[0], worldCoords[1]],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    length: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : 0\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { cachedStats = {}, handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"Length.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const start = worldToImageCoords(referencedImageId, handles.points[0]);\r\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\r\n\r\n        const point1 = { x: start[0], y: start[1] };\r\n        const point2 = { x: end[0], y: end[1] };\r\n\r\n        const { length: distance } =\r\n            cachedStats[`imageId:${referencedImageId}`] || {};\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            distance,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nLength.toolType = LENGTH;\r\nLength.utilityToolType = LENGTH;\r\nLength.TID300Representation = TID300Length;\r\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === LENGTH;\r\n};\r\n\r\nMeasurementReport.registerTool(Length);\r\n\r\nexport default Length;\r\n","import MeasurementReport from \"./MeasurementReport\";\r\nimport { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport { vec3 } from \"gl-matrix\";\r\n\r\nconst { Polyline: TID300Polyline } = utilities.TID300;\r\n\r\nconst PLANARFREEHANDROI = \"PlanarFreehandROI\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PLANARFREEHANDROI}`;\r\nconst closedContourThreshold = 1e-5;\r\n\r\nclass PlanarFreehandROI {\r\n    public static toolType = PLANARFREEHANDROI;\r\n    public static utilityToolType = PLANARFREEHANDROI;\r\n    public static TID300Representation = TID300Polyline;\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === PLANARFREEHANDROI;\r\n    };\r\n\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                PlanarFreehandROI.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const worldCoords = [];\r\n\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const distanceBetweenFirstAndLastPoint = vec3.distance(\r\n            worldCoords[worldCoords.length - 1],\r\n            worldCoords[0]\r\n        );\r\n\r\n        let isOpenContour = true;\r\n\r\n        // If the contour is closed, this should have been encoded as exactly the same point, so check for a very small difference.\r\n        if (distanceBetweenFirstAndLastPoint < closedContourThreshold) {\r\n            worldCoords.pop(); // Remove the last element which is duplicated.\r\n\r\n            isOpenContour = false;\r\n        }\r\n\r\n        const points = [];\r\n\r\n        if (isOpenContour) {\r\n            points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            contour: { polyline: worldCoords, closed: !isOpenContour },\r\n            handles: {\r\n                points,\r\n                activeHandleIndex: null,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {\r\n                [`imageId:${referencedImageId}`]: {\r\n                    area: NUMGroup\r\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\r\n                        : null\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n\r\n        const { polyline, closed } = data.contour;\r\n        const isOpenContour = closed !== true;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const points = polyline.map(worldPos =>\r\n            worldToImageCoords(referencedImageId, worldPos)\r\n        );\r\n\r\n        if (!isOpenContour) {\r\n            // Need to repeat the first point at the end of to have an explicitly closed contour.\r\n            const firstPoint = points[0];\r\n\r\n            // Explicitly expand to avoid ciruclar references.\r\n            points.push([firstPoint[0], firstPoint[1]]);\r\n        }\r\n\r\n        const { area, areaUnit, modalityUnit, perimeter, mean, max, stdDev } =\r\n            data.cachedStats[`imageId:${referencedImageId}`] || {};\r\n\r\n        return {\r\n            /** From cachedStats */\r\n            points,\r\n            area,\r\n            areaUnit,\r\n            perimeter,\r\n            modalityUnit,\r\n            mean,\r\n            max,\r\n            stdDev,\r\n            /** Other */\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(PlanarFreehandROI);\r\n\r\nexport default PlanarFreehandROI;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { Point: TID300Point } = utilities.TID300;\r\n\r\nconst PROBE = \"Probe\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PROBE}`;\r\n\r\nclass Probe {\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                Probe.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: worldCoords,\r\n                activeHandleIndex: null,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, metadata } = tool;\r\n        let { finding, findingSites } = tool;\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"Probe.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const { points } = data.handles;\r\n\r\n        const pointsImage = points.map(point => {\r\n            const pointImage = worldToImageCoords(referencedImageId, point);\r\n            return {\r\n                x: pointImage[0],\r\n                y: pointImage[1]\r\n            };\r\n        });\r\n\r\n        const TID300RepresentationArguments = {\r\n            points: pointsImage,\r\n            trackingIdentifierTextValue,\r\n            findingSites: findingSites || [],\r\n            finding\r\n        };\r\n\r\n        return TID300RepresentationArguments;\r\n    }\r\n}\r\n\r\nProbe.toolType = PROBE;\r\nProbe.utilityToolType = PROBE;\r\nProbe.TID300Representation = TID300Point;\r\nProbe.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n    if (!TrackingIdentifier.includes(\":\")) {\r\n        return false;\r\n    }\r\n\r\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n        return false;\r\n    }\r\n\r\n    return toolType === PROBE;\r\n};\r\n\r\nMeasurementReport.registerTool(Probe);\r\n\r\nexport default Probe;\r\n","import { utilities } from \"dcmjs\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\nimport MeasurementReport from \"./MeasurementReport\";\r\n\r\nconst { Length: TID300Length } = utilities.TID300;\r\n\r\nconst ULTRASOUND_DIRECTIONAL = \"UltrasoundDirectionalTool\";\r\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ULTRASOUND_DIRECTIONAL}`;\r\n\r\nclass UltrasoundDirectional {\r\n    public static toolType = ULTRASOUND_DIRECTIONAL;\r\n    public static utilityToolType = ULTRASOUND_DIRECTIONAL;\r\n    public static TID300Representation = TID300Length;\r\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\r\n        if (!TrackingIdentifier.includes(\":\")) {\r\n            return false;\r\n        }\r\n\r\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\r\n\r\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\r\n            return false;\r\n        }\r\n\r\n        return toolType === ULTRASOUND_DIRECTIONAL;\r\n    };\r\n\r\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\r\n    static getMeasurementData(\r\n        MeasurementGroup,\r\n        sopInstanceUIDToImageIdMap,\r\n        imageToWorldCoords,\r\n        metadata\r\n    ) {\r\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\r\n            MeasurementReport.getSetupMeasurementData(\r\n                MeasurementGroup,\r\n                sopInstanceUIDToImageIdMap,\r\n                metadata,\r\n                UltrasoundDirectional.toolType\r\n            );\r\n\r\n        const referencedImageId =\r\n            defaultState.annotation.metadata.referencedImageId;\r\n\r\n        const { GraphicData } = SCOORDGroup;\r\n        const worldCoords = [];\r\n        for (let i = 0; i < GraphicData.length; i += 2) {\r\n            const point = imageToWorldCoords(referencedImageId, [\r\n                GraphicData[i],\r\n                GraphicData[i + 1]\r\n            ]);\r\n            worldCoords.push(point);\r\n        }\r\n\r\n        const state = defaultState;\r\n\r\n        state.annotation.data = {\r\n            handles: {\r\n                points: [worldCoords[0], worldCoords[1]],\r\n                activeHandleIndex: 0,\r\n                textBox: {\r\n                    hasMoved: false\r\n                }\r\n            },\r\n            cachedStats: {},\r\n            frameNumber: ReferencedFrameNumber\r\n        };\r\n\r\n        return state;\r\n    }\r\n\r\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\r\n        const { data, finding, findingSites, metadata } = tool;\r\n        const { handles } = data;\r\n\r\n        const { referencedImageId } = metadata;\r\n\r\n        if (!referencedImageId) {\r\n            throw new Error(\r\n                \"UltrasoundDirectionalTool.getTID300RepresentationArguments: referencedImageId is not defined\"\r\n            );\r\n        }\r\n\r\n        const start = worldToImageCoords(referencedImageId, handles.points[0]);\r\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\r\n\r\n        const point1 = { x: start[0], y: start[1] };\r\n        const point2 = { x: end[0], y: end[1] };\r\n\r\n        return {\r\n            point1,\r\n            point2,\r\n            trackingIdentifierTextValue,\r\n            finding,\r\n            findingSites: findingSites || []\r\n        };\r\n    }\r\n}\r\n\r\nMeasurementReport.registerTool(UltrasoundDirectional);\r\n\r\nexport default UltrasoundDirectional;\r\n","import { normalizers, derivations } from \"dcmjs\";\r\nimport { fillSegmentation } from \"../../Cornerstone/Segmentation_4X\";\r\n\r\nconst { Normalizer } = normalizers;\r\nconst { Segmentation: SegmentationDerivation } = derivations;\r\n\r\n/**\r\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\r\n *\r\n * @param images - An array of the cornerstone image objects, which includes imageId and metadata\r\n * @param labelmaps - An array of the 3D Volumes that contain the segmentation data.\r\n */\r\nfunction generateSegmentation(images, labelmaps, metadata, options = {}) {\r\n    const segmentation = _createMultiframeSegmentationFromReferencedImages(\r\n        images,\r\n        metadata,\r\n        options\r\n    );\r\n    return fillSegmentation(segmentation, labelmaps, options);\r\n}\r\n\r\n/**\r\n * _createMultiframeSegmentationFromReferencedImages - description\r\n *\r\n * @param images - An array of the cornerstone image objects related to the reference\r\n * series that the segmentation is derived from. You can use methods such as\r\n * volume.getCornerstoneImages() to get this array.\r\n *\r\n * @param options - the options object for the SegmentationDerivation.\r\n * @returns The Seg derived dataSet.\r\n */\r\nfunction _createMultiframeSegmentationFromReferencedImages(\r\n    images,\r\n    metadata,\r\n    options\r\n) {\r\n    const datasets = images.map(image => {\r\n        // add the sopClassUID to the dataset\r\n        const instance = metadata.get(\"instance\", image.imageId);\r\n        return {\r\n            ...image,\r\n            ...instance,\r\n            // Todo: move to dcmjs tag style\r\n            SOPClassUID: instance.SopClassUID || instance.SOPClassUID,\r\n            SOPInstanceUID: instance.SopInstanceUID || instance.SOPInstanceUID,\r\n            PixelData: image.getPixelData(),\r\n            _vrMap: {\r\n                PixelData: \"OW\"\r\n            },\r\n            _meta: {}\r\n        };\r\n    });\r\n\r\n    const multiframe = Normalizer.normalizeToDataset(datasets);\r\n\r\n    return new SegmentationDerivation([multiframe], options);\r\n}\r\n\r\nexport { generateSegmentation };\r\n","import { CornerstoneSEG } from \"../../Cornerstone\";\r\n\r\nconst { Segmentation } = CornerstoneSEG;\r\nconst { generateToolState: generateToolStateCornerstoneLegacy } = Segmentation;\r\n\r\n/**\r\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\r\n * derive cornerstoneTools toolState and brush metadata.\r\n *\r\n * @param   imageIds - An array of the imageIds.\r\n * @param   arrayBuffer - The SEG arrayBuffer.\r\n * @param   skipOverlapping - skip checks for overlapping segs, default value false.\r\n * @param   tolerance - default value 1.e-3.\r\n *\r\n * @returns a list of array buffer for each labelMap\r\n *  an object from which the segment metadata can be derived\r\n *  list containing the track of segments per frame\r\n *  list containing the track of segments per frame for each labelMap                   (available only for the overlapping case).\r\n */\r\nfunction generateToolState(\r\n    imageIds,\r\n    arrayBuffer,\r\n    metadataProvider,\r\n    skipOverlapping = false,\r\n    tolerance = 1e-3\r\n) {\r\n    return generateToolStateCornerstoneLegacy(\r\n        imageIds,\r\n        arrayBuffer,\r\n        metadataProvider,\r\n        skipOverlapping,\r\n        tolerance\r\n    );\r\n}\r\n\r\nexport { generateToolState };\r\n","/**\r\n * Generates 2D label maps from a 3D label map.\r\n * @param labelmap3D - The 3D label map object to generate 2D label maps from. It is derived\r\n * from the volume labelmap.\r\n * @returns The label map object containing the 2D label maps and segments on label maps.\r\n */\r\nfunction generateLabelMaps2DFrom3D(labelmap3D): {\r\n    scalarData: number[];\r\n    dimensions: number[];\r\n    segmentsOnLabelmap: number[];\r\n    labelmaps2D: {\r\n        segmentsOnLabelmap: number[];\r\n        pixelData: number[];\r\n        rows: number;\r\n        columns: number;\r\n    }[];\r\n} {\r\n    // 1. we need to generate labelmaps2D from labelmaps3D, a labelmap2D is for each\r\n    // slice\r\n    const { scalarData, dimensions } = labelmap3D;\r\n\r\n    // scalarData is a flat array of all the pixels in the volume.\r\n    const labelmaps2D = [];\r\n    const segmentsOnLabelmap3D = new Set();\r\n\r\n    // X-Y are the row and column dimensions, Z is the number of slices.\r\n    for (let z = 0; z < dimensions[2]; z++) {\r\n        const pixelData = scalarData.slice(\r\n            z * dimensions[0] * dimensions[1],\r\n            (z + 1) * dimensions[0] * dimensions[1]\r\n        );\r\n\r\n        const segmentsOnLabelmap = [];\r\n\r\n        for (let i = 0; i < pixelData.length; i++) {\r\n            const segment = pixelData[i];\r\n            if (!segmentsOnLabelmap.includes(segment) && segment !== 0) {\r\n                segmentsOnLabelmap.push(segment);\r\n            }\r\n        }\r\n\r\n        const labelmap2D = {\r\n            segmentsOnLabelmap,\r\n            pixelData,\r\n            rows: dimensions[1],\r\n            columns: dimensions[0]\r\n        };\r\n\r\n        if (segmentsOnLabelmap.length === 0) {\r\n            continue;\r\n        }\r\n\r\n        segmentsOnLabelmap.forEach(segmentIndex => {\r\n            segmentsOnLabelmap3D.add(segmentIndex);\r\n        });\r\n\r\n        labelmaps2D[dimensions[2] - 1 - z] = labelmap2D;\r\n    }\r\n\r\n    // remove segment 0 from segmentsOnLabelmap3D\r\n    labelmap3D.segmentsOnLabelmap = Array.from(segmentsOnLabelmap3D);\r\n\r\n    labelmap3D.labelmaps2D = labelmaps2D;\r\n\r\n    return labelmap3D;\r\n}\r\n\r\nexport { generateLabelMaps2DFrom3D };\r\n","export default function getReferencedFrameOfReferenceSequence(\r\n    metadata,\r\n    metadataProvider,\r\n    dataset\r\n) {\r\n    const { referencedImageId: imageId, FrameOfReferenceUID } = metadata;\r\n    const instance = metadataProvider.get(\"instance\", imageId);\r\n    const { SeriesInstanceUID } = instance;\r\n\r\n    const { ReferencedSeriesSequence } = dataset;\r\n\r\n    return [\r\n        {\r\n            FrameOfReferenceUID,\r\n            RTReferencedStudySequence: [\r\n                {\r\n                    ReferencedSOPClassUID: dataset.SOPClassUID,\r\n                    ReferencedSOPInstanceUID: dataset.SOPInstanceUID,\r\n                    RTReferencedSeriesSequence: [\r\n                        {\r\n                            SeriesInstanceUID,\r\n                            ContourImageSequence: [\r\n                                ...ReferencedSeriesSequence[0]\r\n                                    .ReferencedInstanceSequence\r\n                            ]\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        }\r\n    ];\r\n}\r\n","export default function getReferencedSeriesSequence(\r\n    metadata,\r\n    _index,\r\n    metadataProvider,\r\n    DicomMetadataStore\r\n) {\r\n    // grab imageId from toolData\r\n    const { referencedImageId: imageId } = metadata;\r\n    const instance = metadataProvider.get(\"instance\", imageId);\r\n    const { SeriesInstanceUID, StudyInstanceUID } = instance;\r\n\r\n    const ReferencedSeriesSequence = [];\r\n    if (SeriesInstanceUID) {\r\n        const series = DicomMetadataStore.getSeries(\r\n            StudyInstanceUID,\r\n            SeriesInstanceUID\r\n        );\r\n\r\n        const ReferencedSeries = {\r\n            SeriesInstanceUID,\r\n            ReferencedInstanceSequence: []\r\n        };\r\n\r\n        series.instances.forEach(instance => {\r\n            const { SOPInstanceUID, SOPClassUID } = instance;\r\n            ReferencedSeries.ReferencedInstanceSequence.push({\r\n                ReferencedSOPClassUID: SOPClassUID,\r\n                ReferencedSOPInstanceUID: SOPInstanceUID\r\n            });\r\n        });\r\n\r\n        ReferencedSeriesSequence.push(ReferencedSeries);\r\n    }\r\n\r\n    return ReferencedSeriesSequence;\r\n}\r\n","export default function getStructureSetModule(contour, index) {\r\n    const { FrameOfReferenceUID } = contour.metadata;\r\n\r\n    return {\r\n        ROINumber: index + 1,\r\n        ROIName: contour.name || `Todo: name ${index + 1}`,\r\n        ROIDescription: `Todo: description ${index + 1}`,\r\n        ROIGenerationAlgorithm: \"Todo: algorithm\",\r\n        ReferencedFrameOfReferenceUID: FrameOfReferenceUID\r\n    };\r\n}\r\n","import { utilities } from \"@cornerstonejs/tools\";\r\nimport dcmjs from \"dcmjs\";\r\nimport getPatientModule from \"./utilities/getPatientModule\";\r\nimport getReferencedFrameOfReferenceSequence from \"./utilities/getReferencedFrameOfReferenceSequence\";\r\nimport getReferencedSeriesSequence from \"./utilities/getReferencedSeriesSequence\";\r\nimport getRTROIObservationsSequence from \"./utilities/getRTROIObservationsSequence\";\r\nimport getRTSeriesModule from \"./utilities/getRTSeriesModule\";\r\nimport getStructureSetModule from \"./utilities/getStructureSetModule\";\r\n\r\nconst { generateContourSetsFromLabelmap, AnnotationToPointData } =\r\n    utilities.contours;\r\nconst { DicomMetaDictionary } = dcmjs.data;\r\n\r\n/**\r\n * Convert handles to RTSS report containing the dcmjs dicom dataset.\r\n *\r\n * Note: current WIP and using segmentation to contour conversion,\r\n * routine that is not fully tested\r\n *\r\n * @param segmentations - Cornerstone tool segmentations data\r\n * @param metadataProvider - Metadata provider\r\n * @param DicomMetadataStore - metadata store instance\r\n * @param cs - cornerstone instance\r\n * @param csTools - cornerstone tool instance\r\n * @returns Report object containing the dataset\r\n */\r\nfunction generateRTSSFromSegmentations(\r\n    segmentations,\r\n    metadataProvider,\r\n    DicomMetadataStore\r\n) {\r\n    // Convert segmentations to ROIContours\r\n    const roiContours = [];\r\n\r\n    const contourSets = generateContourSetsFromLabelmap({\r\n        segmentations\r\n    });\r\n\r\n    contourSets.forEach((contourSet, segIndex) => {\r\n        // Check contour set isn't undefined\r\n        if (contourSet) {\r\n            const contourSequence = [];\r\n            contourSet.sliceContours.forEach(sliceContour => {\r\n                /**\r\n                 * addContour - Adds a new ROI with related contours to ROIContourSequence\r\n                 *\r\n                 * @param newContour - cornerstoneTools `ROIContour` object\r\n                 *\r\n                 * newContour = {\r\n                 *   name: string,\r\n                 *   description: string,\r\n                 *   contourSequence: array[contour]\r\n                 *   color: array[number],\r\n                 *   metadata: {\r\n                 *       referencedImageId: string,\r\n                 *       FrameOfReferenceUID: string\r\n                 *     }\r\n                 * }\r\n                 *\r\n                 * contour = {\r\n                 *   ContourImageSequence: array[\r\n                 *       { ReferencedSOPClassUID: string, ReferencedSOPInstanceUID: string}\r\n                 *     ]\r\n                 *   ContourGeometricType: string,\r\n                 *   NumberOfContourPoints: number,\r\n                 *   ContourData: array[number]\r\n                 * }\r\n                 */\r\n                // Note: change needed if support non-planar contour representation is needed\r\n                const sopCommon = metadataProvider.get(\r\n                    \"sopCommonModule\",\r\n                    sliceContour.referencedImageId\r\n                );\r\n                const ReferencedSOPClassUID = sopCommon.sopClassUID;\r\n                const ReferencedSOPInstanceUID = sopCommon.sopInstanceUID;\r\n                const ContourImageSequence = [\r\n                    { ReferencedSOPClassUID, ReferencedSOPInstanceUID } // NOTE: replace in dcmjs?\r\n                ];\r\n\r\n                const sliceContourPolyData = sliceContour.polyData;\r\n\r\n                sliceContour.contours.forEach((contour, index) => {\r\n                    const ContourGeometricType = contour.type;\r\n                    const NumberOfContourPoints = contour.contourPoints.length;\r\n                    const ContourData = [];\r\n\r\n                    contour.contourPoints.forEach(point => {\r\n                        const pointData = sliceContourPolyData.points[point];\r\n                        pointData[0] = +pointData[0].toFixed(2);\r\n                        pointData[1] = +pointData[1].toFixed(2);\r\n                        pointData[2] = +pointData[2].toFixed(2);\r\n                        ContourData.push(pointData[0]);\r\n                        ContourData.push(pointData[1]);\r\n                        ContourData.push(pointData[2]);\r\n                    });\r\n\r\n                    contourSequence.push({\r\n                        ContourImageSequence,\r\n                        ContourGeometricType,\r\n                        NumberOfContourPoints,\r\n                        ContourNumber: index + 1,\r\n                        ContourData\r\n                    });\r\n                });\r\n            });\r\n\r\n            const segLabel = contourSet.label || `Segment ${segIndex + 1}`;\r\n\r\n            const ROIContour = {\r\n                name: segLabel,\r\n                description: segLabel,\r\n                contourSequence,\r\n                color: contourSet.color,\r\n                metadata: contourSet.metadata\r\n            };\r\n\r\n            roiContours.push(ROIContour);\r\n        }\r\n    });\r\n\r\n    const rtMetadata = {\r\n        name: segmentations.label,\r\n        label: segmentations.label\r\n    };\r\n\r\n    const dataset = _initializeDataset(\r\n        rtMetadata,\r\n        roiContours[0].metadata,\r\n        metadataProvider\r\n    );\r\n\r\n    roiContours.forEach((contour, index) => {\r\n        const roiContour = {\r\n            ROIDisplayColor: contour.color || [255, 0, 0],\r\n            ContourSequence: contour.contourSequence,\r\n            ReferencedROINumber: index + 1\r\n        };\r\n\r\n        dataset.StructureSetROISequence.push(\r\n            getStructureSetModule(contour, index)\r\n        );\r\n\r\n        dataset.ROIContourSequence.push(roiContour);\r\n\r\n        // ReferencedSeriesSequence\r\n        dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(\r\n            contour.metadata,\r\n            index,\r\n            metadataProvider,\r\n            DicomMetadataStore\r\n        );\r\n\r\n        // ReferencedFrameOfReferenceSequence\r\n        dataset.ReferencedFrameOfReferenceSequence =\r\n            getReferencedFrameOfReferenceSequence(\r\n                contour.metadata,\r\n                metadataProvider,\r\n                dataset\r\n            );\r\n    });\r\n\r\n    const fileMetaInformationVersionArray = new Uint8Array(2);\r\n    fileMetaInformationVersionArray[1] = 1;\r\n\r\n    const _meta = {\r\n        FileMetaInformationVersion: {\r\n            Value: [fileMetaInformationVersionArray.buffer],\r\n            vr: \"OB\"\r\n        },\r\n        TransferSyntaxUID: {\r\n            Value: [\"1.2.840.10008.1.2.1\"],\r\n            vr: \"UI\"\r\n        },\r\n        ImplementationClassUID: {\r\n            Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\r\n            vr: \"UI\"\r\n        },\r\n        ImplementationVersionName: {\r\n            Value: [\"dcmjs\"],\r\n            vr: \"SH\"\r\n        }\r\n    };\r\n\r\n    dataset._meta = _meta;\r\n    dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n\r\n    return dataset;\r\n}\r\n\r\n/**\r\n * Convert handles to RTSSReport report object containing the dcmjs dicom dataset.\r\n *\r\n * Note: The tool data needs to be formatted in a specific way, and currently\r\n * it is limited to the RectangleROIStartEndTool in the Cornerstone.\r\n *\r\n * @param annotations - Array of Cornerstone tool annotation data\r\n * @param metadataProvider -  Metadata provider\r\n * @returns Report object containing the dataset\r\n */\r\nfunction generateRTSSFromAnnotations(\r\n    annotations,\r\n    metadataProvider,\r\n    DicomMetadataStore\r\n) {\r\n    const rtMetadata = {\r\n        name: \"RTSS from Annotations\",\r\n        label: \"RTSS from Annotations\"\r\n    };\r\n    const dataset = _initializeDataset(\r\n        rtMetadata,\r\n        annotations[0].metadata,\r\n        metadataProvider\r\n    );\r\n\r\n    annotations.forEach((annotation, index) => {\r\n        const ContourSequence = AnnotationToPointData.convert(\r\n            annotation,\r\n            index,\r\n            metadataProvider\r\n        );\r\n\r\n        dataset.StructureSetROISequence.push(\r\n            getStructureSetModule(annotation, index)\r\n        );\r\n\r\n        dataset.ROIContourSequence.push(ContourSequence);\r\n        dataset.RTROIObservationsSequence.push(\r\n            getRTROIObservationsSequence(annotation, index)\r\n        );\r\n\r\n        // ReferencedSeriesSequence\r\n        // Todo: handle more than one series\r\n        dataset.ReferencedSeriesSequence = getReferencedSeriesSequence(\r\n            annotation.metadata,\r\n            index,\r\n            metadataProvider,\r\n            DicomMetadataStore\r\n        );\r\n\r\n        // ReferencedFrameOfReferenceSequence\r\n        dataset.ReferencedFrameOfReferenceSequence =\r\n            getReferencedFrameOfReferenceSequence(\r\n                annotation.metadata,\r\n                metadataProvider,\r\n                dataset\r\n            );\r\n    });\r\n\r\n    const fileMetaInformationVersionArray = new Uint8Array(2);\r\n    fileMetaInformationVersionArray[1] = 1;\r\n\r\n    const _meta = {\r\n        FileMetaInformationVersion: {\r\n            Value: [fileMetaInformationVersionArray.buffer],\r\n            vr: \"OB\"\r\n        },\r\n        TransferSyntaxUID: {\r\n            Value: [\"1.2.840.10008.1.2.1\"],\r\n            vr: \"UI\"\r\n        },\r\n        ImplementationClassUID: {\r\n            Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\r\n            vr: \"UI\"\r\n        },\r\n        ImplementationVersionName: {\r\n            Value: [\"dcmjs\"],\r\n            vr: \"SH\"\r\n        }\r\n    };\r\n\r\n    dataset._meta = _meta;\r\n    dataset.SpecificCharacterSet = \"ISO_IR 192\";\r\n\r\n    return dataset;\r\n}\r\n\r\n// /**\r\n//  * Generate Cornerstone tool state from dataset\r\n//  * @param {object} dataset dataset\r\n//  * @param {object} hooks\r\n//  * @param {function} hooks.getToolClass Function to map dataset to a tool class\r\n//  * @returns\r\n//  */\r\n// //static generateToolState(_dataset, _hooks = {}) {\r\n// function generateToolState() {\r\n//     // Todo\r\n//     console.warn(\"RTSS.generateToolState not implemented\");\r\n// }\r\n\r\nfunction _initializeDataset(rtMetadata, imgMetadata, metadataProvider) {\r\n    const rtSOPInstanceUID = DicomMetaDictionary.uid();\r\n\r\n    // get the first annotation data\r\n    const { referencedImageId: imageId, FrameOfReferenceUID } = imgMetadata;\r\n\r\n    const { studyInstanceUID } = metadataProvider.get(\r\n        \"generalSeriesModule\",\r\n        imageId\r\n    );\r\n\r\n    const patientModule = getPatientModule(imageId, metadataProvider);\r\n    const rtSeriesModule = getRTSeriesModule(DicomMetaDictionary);\r\n\r\n    return {\r\n        StructureSetROISequence: [],\r\n        ROIContourSequence: [],\r\n        RTROIObservationsSequence: [],\r\n        ReferencedSeriesSequence: [],\r\n        ReferencedFrameOfReferenceSequence: [],\r\n        ...patientModule,\r\n        ...rtSeriesModule,\r\n        StudyInstanceUID: studyInstanceUID,\r\n        SOPClassUID: \"1.2.840.10008.5.1.4.1.1.481.3\", // RT Structure Set Storage\r\n        SOPInstanceUID: rtSOPInstanceUID,\r\n        Manufacturer: \"dcmjs\",\r\n        Modality: \"RTSTRUCT\",\r\n        FrameOfReferenceUID,\r\n        PositionReferenceIndicator: \"\",\r\n        StructureSetLabel: rtMetadata.label || \"\",\r\n        StructureSetName: rtMetadata.name || \"\",\r\n        ReferringPhysicianName: \"\",\r\n        OperatorsName: \"\",\r\n        StructureSetDate: DicomMetaDictionary.date(),\r\n        StructureSetTime: DicomMetaDictionary.time(),\r\n        _meta: null\r\n    };\r\n}\r\n\r\nexport { generateRTSSFromSegmentations, generateRTSSFromAnnotations };\r\n","export default function getPatientModule(imageId, metadataProvider) {\r\n    const generalSeriesModule = metadataProvider.get(\r\n        \"generalSeriesModule\",\r\n        imageId\r\n    );\r\n    const generalStudyModule = metadataProvider.get(\r\n        \"generalStudyModule\",\r\n        imageId\r\n    );\r\n    const patientStudyModule = metadataProvider.get(\r\n        \"patientStudyModule\",\r\n        imageId\r\n    );\r\n    const patientModule = metadataProvider.get(\"patientModule\", imageId);\r\n    const patientDemographicModule = metadataProvider.get(\r\n        \"patientDemographicModule\",\r\n        imageId\r\n    );\r\n\r\n    return {\r\n        Modality: generalSeriesModule.modality,\r\n        PatientID: patientModule.patientId,\r\n        PatientName: patientModule.patientName,\r\n        PatientBirthDate: \"\",\r\n        PatientAge: patientStudyModule.patientAge,\r\n        PatientSex: patientDemographicModule.patientSex,\r\n        PatientWeight: patientStudyModule.patientWeight,\r\n        StudyDate: generalStudyModule.studyDate,\r\n        StudyTime: generalStudyModule.studyTime,\r\n        StudyID: \"ToDo\",\r\n        AccessionNumber: generalStudyModule.accessionNumber\r\n    };\r\n}\r\n","export default function getRTSeriesModule(DicomMetaDictionary) {\r\n    return {\r\n        SeriesInstanceUID: DicomMetaDictionary.uid(), // generate a new series instance uid\r\n        SeriesNumber: \"99\" // Todo:: what should be the series number?\r\n    };\r\n}\r\n","import { utilities } from \"@cornerstonejs/tools\";\r\nimport {\r\n    generateRTSSFromAnnotations,\r\n    generateRTSSFromSegmentations\r\n} from \"./RTSS\";\r\n\r\nconst { generateContourSetsFromLabelmap } = utilities.contours;\r\n\r\nexport {\r\n    generateContourSetsFromLabelmap,\r\n    generateRTSSFromAnnotations,\r\n    generateRTSSFromSegmentations\r\n};\r\n","export default function getRTROIObservationsSequence(toolData, index) {\r\n    return {\r\n        ObservationNumber: index + 1,\r\n        ReferencedROINumber: index + 1,\r\n        RTROIInterpretedType: \"Todo: type\",\r\n        ROIInterpreter: \"Todo: interpreter\"\r\n    };\r\n}\r\n","import MeasurementReport from \"./MeasurementReport\";\r\nimport CodeScheme from \"./CodingScheme\";\r\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\r\n\r\nimport ArrowAnnotate from \"./ArrowAnnotate\";\r\nimport Bidirectional from \"./Bidirectional\";\r\nimport Angle from \"./Angle\";\r\nimport CobbAngle from \"./CobbAngle\";\r\nimport CircleROI from \"./CircleROI\";\r\nimport EllipticalROI from \"./EllipticalROI\";\r\nimport RectangleROI from \"./RectangleROI\";\r\nimport Length from \"./Length\";\r\nimport PlanarFreehandROI from \"./PlanarFreehandROI\";\r\nimport Probe from \"./Probe\";\r\nimport UltrasoundDirectional from \"./UltrasoundDirectional\";\r\n\r\nimport * as Segmentation from \"./Segmentation\";\r\nimport * as RTSS from \"./RTStruct\";\r\n\r\nconst Cornerstone3DSR = {\r\n    Bidirectional,\r\n    CobbAngle,\r\n    Angle,\r\n    Length,\r\n    CircleROI,\r\n    EllipticalROI,\r\n    RectangleROI,\r\n    ArrowAnnotate,\r\n    Probe,\r\n    PlanarFreehandROI,\r\n    UltrasoundDirectional,\r\n    MeasurementReport,\r\n    CodeScheme,\r\n    CORNERSTONE_3D_TAG\r\n};\r\n\r\nconst Cornerstone3DSEG = {\r\n    Segmentation\r\n};\r\n\r\nconst Cornerstone3DRT = {\r\n    RTSS\r\n};\r\n\r\nexport { Cornerstone3DSR, Cornerstone3DSEG, Cornerstone3DRT };\r\n","import { data } from \"dcmjs\";\r\n\r\nconst { Colors, BitArray } = data;\r\n\r\n// TODO: Is there a better name for this? RGBAInt?\r\n// Should we move it to Colors.js\r\nfunction dicomlab2RGBA(cielab) {\r\n    const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\r\n    rgba.push(255);\r\n\r\n    return rgba;\r\n}\r\n\r\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\r\n// I guess we should put them somewhere\r\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\r\nfunction cross(x, y, out) {\r\n    const Zx = x[1] * y[2] - x[2] * y[1];\r\n    const Zy = x[2] * y[0] - x[0] * y[2];\r\n    const Zz = x[0] * y[1] - x[1] * y[0];\r\n    out[0] = Zx;\r\n    out[1] = Zy;\r\n    out[2] = Zz;\r\n}\r\n\r\nfunction norm(x, n = 3) {\r\n    switch (n) {\r\n        case 1:\r\n            return Math.abs(x);\r\n        case 2:\r\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\r\n        case 3:\r\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\r\n        default: {\r\n            let sum = 0;\r\n            for (let i = 0; i < n; i++) {\r\n                sum += x[i] * x[i];\r\n            }\r\n            return Math.sqrt(sum);\r\n        }\r\n    }\r\n}\r\n\r\nfunction normalize(x) {\r\n    const den = norm(x);\r\n    if (den !== 0.0) {\r\n        x[0] /= den;\r\n        x[1] /= den;\r\n        x[2] /= den;\r\n    }\r\n    return den;\r\n}\r\n\r\nfunction subtract(a, b, out) {\r\n    out[0] = a[0] - b[0];\r\n    out[1] = a[1] - b[1];\r\n    out[2] = a[2] - b[2];\r\n}\r\n\r\n// TODO: This is a useful utility on its own. We should move it somewhere?\r\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\r\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\r\n    const geometry = {};\r\n    const pixelMeasures =\r\n        dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\r\n    const planeOrientation =\r\n        dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\r\n\r\n    // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\r\n    //\r\n    // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\r\n    // sort them to obtain the first and last position along the acquisition axis.\r\n    const firstFunctionalGroup = PerFrameFunctionalGroups[0];\r\n    const lastFunctionalGroup =\r\n        PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\r\n    const firstPosition =\r\n        firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\r\n            Number\r\n        );\r\n    const lastPosition =\r\n        lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\r\n            Number\r\n        );\r\n\r\n    geometry.origin = firstPosition;\r\n\r\n    // NB: DICOM PixelSpacing is defined as Row then Column,\r\n    // unlike ImageOrientationPatient\r\n    geometry.spacing = [\r\n        pixelMeasures.PixelSpacing[1],\r\n        pixelMeasures.PixelSpacing[0],\r\n        pixelMeasures.SpacingBetweenSlices\r\n    ].map(Number);\r\n\r\n    geometry.dimensions = [\r\n        dataset.Columns,\r\n        dataset.Rows,\r\n        PerFrameFunctionalGroups.length\r\n    ].map(Number);\r\n\r\n    const orientation = planeOrientation.ImageOrientationPatient.map(Number);\r\n    const columnStepToPatient = orientation.slice(0, 3);\r\n    const rowStepToPatient = orientation.slice(3, 6);\r\n\r\n    geometry.planeNormal = [];\r\n\r\n    cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\r\n\r\n    geometry.sliceStep = [];\r\n    subtract(lastPosition, firstPosition, geometry.sliceStep);\r\n    normalize(geometry.sliceStep);\r\n    geometry.direction = columnStepToPatient\r\n        .concat(rowStepToPatient)\r\n        .concat(geometry.sliceStep);\r\n\r\n    return geometry;\r\n}\r\n\r\nexport default class Segmentation {\r\n    constructor() {}\r\n\r\n    /**\r\n     * Produces an array of Segments from an input DICOM Segmentation dataset\r\n     *\r\n     * Segments are returned with Geometry values that can be used to create\r\n     * VTK Image Data objects.\r\n     *\r\n     * @example Example usage to create VTK Volume actors from each segment:\r\n     *\r\n     * const actors = [];\r\n     * const segments = generateToolState(dataset);\r\n     * segments.forEach(segment => {\r\n     *   // now make actors using the segment information\r\n     *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\r\n     *        name: \"Scalars\",\r\n     *        numberOfComponents: 1,\r\n     *        values: segment.pixelData,\r\n     *    });\r\n     *\r\n     *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\r\n     *    imageData.getPointData().setScalars(scalarArray);\r\n     *    imageData.setDimensions(geometry.dimensions);\r\n     *    imageData.setSpacing(geometry.spacing);\r\n     *    imageData.setOrigin(geometry.origin);\r\n     *    imageData.setDirection(geometry.direction);\r\n     *\r\n     *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\r\n     *    mapper.setInputData(imageData);\r\n     *    mapper.setSampleDistance(2.);\r\n     *\r\n     *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\r\n     *    actor.setMapper(mapper);\r\n     *\r\n     *    actors.push(actor);\r\n     * });\r\n     *\r\n     * @param dataset\r\n     * @return {{}}\r\n     */\r\n    static generateSegments(dataset) {\r\n        if (dataset.SegmentSequence.constructor.name !== \"Array\") {\r\n            dataset.SegmentSequence = [dataset.SegmentSequence];\r\n        }\r\n\r\n        dataset.SegmentSequence.forEach(segment => {\r\n            // TODO: other interesting fields could be extracted from the segment\r\n            // TODO: Read SegmentsOverlay field\r\n            // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\r\n\r\n            // TODO: Looks like vtkColor only wants RGB in 0-1 values.\r\n            // Why was this example converting to RGBA with 0-255 values?\r\n            const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\r\n\r\n            segments[segment.SegmentNumber] = {\r\n                color,\r\n                functionalGroups: [],\r\n                offset: null,\r\n                size: null,\r\n                pixelData: null\r\n            };\r\n        });\r\n\r\n        // make a list of functional groups per segment\r\n        dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\r\n            const segmentNumber =\r\n                functionalGroup.SegmentIdentificationSequence\r\n                    .ReferencedSegmentNumber;\r\n\r\n            segments[segmentNumber].functionalGroups.push(functionalGroup);\r\n        });\r\n\r\n        // determine per-segment index into the pixel data\r\n        // TODO: only handles one-bit-per pixel\r\n        const frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\r\n        let nextOffset = 0;\r\n\r\n        Object.keys(segments).forEach(segmentNumber => {\r\n            const segment = segments[segmentNumber];\r\n\r\n            segment.numberOfFrames = segment.functionalGroups.length;\r\n            segment.size = segment.numberOfFrames * frameSize;\r\n            segment.offset = nextOffset;\r\n\r\n            nextOffset = segment.offset + segment.size;\r\n\r\n            const packedSegment = dataset.PixelData.slice(\r\n                segment.offset,\r\n                nextOffset\r\n            );\r\n\r\n            segment.pixelData = BitArray.unpack(packedSegment);\r\n\r\n            const geometry = geometryFromFunctionalGroups(\r\n                dataset,\r\n                segment.functionalGroups\r\n            );\r\n\r\n            segment.geometry = geometry;\r\n        });\r\n\r\n        return segments;\r\n    }\r\n}\r\n","import { CornerstoneSR, CornerstoneSEG } from \"./Cornerstone\";\r\nimport {\r\n    Cornerstone3DSR,\r\n    Cornerstone3DSEG,\r\n    Cornerstone3DRT\r\n} from \"./Cornerstone3D\";\r\nimport { VTKjsSEG } from \"./VTKjs\";\r\nimport * as Enums from \"./enums\";\r\nimport * as helpers from \"./helpers\";\r\n\r\nconst adaptersSR = {\r\n    Cornerstone: CornerstoneSR,\r\n    Cornerstone3D: Cornerstone3DSR\r\n};\r\n\r\nconst adaptersSEG = {\r\n    Cornerstone: CornerstoneSEG,\r\n    Cornerstone3D: Cornerstone3DSEG,\r\n    VTKjs: VTKjsSEG\r\n};\r\n\r\nconst adaptersRT = {\r\n    Cornerstone3D: Cornerstone3DRT\r\n};\r\n\r\nexport { adaptersSR, adaptersSEG, adaptersRT, Enums, helpers };\r\n","import Segmentation from \"./Segmentation\";\r\n\r\nconst VTKjsSEG = {\r\n    Segmentation\r\n};\r\n\r\nexport { VTKjsSEG };\r\n"],"names":["toArray","x","Array","isArray","codeMeaningEquals","codeMeaningName","contentItem","ConceptNameCodeSequence","CodeMeaning","datasetToDict","bufferOrDataset","filename","blob","ArrayBuffer","Blob","type","_meta","Error","buffer","from","write","link","document","createElement","href","window","URL","createObjectURL","download","click","graphicType","GraphicType","TID1500","utilities","addAccessors","StructuredReport","derivations","Normalizer","normalizers","TID1500MeasurementReport","TID1501MeasurementGroup","DicomMetaDictionary","data","FINDING","CodingSchemeDesignator","CodeValue","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","group","code","oldCode","MeasurementReport","_classCallCheck","_createClass","key","value","MeasurementGroup","ContentSequence","contentSequenceArr","findingGroup","find","findingSiteGroups","filter","NUMGroup","ValueType","SCOORDGroup","ReferencedSOPSequence","ReferencedSOPInstanceUID","ReferencedFrameNumber","defaultState","sopInstanceUid","frameIndex","complete","finding","ConceptCodeSequence","undefined","findingSites","map","fsg","description","findingSite","location","toolState","metadataProvider","options","allMeasurementGroups","firstImageId","Object","keys","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","forEach","imageId","sopCommonModule","frameNumber","toolData","toolTypes","ReferencedSOPClassUID","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","measurementGroups","toolType","toolTypeData","toolClass","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","length","Measurements","tool","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem","getMeasurementGroup","push","concat","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","StudyInstanceUID","SeriesInstanceUID","FileMetaInformationVersion","Value","vr","TransferSyntaxUID","ImplementationClassUID","uid","ImplementationVersionName","_vrMap","PixelData","report","dataset","assign","SpecificCharacterSet","hooks","arguments","ContentTemplateSequence","TemplateIdentifier","imagingMeasurementContent","measurementData","cornerstoneToolClasses","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","registeredToolClasses","measurementGroup","TrackingIdentifierValue","TextValue","getToolClass","tc","isValidCornerstoneTrackingIdentifier","measurement","getMeasurementData","console","log","utilityToolType","MEASUREMENT_BY_TOOLTYPE","TID300Length","TID300","Length","LENGTH","_MeasurementReport$ge","getSetupMeasurementData","state","_objectSpread","MeasuredValueSequence","NumericValue","handles","start","end","textBox","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","_SCOORDGroup$GraphicD","_slicedToArray","GraphicData","y","point1","point2","distance","trackingIdentifierTextValue","TrackingIdentifier","includes","_TrackingIdentifier$s2","split","cornerstone4Tag","CORNERSTONE_4_TAG","registerTool","TID300Polyline","Polyline","FreehandRoi","points","active","cachedStats","area","color","invalidated","i","_tool$cachedStats","_cachedStats$area","_cachedStats$perimete","perimeter","TID300Bidirectional","Bidirectional","BIDIRECTIONAL","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","bottomRight","Math","max","highlight","index","perpendicularStart","perpendicularEnd","isCreating","toolName","visible","_tool$handles","longAxis","shortAxis","longAxisLength","shortAxisLength","TID300Ellipse","Ellipse","ELLIPTICALROI","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","abs","halfYLength","center","TID300Circle","Circle","CIRCLEROI","CircleRoi","radius","PI","TID300Point","Point","ARROW_ANNOTATE","CORNERSTONEFREETEXT","ArrowAnnotate","text","TID300RepresentationArguments","TID300CobbAngle","CobbAngle","COBB_ANGLE","rAngle","start2","end2","point3","point4","TID300Angle","Angle","ANGLE","middle","RectangleRoi","_utilities$orientatio","orientation","rotateDirectionCosinesInPlane","flipIOP","flipImageOrientationPatient","flipMatrix2D","rotateMatrix902D","datasetToBlob","BitArray","DicomMessage","SegmentationDerivation","Segmentation","generateSegmentation","images","brushData","includeSliceSpacing","segments","image0","dims","columns","rows","z","xy","_getSegCount","seg","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","multiframe","normalizeToDataset","_createSegFromImages","_getNumberOfFramesPer","segmentIndicies","referencedFramesPerSegment","imageIdSpecificToolState","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","element","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","generateToolState","imageIds","imagePlaneModule","warn","validOrientations","iop","orientations","h","v","iop90","getValidOrientations","rowCosines","_toConsumableArray","columnCosines","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData","ndarray","SegmentIdentificationSequence","ReferencedSegmentNumber","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","DerivationImageSequence","SourceImageSequence","referencedFrames","pixelDataIndex","brushPixelData","p","numSegments","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","Number","getImageIdOfReferencedFrame","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","Events","dx","iop1","iop2","nearlyEqual","dcmjsData","_utilities$compressio","compression","encode","decode","generateSegmentationDefaultOptions","rleEncode","fillSegmentation","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","_loop","labelmap3D","labelmapIndex","labelmaps2D","metadata","_loop2","_i","labelmap2D","segmentsOnLabelmap","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","frame","_generateToolState","_regenerator","m","_callee","_options$skipOverlapp","skipOverlapping","_options$tolerance","tolerance","_options$TypedArrayCo","TypedArrayConstructor","_options$maxBytesPerC","maxBytesPerChunk","eventTarget","triggerEvent","pixelDataChunks","sopUIDImageIdIndexMap","overlapping","insertFunction","segmentsOnFrameArray","segmentsOnFrame","arrayBufferLength","labelmapBufferArray","imageIdMaps","segmentsPixelIndices","overlappingSegments","centroidXYZ","_t","w","_context","n","a","checkOrientation","reduce","acc","checkSEGsOverlapping","insertOverlappingPixelDataPlanar","insertPixelDataPlanar","BYTES_PER_ELEMENT","curr","indices","Map","imageIdIndexBufferIndex","_calculateCentroid","calculateCentroid","xAcc","yAcc","zAcc","count","set","floor","centroids","apply","findReferenceSourceImageId","frameSegment","FrameOfReferenceUID","PerFrameFunctionalGroup","frameSourceImageSequence","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","imageIdsIndexc","sourceImageMetadata","compareArrays","getImageIdOfSourceImagebyGeometry","groupsLen","frameSegmentsMapping","_loop3","getSegmentIndex","imageIdIndex","findIndex","has","segmentArray","_step","_iterator","_createForOfIteratorHelper","entries","s","done","role","temp2DArray","fill","view","readFromUnpackedChunks","j","len","err","e","f","M","tempBuffer","slice","tempSegmentsOnFrame","cloneDeep","numberOfSegs","segmentIndexToProcess","_loop4","_i2","byteOffset","labelmap2DView","segmentOnFrame","chunkSize","ceil","shouldTriggerEvent","Promise","resolve","processInChunks","min","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","sourceDataDimensions","some","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","error","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","endByte","chunk","unpackedChunk","getUnpackedChunks","array1","array2","offset","mapping","totalBytes","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","_i3","_Object$entries","_Object$entries$_i","bufferIndices","_step2","_iterator2","bufferIndex","_x","_x2","_x3","_x4","CornerstoneSR","CornerstoneSEG","labelmaps3DorBrushData","cornerstoneToolsVersion","Segmentation_4X","Segmentation_3X","__assign","t","prototype","hasOwnProperty","call","this","__spreadArray","to","pack","ar","l","SuppressedError","CodingScheme","codeValues","worldToImageCoords","cornersoneFreeTextCodingValue","Cornerstone3DCodingScheme","freeTextLabel","fs","generateDatasetMeta","sopInstanceUIDToImageIdMap","referencedImageId","annotation","annotationUID","frameOfReferenceUID","label","getCornerstoneLabelFromDefaultState","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","instance","dsd","generateDerivationSourceDataset","tid1500MeasurementReport","imageToWorldCoords","measurementGroupContentSequence","TrackingUniqueIdentifierGroup","TrackingUniqueIdentifierValue","UID","TrackingUniqueIdentifier","CORNERSTONE_3D_TAG","worldCoords","point","imagePixelModule","xOffset","yOffset","secondPoint","arrowFirst","activeHandleIndex","_data$handles","pointImage","cornerstone3DTag","width","shortAxisPoints","longAxisPoints","firstPointPairs","secondPointPairs","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","MEASUREMENT_TYPE","angle","start1","end1","trackingIdentifier","toLowerCase","CircleROI","pointsWorld","worldPos","EPSILON","EllipticalROI","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","ellipsePoints","top","bottom","left","right","rotation","TOOLTYPE","RectangleROI","corners","_defineProperty","_data$cachedStats","PLANARFREEHANDROI","PlanarFreehandROI","isOpenContour","pop","contour","polyline","closed","firstPoint","areaUnit","modalityUnit","mean","stdDev","PROBE","Probe","ULTRASOUND_DIRECTIONAL","UltrasoundDirectional","generateToolStateCornerstoneLegacy","scalarData","dimensions","segmentsOnLabelmap3D","Set","add","image","SOPClassUID","SopClassUID","SOPInstanceUID","SopInstanceUID","getPixelData","_createMultiframeSegmentationFromReferencedImages","getReferencedFrameOfReferenceSequence","RTReferencedStudySequence","RTReferencedSeriesSequence","ContourImageSequence","ReferencedInstanceSequence","getReferencedSeriesSequence","_index","DicomMetadataStore","series","getSeries","ReferencedSeries","instances","getStructureSetModule","ROINumber","ROIName","name","ROIDescription","ROIGenerationAlgorithm","ReferencedFrameOfReferenceUID","generateContourSetsFromLabelmap","AnnotationToPointData","_initializeDataset","rtMetadata","imgMetadata","rtSOPInstanceUID","patientModule","generalStudyModule","patientStudyModule","patientDemographicModule","Modality","modality","PatientID","patientId","PatientName","patientName","PatientBirthDate","PatientAge","patientAge","PatientSex","patientSex","PatientWeight","patientWeight","StudyDate","studyDate","StudyTime","studyTime","StudyID","AccessionNumber","accessionNumber","getPatientModule","rtSeriesModule","SeriesNumber","getRTSeriesModule","StructureSetROISequence","ROIContourSequence","RTROIObservationsSequence","ReferencedFrameOfReferenceSequence","Manufacturer","PositionReferenceIndicator","StructureSetLabel","StructureSetName","ReferringPhysicianName","OperatorsName","StructureSetDate","date","StructureSetTime","time","annotations","ContourSequence","convert","ObservationNumber","ReferencedROINumber","RTROIInterpretedType","ROIInterpreter","getRTROIObservationsSequence","segmentations","roiContours","contourSet","segIndex","sliceContours","sliceContour","sopCommon","sliceContourPolyData","polyData","contours","ContourGeometricType","NumberOfContourPoints","contourPoints","ContourData","pointData","toFixed","ContourNumber","segLabel","ROIContour","contourSequence","roiContour","ROIDisplayColor","Cornerstone3DSR","CodeScheme","Cornerstone3DSEG","Cornerstone3DRT","RTSS","Colors","normalize","den","sum","norm","adaptersSR","Cornerstone","Cornerstone3D","adaptersSEG","VTKjs","constructor","cielab","rgba","RecommendedDisplayCIELabValue","dicomlab2RGB","SegmentNumber","functionalGroups","size","functionalGroup","segmentNumber","frameSize","nextOffset","packedSegment","geometry","pixelMeasures","PixelMeasuresSequence","planeOrientation","firstFunctionalGroup","lastFunctionalGroup","firstPosition","lastPosition","origin","spacing","PixelSpacing","SpacingBetweenSlices","out","Zx","Zy","Zz","columnStepToPatient","rowStepToPatient","planeNormal","sliceStep","b","subtract","direction","geometryFromFunctionalGroups","adaptersRT"],"sourceRoot":""}